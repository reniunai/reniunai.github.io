import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as s,a as e,e as a,o as n}from"./app-zamys2Ga.js";const c={},o=e("p",null,"Redis缓存数据和数据库数据如何保持一致性",-1),p=e("p",null,"对于这种两个库如何保证一致性的问题，可以从两大方式去讨论。",-1),l=e("p",null,"一、同步还是异步，",-1),h=e("p",null,"二、需要强一致性还是最终一致性。",-1),r=a('<h1 id="同步" tabindex="-1"><a class="header-anchor" href="#同步"><span>同步</span></a></h1><h2 id="双写模式" tabindex="-1"><a class="header-anchor" href="#双写模式"><span>双写模式</span></a></h2><p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致。</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170311991.png" alt="image-20240717031153944" tabindex="0" loading="lazy"><figcaption>image-20240717031153944</figcaption></figure><h2 id="失效模式" tabindex="-1"><a class="header-anchor" href="#失效模式"><span>失效模式</span></a></h2><p>数据库更新后，将缓存中数据删除，等待下次主动查询进行更新</p><p>缺点：在删除缓存前，有请求读到缓存，那么读取到的数据就不是最新的</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170312933.png" alt="image-20240717031245889" tabindex="0" loading="lazy"><figcaption>image-20240717031245889</figcaption></figure><h3 id="先删除缓存-后更新数据库" tabindex="-1"><a class="header-anchor" href="#先删除缓存-后更新数据库"><span>先删除缓存，后更新数据库</span></a></h3><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170319607.png" alt="image-20240717031931497" tabindex="0" loading="lazy"><figcaption>image-20240717031931497</figcaption></figure><h3 id="先更新数据库-后删除缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库-后删除缓存"><span>先更新数据库，后删除缓存</span></a></h3><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170321502.png" alt="image-20240717032141396" tabindex="0" loading="lazy"><figcaption>image-20240717032141396</figcaption></figure><p>无论是先删数据库还是先删缓存，都是会出现问题，包括下面的延时双删也是不能保证100%的一致性，需要强一致性那么要加锁。</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170400166.png" alt="image-20240717040018130" tabindex="0" loading="lazy"><figcaption>image-20240717040018130</figcaption></figure><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170400425.png" alt="image-20240717040036393" tabindex="0" loading="lazy"><figcaption>image-20240717040036393</figcaption></figure><h3 id="延迟双删" tabindex="-1"><a class="header-anchor" href="#延迟双删"><span>延迟双删</span></a></h3><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间 写操作：延迟双删（因为数据有变更，数据在写的过程中，并发读会产生脏数据）</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170322666.png" alt="image-20240717032251588" tabindex="0" loading="lazy"><figcaption>image-20240717032251588</figcaption></figure><p>若是网络延迟，在箭头处才写入旧数据的缓存，还是会出现问题。</p><p>此外，因为删除缓存和更新数据库不是原子操作，还可能会出现问题。这种方案只适合最终一致性，想要强一致性就加锁或者直接去掉Rredis直接去MySQL查。或者去掉MySQL，直接全部数据放Redis再持久化，这样就不用考虑一致性问题。</p><h2 id="加锁-强一致性" tabindex="-1"><a class="header-anchor" href="#加锁-强一致性"><span>加锁（强一致性）</span></a></h2><p>采用Redisson提供的读写锁</p><p>①共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</p><p>②排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作</p><h1 id="异步-最终一致性" tabindex="-1"><a class="header-anchor" href="#异步-最终一致性"><span>异步-最终一致性</span></a></h1><p>基于MQ</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170008642.png" alt="image-20240717000827587" tabindex="0" loading="lazy"><figcaption>image-20240717000827587</figcaption></figure><p>基于Canal</p><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170736886.png" alt="image-20240717073627838" tabindex="0" loading="lazy"><figcaption>image-20240717073627838</figcaption></figure><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170736198.png" alt="image-20240717073638153" tabindex="0" loading="lazy"><figcaption>image-20240717073638153</figcaption></figure><h1 id="缓存数据一致性解决方案" tabindex="-1"><a class="header-anchor" href="#缓存数据一致性解决方案"><span>缓存数据一致性解决方案</span></a></h1><ul><li><p>无论是双写模式还是失效模式，都会导致缓存的不一致问题。即多个实例同时更新会出事。怎么办？</p><ul><li>1、如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可</li><li>2、如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式。</li><li>3、缓存数据+过期时间也足够解决大部分业务对于缓存的要求。</li><li>4、通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）；</li></ul></li><li><p>总结：</p><ul><li>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。</li><li>我们不应该过度设计，增加系统的复杂性</li><li>遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</li></ul></li></ul><figure><img src="https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170316281.png" alt="image-20240717031606230" tabindex="0" loading="lazy"><figcaption>image-20240717031606230</figcaption></figure>',33);function g(m,d){return n(),t("div",null,[o,p,l,h,s(" more "),r])}const y=i(c,[["render",g],["__file","4.Redis缓存数据和数据库数据一致性.html.vue"]]),_=JSON.parse('{"path":"/note/redis/4.Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.html","title":"Redis缓存数据和数据库数据一致性","lang":"zh-CN","frontmatter":{"title":"Redis缓存数据和数据库数据一致性","cover":"/assets/images/cover1.jpg","icon":"file","order":3,"author":"HotMilk","category":["Redis"],"tag":["一致性","缓存数据和数据库数据一致性"],"description":"Redis缓存数据和数据库数据如何保持一致性 对于这种两个库如何保证一致性的问题，可以从两大方式去讨论。 一、同步还是异步， 二、需要强一致性还是最终一致性。","head":[["meta",{"property":"og:url","content":"https://reniunai.github.io/note/redis/4.Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"热牛奶"}],["meta",{"property":"og:title","content":"Redis缓存数据和数据库数据一致性"}],["meta",{"property":"og:description","content":"Redis缓存数据和数据库数据如何保持一致性 对于这种两个库如何保证一致性的问题，可以从两大方式去讨论。 一、同步还是异步， 二、需要强一致性还是最终一致性。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://reniunai.github.io/assets/images/cover1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-05T08:48:07.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://reniunai.github.io/assets/images/cover1.jpg"}],["meta",{"name":"twitter:image:alt","content":"Redis缓存数据和数据库数据一致性"}],["meta",{"property":"article:author","content":"HotMilk"}],["meta",{"property":"article:tag","content":"一致性"}],["meta",{"property":"article:tag","content":"缓存数据和数据库数据一致性"}],["meta",{"property":"article:modified_time","content":"2024-08-05T08:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis缓存数据和数据库数据一致性\\",\\"image\\":[\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170311991.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170312933.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170319607.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170321502.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170400166.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170400425.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170322666.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170008642.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170736886.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170736198.png\\",\\"https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407170316281.png\\"],\\"dateModified\\":\\"2024-08-05T08:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HotMilk\\"}]}"]]},"headers":[{"level":2,"title":"双写模式","slug":"双写模式","link":"#双写模式","children":[]},{"level":2,"title":"失效模式","slug":"失效模式","link":"#失效模式","children":[{"level":3,"title":"先删除缓存，后更新数据库","slug":"先删除缓存-后更新数据库","link":"#先删除缓存-后更新数据库","children":[]},{"level":3,"title":"先更新数据库，后删除缓存","slug":"先更新数据库-后删除缓存","link":"#先更新数据库-后删除缓存","children":[]},{"level":3,"title":"延迟双删","slug":"延迟双删","link":"#延迟双删","children":[]}]},{"level":2,"title":"加锁（强一致性）","slug":"加锁-强一致性","link":"#加锁-强一致性","children":[]}],"git":{"createdTime":1722847687000,"updatedTime":1722847687000,"contributors":[{"name":"reniunai","email":"2843768@qq.com","commits":1}]},"readingTime":{"minutes":3.54,"words":1061},"filePathRelative":"note/redis/4.Redis缓存数据和数据库数据一致性.md","localizedDate":"2024年8月5日","excerpt":"<p>Redis缓存数据和数据库数据如何保持一致性</p>\\n<p>对于这种两个库如何保证一致性的问题，可以从两大方式去讨论。</p>\\n<p>一、同步还是异步，</p>\\n<p>二、需要强一致性还是最终一致性。</p>\\n","autoDesc":true}');export{y as comp,_ as data};
