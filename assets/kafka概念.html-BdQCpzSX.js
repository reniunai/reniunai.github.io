import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,a as o,e as p,o as r}from"./app-Bv3jHGDE.js";const i={},n=o("p",null,"kafka概念",-1),c=p('<p>kafka是一款消息队列，消息队列有三个作用，削峰，解耦，异步。</p><p>kafka常用的组件</p><h1 id="消息发送和接收模型" tabindex="-1"><a class="header-anchor" href="#消息发送和接收模型"><span>消息发送和接收模型</span></a></h1><p>点对点模型（P2P）：P2P模型是基于队列的，消息生产者将数据发送到消息队列中，消息消费者从消息队列中接收消息。因为队列的存在，消息的异步传输成为可能。P2P模型的规定就是每一个消息数据，只有一个消费者，当发送者发送消息以后，不管接收者有没有运行都不影响消息发布到队列中。接收者在成功接收消息后会向发送者发送接收成功的消息。</p><p>发布/订阅模型（PS）：所谓得发布订阅模型就是事先将传输的数据进行分类，我们管这个数据的分类称之为主题（Topic）。也就是说，生产者发送消息时，会根据主题进行发送。比如咱们的消息中有一个分类是NBA，那么生产者在生产消息时，就可以将NBA篮球消息数据发送到NBA主题中，这样，对NBA消息主题感兴趣的消费者就可以申请订阅NBA主题，然后从该主题中获取消息。这样，也就是说一个消息，是允许被多个消费者同时消费的。这里生产者发送消息，我们称之为发布消息，而消费者从主题中获取消息，我们就称之为订阅消息。Kafka采用就是这种模型。</p><h1 id="生产者-消费者模式" tabindex="-1"><a class="header-anchor" href="#生产者-消费者模式"><span>生产者-消费者模式</span></a></h1><p>生产者-消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个消息缓冲区，平衡了生产者和消费者的处理能力。在数据传输过程中，起到了一个削弱峰值的作用，也就是我们经常说到的削峰。</p><p>主题</p><p>生产者 - 生产消息</p><p>消费者 - 消费消息</p><p>可靠性 - ACK应答机制</p><p>重复消费 - 业务幂等和消息去重</p><p>Producer消息重复和消息丢失的原因，主要就是kafka为了提高数据可靠性所提供的重试机制，如果禁用重试机制，那么一旦数据发送失败，数据就丢失了。而数据重复，恰恰是因为开启重试机制后，如果因为网络阻塞或不稳定，导致数据重新发送。那么数据就有可能是重复的。所以kafka提供了幂等性操作解决数据重复，并且幂等性操作要求必须开启重试功能和ACK取值为-1，这样，数据就不会丢失了。</p><p>kafka提供的幂等性操作只能保证同一个生产者会话中同一个分区中的数据不会重复，一旦数据发送过程中，生产者对象重启，那么幂等性操作就会失效。那么此时就需要使用Kafka的事务功能来解决跨会话的幂等性操作。但是跨分区的幂等性操作是无法实现的。</p><p>有序性 - 全局顺序 局部顺序</p><p>积压 - 消费者扩容</p><p>集群</p><p>主从同步</p><p>分片存储（副本机制）</p><p>选举（故障自动转移）</p>',20);function s(m,k){return r(),t("div",null,[n,a(" more "),c])}const f=e(i,[["render",s],["__file","kafka概念.html.vue"]]),h=JSON.parse('{"path":"/note/kafka/kafka%E6%A6%82%E5%BF%B5.html","title":"kafka概念","lang":"zh-CN","frontmatter":{"title":"kafka概念","cover":"/assets/images/cover1.jpg","icon":"file","order":3,"author":"HotMilk","date":"2024-07-15T00:00:00.000Z","category":["kafka概念"],"tag":["kafka概念","消息队列"],"description":"kafka概念","head":[["meta",{"property":"og:url","content":"https://reniunai.github.io/note/kafka/kafka%E6%A6%82%E5%BF%B5.html"}],["meta",{"property":"og:site_name","content":"热牛奶"}],["meta",{"property":"og:title","content":"kafka概念"}],["meta",{"property":"og:description","content":"kafka概念"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://reniunai.github.io/assets/images/cover1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-05T08:48:07.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://reniunai.github.io/assets/images/cover1.jpg"}],["meta",{"name":"twitter:image:alt","content":"kafka概念"}],["meta",{"property":"article:author","content":"HotMilk"}],["meta",{"property":"article:tag","content":"kafka概念"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:published_time","content":"2024-07-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-05T08:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"kafka概念\\",\\"image\\":[\\"https://reniunai.github.io/assets/images/cover1.jpg\\"],\\"datePublished\\":\\"2024-07-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-05T08:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HotMilk\\"}]}"]]},"headers":[],"git":{"createdTime":1722847687000,"updatedTime":1722847687000,"contributors":[{"name":"reniunai","email":"2843768@qq.com","commits":1}]},"readingTime":{"minutes":3.59,"words":1078},"filePathRelative":"note/kafka/kafka概念.md","localizedDate":"2024年7月15日","excerpt":"<p>kafka概念</p>\\n","autoDesc":true}');export{f as comp,h as data};
