const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":330,\"nextId\":330,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2@0\",\"3\":\"3\",\"4\":\"3@0\",\"5\":\"3@1\",\"6\":\"4\",\"7\":\"4@0\",\"8\":\"4@1\",\"9\":\"5\",\"10\":\"5#markdown-介绍\",\"11\":\"5#markdown-配置\",\"12\":\"5#markdown-扩展\",\"13\":\"5#vuepress-扩展\",\"14\":\"5#主题扩展\",\"15\":\"5#选项卡\",\"16\":\"5#脚注\",\"17\":\"5#导入文件\",\"18\":\"5#tex-语法\",\"19\":\"5#任务列表\",\"20\":\"5#图片增强\",\"21\":\"5#上下角标\",\"22\":\"5#组件\",\"23\":\"5@0\",\"24\":\"5@1\",\"25\":\"6\",\"26\":\"6#页面标题\",\"27\":\"6#页面信息\",\"28\":\"6#页面内容\",\"29\":\"6#组件\",\"30\":\"6@0\",\"31\":\"6@1\",\"32\":\"7\",\"33\":\"7@0\",\"34\":\"8\",\"35\":\"8#标题-2\",\"36\":\"8#标题-3\",\"37\":\"8@0\",\"38\":\"8@1\",\"39\":\"9\",\"40\":\"9#标题-2\",\"41\":\"9#标题-3\",\"42\":\"9@0\",\"43\":\"9@1\",\"44\":\"10\",\"45\":\"10#标题-2\",\"46\":\"10#标题-3\",\"47\":\"10@0\",\"48\":\"10@1\",\"49\":\"11\",\"50\":\"11#标题-2\",\"51\":\"11#标题-3\",\"52\":\"11@0\",\"53\":\"11@1\",\"54\":\"12\",\"55\":\"12@0\",\"56\":\"13\",\"57\":\"13@0\",\"58\":\"13@1\",\"59\":\"14\",\"60\":\"14#wait-notify原理\",\"61\":\"14#join原理\",\"62\":\"14#park-unpark原理\",\"63\":\"14#先park-后unpark\",\"64\":\"14#先unpark后park\",\"65\":\"14#与-object-的-wait-notify相比\",\"66\":\"14#含义\",\"67\":\"14#作用\",\"68\":\"14#使用场景及原理\",\"69\":\"14#synchronized\",\"70\":\"14#monitor-被翻译为监视器或管程\",\"71\":\"14#关联流程\",\"72\":\"14#对象头\",\"73\":\"14#对象标记\",\"74\":\"14#指向类的指针\",\"75\":\"14#数组长度\",\"76\":\"14#偏向锁\",\"77\":\"14#偏向状态\",\"78\":\"14#撤销-调用对象-hashcode\",\"79\":\"14#撤销-其它线程使用对象\",\"80\":\"14#撤销-调用-wait-notify\",\"81\":\"14#批量重偏向\",\"82\":\"14#批量撤销\",\"83\":\"14#轻量级锁\",\"84\":\"14#锁膨胀\",\"85\":\"14#锁消除\",\"86\":\"14#锁粗化\",\"87\":\"14#synchronized-的四种锁状态\",\"88\":\"14#reentrantlock\",\"89\":\"14#synchronized和reentrantlock对比\",\"90\":\"14#reentrantreadwritelock\",\"91\":\"14#cas-aba问题-自旋问题-单个变量操作\",\"92\":\"14#aqs\",\"93\":\"14#semaphore\",\"94\":\"14#semaphore-原理\",\"95\":\"14#semaphore的主要特点包括\",\"96\":\"14#使用semaphore的一个简单例子\",\"97\":\"14#countdownlatch\",\"98\":\"14#cyclicbarrier-类\",\"99\":\"14#exchanger\",\"100\":\"14#completablefuture\",\"101\":\"14#locksupport\",\"102\":\"14@0\",\"103\":\"14@1\",\"104\":\"15\",\"105\":\"15#_1-程序计数器\",\"106\":\"15#_1-1定义\",\"107\":\"15#_2-虚拟机栈\",\"108\":\"15#_2-1-定义\",\"109\":\"15#_2-2-栈内存溢出\",\"110\":\"15#_2-3-线程运行诊断\",\"111\":\"15#_3-本地方法栈\",\"112\":\"15#_4-堆\",\"113\":\"15#_4-1-定义\",\"114\":\"15#_4-2特点\",\"115\":\"15#_4-3堆内存溢出\",\"116\":\"15#_4-4堆内存诊断\",\"117\":\"15#_5-方法区\",\"118\":\"15#_5-1-定义\",\"119\":\"15#_5-2-组成\",\"120\":\"15#_5-3-方法区内存溢出\",\"121\":\"15#_5-4-通过反编译来查看类的信息\",\"122\":\"15#_5-5-运行时常量池\",\"123\":\"15#_5-6-常量池与串池stringtable的关系\",\"124\":\"15#面试题-string-str1-new-string-abc-和string-str2-abc-和-区别\",\"125\":\"15#面试题-string-s-new-string-a-new-string-b\",\"126\":\"15#_5-7-stringtable-位置\",\"127\":\"15#_5-8-stringtable-垃圾回收\",\"128\":\"15#_5-9-stringtable-性能调优\",\"129\":\"15#_6-直接内存\",\"130\":\"15#_6-1-定义\",\"131\":\"15#_6-2-使用直接内存的好处\",\"132\":\"15#直接内存也会导致内存溢出\",\"133\":\"15#_6-3-直接内存回收原理\",\"134\":\"15#_1-如何判断对象可以回收\",\"135\":\"15#_1-1-引用计数法\",\"136\":\"15#缺点-循环引用时-两个对象的计数都为1-导致两个对象都无法被释放\",\"137\":\"15#_1-2-可达性分析算法\",\"138\":\"15#可以作为gc-root的对象\",\"139\":\"15#使用memory-analyzer-mat-分析。\",\"140\":\"15#_1-3-五种引用\",\"141\":\"15#强引用\",\"142\":\"15#软引用\",\"143\":\"15#弱引用\",\"144\":\"15#虚引用\",\"145\":\"15#终结器引用\",\"146\":\"15#软引用使用\",\"147\":\"15#弱引用-使用\",\"148\":\"15#_2-垃圾回收算法\",\"149\":\"15#_2-1-标记清除\",\"150\":\"15#_2-2-标记整理\",\"151\":\"15#_2-3-复制\",\"152\":\"15#_3-分代垃圾回收\",\"153\":\"15#_3-1-回收流程\",\"154\":\"15#_3-2-gc-分析\",\"155\":\"15#相关vm参数\",\"156\":\"15#大对象处理策略\",\"157\":\"15#线程内存溢出\",\"158\":\"15#_4-垃圾回收器\",\"159\":\"15#_4-1-串行-serial-serialold-新生代复制-老年代标记整理\",\"160\":\"15#_4-2-吞吐量优先\",\"161\":\"15#_4-3-响应时间优先\",\"162\":\"15#_4-4-garbage-first\",\"163\":\"15#young-collection\",\"164\":\"15#young-collection-cm\",\"165\":\"15#mixed-collection\",\"166\":\"15#full-gc\",\"167\":\"15#young-collection-跨代引用\",\"168\":\"15#remark\",\"169\":\"15#jdk-8u20-字符串去重\",\"170\":\"15#jdk-8u40-并发标记类卸载\",\"171\":\"15#jdk-8u60-回收巨型对象\",\"172\":\"15#_5-垃圾回收调优\",\"173\":\"15#_5-1-调优领域\",\"174\":\"15#_5-2-确定目标\",\"175\":\"15#_5-3-最快的-gc是不发生gc\",\"176\":\"15#_5-4-新生代调优\",\"177\":\"15#_5-5-老年代调优\",\"178\":\"15#_5-6-案例\",\"179\":\"15#_1-类文件结构\",\"180\":\"15#_1-1-魔数\",\"181\":\"15#_1-2-版本\",\"182\":\"15#_1-3-常量池\",\"183\":\"15#_1-4-访问标识与继承信息\",\"184\":\"15#_2-字节码指令\",\"185\":\"15#_2-1-javap工具\",\"186\":\"15#_2-2-图解方法执行流程\",\"187\":\"15#_1-代码\",\"188\":\"15#_2-编译后的字节码文件\",\"189\":\"15#_3-常量池载入运行时常量池\",\"190\":\"15#_4-方法字节码载入方法区\",\"191\":\"15#_5-main-线程开始运行-分配栈帧内存\",\"192\":\"15#_6-执行引擎开始执行字节码-bipush-10\",\"193\":\"15#_2-3-练习-分析-i\",\"194\":\"15#_2-4-条件判断指令\",\"195\":\"15#_2-5-循环控制指令\",\"196\":\"15#_2-6-练习-判断结果\",\"197\":\"15#_2-7-构造方法\",\"198\":\"15#_2-8-方法调用\",\"199\":\"15#_2-9-多态的原理\",\"200\":\"15#_1-运行代码\",\"201\":\"15#_2-运行-hsdb-工具\",\"202\":\"15#_3-查找某个对象\",\"203\":\"15#_4-查看对象内存结构\",\"204\":\"15#_5-查看对象-class-的内存地址\",\"205\":\"15#_6-查看类的-vtable\",\"206\":\"15#_7-验证方法地址\",\"207\":\"15#_8-小结\",\"208\":\"15#_2-10-异常处理\",\"209\":\"15#_1-try-catch\",\"210\":\"15#_2-多个-single-catch-块的情况\",\"211\":\"15#_3-multi-catch-的情况\",\"212\":\"15#_4-finally\",\"213\":\"15#_5-finally中的return\",\"214\":\"15#_6-finally不带return\",\"215\":\"15#_2-11-synchronized\",\"216\":\"15#_3-编译器处理\",\"217\":\"15#_3-1-默认构造器\",\"218\":\"15#_3-2-自动拆装箱\",\"219\":\"15#_3-3-泛型集合取值\",\"220\":\"15#_3-4反射获取泛型信息\",\"221\":\"15#_3-5-可变参数\",\"222\":\"15#_3-6-foreach-循环\",\"223\":\"15#_3-7-switch-字符串\",\"224\":\"15#_3-8-switch-枚举\",\"225\":\"15#_3-9-枚举类\",\"226\":\"15#_3-10-try-with-resources\",\"227\":\"15#_3-11-方法重写时的桥接方法\",\"228\":\"15#_3-12-匿名内部类\",\"229\":\"15#_4-类加载阶段\",\"230\":\"15#_4-1-加载\",\"231\":\"15#_4-2-链接\",\"232\":\"15#_1-验证\",\"233\":\"15#_2-准备\",\"234\":\"15#_3-解析\",\"235\":\"15#_4-3-初始化\",\"236\":\"15#_1-cinit-v-方法\",\"237\":\"15#_2-发生的时机\",\"238\":\"15#_4-练习\",\"239\":\"15#_5-类加载器\",\"240\":\"15#_5-1-启动类的加载器\",\"241\":\"15#_5-2-扩展类的加载器\",\"242\":\"15#_5-3-双亲委派模式\",\"243\":\"15#_5-4-自定义类加载器\",\"244\":\"15#_5-5-线程上下文类加载器\",\"245\":\"15#背景\",\"246\":\"15#spi-服务提供接口\",\"247\":\"15#使用\",\"248\":\"15#原理\",\"249\":\"15#_6、运行期优化\",\"250\":\"15#_6-1-即时编译\",\"251\":\"15#_1-分层编译\",\"252\":\"15#_2-方法内联\",\"253\":\"15#_3-字段优化\",\"254\":\"15#_6-2-反射优化\",\"255\":\"15#_1-原子性\",\"256\":\"15#_1-1-问题解析\",\"257\":\"15#_1-2-解决方法-加锁\",\"258\":\"15#_1-synchronized-同步关键字\",\"259\":\"15#_2-可见性\",\"260\":\"15#_2-1-退不出的循环\",\"261\":\"15#_2-2-解决办法\",\"262\":\"15#_1-volatile-易变关键字\",\"263\":\"15#_2-3-可见性\",\"264\":\"15@0\",\"265\":\"15@1\",\"266\":\"16\",\"267\":\"16@0\",\"268\":\"17\",\"269\":\"17#缓存穿透\",\"270\":\"17#简单的解决方法\",\"271\":\"17#布隆过滤器\",\"272\":\"17#什么是布隆过滤器\",\"273\":\"17#原理\",\"274\":\"17#使用\",\"275\":\"17#代码分析\",\"276\":\"17#参考\",\"277\":\"17@0\",\"278\":\"17@1\",\"279\":\"18\",\"280\":\"18#页面标题\",\"281\":\"18#页面信息\",\"282\":\"18#页面内容\",\"283\":\"18#组件\",\"284\":\"18@0\",\"285\":\"18@1\",\"286\":\"19\",\"287\":\"19#标题-2\",\"288\":\"19#标题-3\",\"289\":\"19@0\",\"290\":\"19@1\",\"291\":\"20\",\"292\":\"20#标题-2\",\"293\":\"20#标题-3\",\"294\":\"20@0\",\"295\":\"20@1\",\"296\":\"21\",\"297\":\"21#标题-2\",\"298\":\"21#标题-3\",\"299\":\"21@0\",\"300\":\"21@1\",\"301\":\"22\",\"302\":\"22#标题-2\",\"303\":\"22#标题-3\",\"304\":\"22@0\",\"305\":\"22@1\",\"306\":\"23\",\"307\":\"23#标题-2\",\"308\":\"23#标题-3\",\"309\":\"23@0\",\"310\":\"23@1\",\"311\":\"24\",\"312\":\"24#标题-2\",\"313\":\"24#标题-3\",\"314\":\"24@0\",\"315\":\"24@1\",\"316\":\"25\",\"317\":\"25#标题-2\",\"318\":\"25#标题-3\",\"319\":\"25@0\",\"320\":\"25@1\",\"321\":\"26\",\"322\":\"26#标题-2\",\"323\":\"26#标题-3\",\"324\":\"26@0\",\"325\":\"26@1\",\"326\":\"27\",\"327\":\"28\",\"328\":\"29\",\"329\":\"30\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1],\"2\":[null,null,1],\"3\":[1,18],\"4\":[null,null,1],\"5\":[null,null,1],\"6\":[1,20],\"7\":[null,null,1],\"8\":[null,null,1],\"9\":[2,10],\"10\":[2,8],\"11\":[2,12],\"12\":[2,11],\"13\":[2,10],\"14\":[1,10],\"15\":[1,1],\"16\":[1,2],\"17\":[1,1],\"18\":[2,25],\"19\":[1,5],\"20\":[1,2],\"21\":[1,3],\"22\":[1],\"23\":[null,null,1],\"24\":[null,null,1],\"25\":[1,3],\"26\":[1,19],\"27\":[1,20],\"28\":[1,12],\"29\":[1,13],\"30\":[null,null,1],\"31\":[null,null,2],\"32\":[1],\"33\":[null,null,1],\"34\":[1],\"35\":[2,2],\"36\":[2,2],\"37\":[null,null,1],\"38\":[null,null,3],\"39\":[1],\"40\":[2,2],\"41\":[2,2],\"42\":[null,null,2],\"43\":[null,null,2],\"44\":[1],\"45\":[2,2],\"46\":[2,2],\"47\":[null,null,2],\"48\":[null,null,2],\"49\":[1],\"50\":[2,2],\"51\":[2,2],\"52\":[null,null,1],\"53\":[null,null,2],\"54\":[1],\"55\":[null,null,1],\"56\":[1,18],\"57\":[null,null,1],\"58\":[null,null,1],\"59\":[1,98],\"60\":[2,28],\"61\":[1,23],\"62\":[2,27],\"63\":[2,7],\"64\":[1,11],\"65\":[5,100],\"66\":[1,8],\"67\":[1,45],\"68\":[1,51],\"69\":[1],\"70\":[2,15],\"71\":[1,142],\"72\":[1,10],\"73\":[1,1],\"74\":[1,4],\"75\":[1,3],\"76\":[1,38],\"77\":[1,38],\"78\":[3,17],\"79\":[2,59],\"80\":[4,42],\"81\":[1,99],\"82\":[1,54],\"83\":[1,59],\"84\":[1,56],\"85\":[1,77],\"86\":[1,8],\"87\":[2,27],\"88\":[1,8],\"89\":[1],\"90\":[1],\"91\":[4,19],\"92\":[1,28],\"93\":[1,6],\"94\":[2,48],\"95\":[1,37],\"96\":[3,17],\"97\":[1,36],\"98\":[2,55],\"99\":[1,2],\"100\":[1,8],\"101\":[1,85],\"102\":[null,null,1],\"103\":[null,null,1],\"104\":[1,5],\"105\":[2],\"106\":[2,53],\"107\":[2,1],\"108\":[3,62],\"109\":[2,18],\"110\":[3,22],\"111\":[2,4],\"112\":[2],\"113\":[3,1],\"114\":[2,3],\"115\":[2,70],\"116\":[2,14],\"117\":[2],\"118\":[3,22],\"119\":[3,12],\"120\":[3,87],\"121\":[3,36],\"122\":[2,13],\"123\":[3,153],\"124\":[1,10],\"125\":[1,71],\"126\":[4,9],\"127\":[4,49],\"128\":[4,12],\"129\":[2],\"130\":[3,6],\"131\":[3,27],\"132\":[1,161],\"133\":[3,78],\"134\":[2],\"135\":[2,7],\"136\":[4,1],\"137\":[3,5],\"138\":[2,12],\"139\":[5,68],\"140\":[3,1],\"141\":[1,7],\"142\":[1,10],\"143\":[1,9],\"144\":[1,20],\"145\":[1,25],\"146\":[1,114],\"147\":[1,62],\"148\":[2],\"149\":[3,19],\"150\":[2,13],\"151\":[3,17],\"152\":[2,5],\"153\":[3,46],\"154\":[4],\"155\":[1,73],\"156\":[1,47],\"157\":[1,58],\"158\":[2,71],\"159\":[9,63],\"160\":[3,73],\"161\":[3,92],\"162\":[3,57],\"163\":[2,18],\"164\":[1,19],\"165\":[1,25],\"166\":[1,23],\"167\":[3,28],\"168\":[1,28],\"169\":[1,35],\"170\":[1,7],\"171\":[3,20],\"172\":[2,13],\"173\":[3,6],\"174\":[3,10],\"175\":[4,33],\"176\":[3,43],\"177\":[2,19],\"178\":[3,16],\"179\":[2,183],\"180\":[2,28],\"181\":[3,29],\"182\":[3,310],\"183\":[3,21],\"184\":[2,3],\"185\":[3,9],\"186\":[2],\"187\":[2,23],\"188\":[3,105],\"189\":[3,3],\"190\":[2,1],\"191\":[5,6],\"192\":[1,97],\"193\":[5,96],\"194\":[3,73],\"195\":[3,51],\"196\":[4,94],\"197\":[3,84],\"198\":[3,101],\"199\":[3,64],\"200\":[2,9],\"201\":[4,18],\"202\":[2,21],\"203\":[2,15],\"204\":[4,24],\"205\":[3,64],\"206\":[2,39],\"207\":[2,12],\"208\":[3],\"209\":[4,62],\"210\":[6,82],\"211\":[5,91],\"212\":[3,86],\"213\":[3,80],\"214\":[3,60],\"215\":[3,92],\"216\":[2,34],\"217\":[3,15],\"218\":[3,37],\"219\":[2,108],\"220\":[2,143],\"221\":[3,42],\"222\":[4,62],\"223\":[4,97],\"224\":[4,56],\"225\":[3,36],\"226\":[5,95],\"227\":[3,56],\"228\":[3,60],\"229\":[2],\"230\":[3,64],\"231\":[3],\"232\":[3,10],\"233\":[3,55],\"234\":[3,36],\"235\":[3],\"236\":[5,6],\"237\":[3,81],\"238\":[2,47],\"239\":[2,48],\"240\":[3,57],\"241\":[3,53],\"242\":[3,90],\"243\":[3,57],\"244\":[2],\"245\":[1,65],\"246\":[2,98],\"247\":[1,29],\"248\":[1,71],\"249\":[2],\"250\":[3],\"251\":[3,92],\"252\":[3,60],\"253\":[3,172],\"254\":[3,140],\"255\":[2],\"256\":[2,94],\"257\":[4],\"258\":[4,90],\"259\":[2],\"260\":[3,52],\"261\":[2],\"262\":[4,58],\"263\":[3,77],\"264\":[null,null,1],\"265\":[null,null,1],\"266\":[1],\"267\":[null,null,1],\"268\":[2,3],\"269\":[1,23],\"270\":[1,9],\"271\":[1],\"272\":[1,14],\"273\":[1,51],\"274\":[1,64],\"275\":[1,30],\"276\":[1,12],\"277\":[null,null,1],\"278\":[null,null,2],\"279\":[1,3],\"280\":[1,19],\"281\":[1,20],\"282\":[1,12],\"283\":[1,13],\"284\":[null,null,1],\"285\":[null,null,2],\"286\":[2],\"287\":[2,2],\"288\":[2,2],\"289\":[null,null,1],\"290\":[null,null,3],\"291\":[2,2],\"292\":[2,2],\"293\":[2,2],\"294\":[null,null,1],\"295\":[null,null,3],\"296\":[2],\"297\":[2,2],\"298\":[2,2],\"299\":[null,null,2],\"300\":[null,null,3],\"301\":[2],\"302\":[2,2],\"303\":[2,2],\"304\":[null,null,2],\"305\":[null,null,3],\"306\":[2],\"307\":[2,2],\"308\":[2,2],\"309\":[null,null,2],\"310\":[null,null,3],\"311\":[2,4],\"312\":[2,2],\"313\":[2,2],\"314\":[null,null,2],\"315\":[null,null,3],\"316\":[2],\"317\":[2,2],\"318\":[2,2],\"319\":[null,null,1],\"320\":[null,null,3],\"321\":[2],\"322\":[2,2],\"323\":[2,2],\"324\":[null,null,1],\"325\":[null,null,3],\"326\":[1,3],\"327\":[1],\"328\":[1],\"329\":[1]},\"averageFieldLength\":[2.0743123859625276,33.65621454740907,1.0084454793301187],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"热牛奶 将你的个人介绍和档案放置在此处。\"]},\"1\":{\"h\":\"主要功能与配置演示\"},\"2\":{\"c\":[\"使用指南\"]},\"3\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"4\":{\"c\":[\"使用指南\"]},\"5\":{\"c\":[\"禁用\"]},\"6\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"7\":{\"c\":[\"指南\"]},\"8\":{\"c\":[\"布局\"]},\"9\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"10\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"11\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"12\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"13\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"14\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"15\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"16\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"17\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"18\":{\"h\":\"TeX 语法\",\"t\":[\"$$ \\\\frac {\\\\partial^r} {\\\\partial \\\\omega^r} \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) = \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) \\\\left{(\\\\log y)^r + \\\\sum_{i=1}^r \\\\frac {(-1)^i r \\\\cdots (r-i+1) (\\\\log y)^{r-i}} {\\\\omega^i} \\\\right} $$\",\"查看详情\"]},\"19\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"20\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"组件\"},\"23\":{\"c\":[\"使用指南\"]},\"24\":{\"c\":[\"Markdown\"]},\"25\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"26\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"27\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"28\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"29\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"30\":{\"c\":[\"使用指南\"]},\"31\":{\"c\":[\"页面配置\",\"使用指南\"]},\"32\":{\"h\":\"学习笔记\"},\"33\":{\"c\":[\"学习笔记\"]},\"34\":{\"h\":\"樱桃\"},\"35\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"36\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"37\":{\"c\":[\"樱桃\"]},\"38\":{\"c\":[\"红\",\"小\",\"圆\"]},\"39\":{\"h\":\"火龙果\"},\"40\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"41\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"42\":{\"c\":[\"火龙果\",\"水果\"]},\"43\":{\"c\":[\"红\",\"大\"]},\"44\":{\"h\":\"草莓\"},\"45\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"46\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"47\":{\"c\":[\"水果\",\"草莓\"]},\"48\":{\"c\":[\"红\",\"小\"]},\"49\":{\"h\":\"番茄\"},\"50\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"51\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"52\":{\"c\":[\"蔬菜\"]},\"53\":{\"c\":[\"红\",\"圆\"]},\"54\":{\"h\":\"Java\"},\"55\":{\"c\":[\"Java\"]},\"56\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"57\":{\"c\":[\"使用指南\"]},\"58\":{\"c\":[\"禁用\"]},\"59\":{\"h\":\"Java虚拟机\",\"t\":[\"Java 并发包\",\"JUC是指package java.util.concurrent;这个并发包。\",\"img\",\"这个包是为了解决并发问题的。有atomic子包，locks子包，Semaphore，Threadlocal，ThreadPoolExecutor，Excutor，CyclicBarrier，Future，\",\"讲到并发，那要先提一下线程间是如何通信的，简单来说线程有两种通信方式，一种是基于共享内存的，一种是基于消息传递的。Java里面是基于内存共享来进行线程间的通信，golang里面的协程（类似于操作系统的线程，线程是CPU调度的最小单位，协程是在线程的基础上再细分出来的一个调度的最小单位）可以通过管道进行消息传递来实现协程间的通信。\",\"线程同步是一种机制，用于控制多个线程访问共享资源（如内存、文件、数据库等）的方式，以避免数据不一致或竞态条件的问题。在 Java 中，线程同步通常通过以下几种方式实现：\",\"互斥锁**（Mutexes）**：通过 synchronized 关键字或 java.util.concurrent.locks.Lock 接口的实现（如 ReentrantLock）来保证同一时间只有一个线程可以访问特定的代码块或资源。\",\"原子操作：使用 java.util.concurrent.atomic 包中的原子类（如 AtomicInteger、AtomicReference 等）来执行不可中断的操作。\",\"volatile 关键字：确保对变量的读写操作直接在主内存中进行，而不是在各个线程的缓存中，以此保证变量的一致性。\",\"final 关键字：确保对象的引用在构造之后不会改变，保证对象初始化的安全性。\",\"线程同步的目的是确保当一个线程正在使用某个资源时，其他线程不会同时修改这个资源，从而防止数据竞争和不一致。\",\"线程通信是指线程之间相互发送信号和交换数据的过程。线程通信通常用于以下场景：\",\"协调任务执行：线程可能需要等待其他线程完成某些操作后才能继续执行。\",\"数据共享：线程可能需要向其他线程提供数据或者从其他线程接收数据。\",\"在 Java 中，线程通信通常通过以下几种方式实现：\",\"等待/通知机制：通过 Object 类的 wait()、notify() 和 notifyAll() 方法实现。一个线程可以调用 wait() 方法暂停执行并等待其他线程通过 notify() 或 notifyAll() 方法唤醒它。\",\"条件变量：通过 java.util.concurrent.locks.Condition 接口实现，与 ReentrantLock 结合使用，提供了更灵活的线程通信方式。\",\"**CountDownLatch、CyclicBarrier、**Semaphore 等同步器：提供更高级的线程通信和同步机制。\"]},\"60\":{\"h\":\"Wait notify原理\",\"t\":[\"img\",\"Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态\",\"BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片\",\"BLOCKED 线程会在 Owner 线程释放锁时唤醒\",\"WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入\",\"EntryList 重新竞争\"]},\"61\":{\"h\":\"join原理\",\"t\":[\"//是调用者轮询检查线程 alive 状态 t1.join(); 等价于下面的代码 synchronized (t1) { // 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束 while (t1.isAlive()) { t1.wait(0); } }\",\"注意join 体现的是【保护性暂停】模式，请参考之\"]},\"62\":{\"h\":\"Park unpark原理\",\"t\":[\"// 暂停当前线程 LockSupport.park(); // 恢复某个线程的运行 LockSupport.unpark(暂停线程对象);\",\"每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻\",\"_counter 理解成订单，_cond 理解成停车场，_mutex是互斥锁。\",\"把Park 理解成泊车，把unpark理解成出车。跟现实的司机很像，这里代入一下。\",\"可以先Park 后unpark，也可以先unpark后Park 。\"]},\"63\":{\"h\":\"先Park 后unpark\",\"t\":[\"执行Park ，司机在停车场停车休息，阻塞等待订单。\",\"执行unpark，下了个订单，司机那边收到就开始工作。\"]},\"64\":{\"h\":\"先unpark后Park\",\"t\":[\"执行unpark，先下个单，等司机来接。\",\"执行Park ，开车不能玩手机，司机停车的时候发现有个订单，立马处理，不用阻塞等待。这里跟现实不一样，这里必须是司机停车的时候才能接单。\"]},\"65\":{\"h\":\"与 Object 的 wait & notify相比\",\"t\":[\"wait, notify 和 notifyAll 必须配合 Object Monitor 一起使用,而 park, unpark不必\",\"park & unpark是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程， notifyAll 是唤醒所有等待线程，就不那么【精确】\",\"park & unpark可以先 unpark, 而 wait & notify 不能先 notify\",\"线程同步和线程通信虽然密切相关，但它们的关注点不同。线程同步关注的是如何避免并发导致的问题，而线程通信关注的是线程之间如何协作完成任务。在并发编程中，这两者通常是相辅相成的。\",\"是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。\",\"JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的 本地内存 （Local Memory），本地内存中存储了该线程以读/写共享变量的副本。\",\"img\",\"原子性、有序性、可见性是并发编程中非常重要的基础概念，用于描述多线程环境下的内存访问行为，它们是 Java 内存模型（Java Memory Model, JMM）的基础。\",\"原子性（Atomicity）：\",\"原子性是指一个操作或者一系列操作要么全部执行并且在执行过程中不会被任何其他操作中断，要么就全部都不执行。\",\"在多线程环境中，原子性确保了当多个线程尝试同时修改同一变量时，这些修改不会相互干扰。\",\"Java 提供了一些原子类（如 AtomicInteger、AtomicLong 等），它们利用底层硬件的原子指令来保证操作的原子性。\",\"可见性（Visibility）：\",\"可见性是指当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。\",\"在没有同步机制的情况下，一个线程对共享变量的修改可能对其他线程不可见，因为变量的值可能被缓存在寄存器或者线程私有内存中。\",\"Java 通过 volatile 关键字、synchronized 块以及 Lock 机制来保证可见性。\",\"有序性（Ordering）：\",\"有序性是指程序执行的顺序按照代码的先后顺序进行。\",\"在多线程环境中，由于编译器优化、处理器乱序执行等原因，指令可能会以不同于编写代码时的顺序执行。\",\"JMM 规定了 happens-before 关系，确保在并发环境中程序的执行结果与按序执行时的结果一致。\",\"使用 synchronized 和 volatile 可以禁止某些重排序，保证操作的有序性。\",\"JMM 定义了这些概念来规范多线程程序的内存一致性行为，确保在不同的线程、处理器和编译器优化下，程序的行为符合预期。理解并正确使用这些概念对于编写正确、高效的并发程序至关重要。\",\"volatile关键字有两个作用，保证可见性和有序性，但是不保证原子性。\"]},\"66\":{\"h\":\"含义\",\"t\":[\"volatile关键字用来修饰变量，告诉JVM编译器和处理器，这个变量可能会被不同的线程同时访问和修改。这意味着，任何线程对volatile变量的修改，都将立即反映到主内存中，而且其他线程可以从主内存中读取最新的值。\"]},\"67\":{\"h\":\"作用\",\"t\":[\"保证可见性：volatile变量的写操作会强制将数据写入主内存，读操作会从主内存中读取数据。这样，一旦某个线程修改了volatile变量，其他线程可以立即看到这个变化。\",\"禁止指令重排序：变量的写操作在执行时不能被编译器或处理器重排序到之前的任何时刻。这确保了在 volatile 变量写操作之前的所有操作都将在写操作之前完成，读操作也是如此。\",\"尽管 volatile 保证了可见性和禁止指令重排序，但它并不保证复合操作的原子性。例如，递增操作 i++（即 i = i + 1）不是一个原子操作，即使 i 被声明为 volatile，也不能保证线程安全。\",\"1public class VolatileCounter { 2 private volatile int count = 0; 34 public void increment() { 5 count++; // 这个操作在多线程环境下不是原子的 6 } 7}\"]},\"68\":{\"h\":\"使用场景及原理\",\"t\":[\"使用场景：\",\"volatile 适用于状态标记，例如，一个线程需要知道另一个线程是否已经初始化了某些资源或者是否正在执行特定的任务。\",\"示例：\",\"public class Example { private volatile boolean running = true; public void start() { while (running) { // 执行任务 } } public void stop() { running = false; } }\",\"在这个例子中，running 变量被声明为 volatile，以确保当调用 stop() 方法修改 running 为 false 时，start() 方法中的线程能够立即看到这个变化。\",\"内存****屏障：\",\"在读取 volatile 变量时，JVM 会插入一个内存屏障来防止指令重排序，确保在该屏障之前的所有读/写操作在该屏障之后的所有读/写操作之前执行。\",\"volatile 是一种比 synchronized 更轻量级的同步机制，但它的使用场景有限，主要用于保证变量的可见性。在需要更复杂的同步操作时，通常需要使用其他同步机制，如 synchronized 或 java.util.concurrent 包中的并发工具。\",\"原子操作。\"]},\"69\":{\"h\":\"Synchronized\"},\"70\":{\"h\":\"Monitor 被翻译为监视器或管程\",\"t\":[\"每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针。\"]},\"71\":{\"h\":\"关联流程\",\"t\":[\"img\",\"刚开始 Monitor 中 Owner 为 null\",\"当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner\",\"在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED\",\"Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的\",\"图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程\",\"注意：\",\"synchronized 必须是进入同一个对象的 monitor 才有上述的效果\",\"不加 synchronized 的对象不会关联监视器，不遵从以上规则\",\"static final Object lock = new Object(); static int counter = 0; public static void main(String[] args) { synchronized (lock) { counter++; } } Code: stack=2, locals=3, args_size=1 0: getstatic #2 // <- lock引用 （synchronized开始） 3: dup 4: astore_1 // lock引用 -> slot 1 5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针 6: getstatic #3 // <- i 9: iconst_1 // 准备常数 1 10: iadd // +1 11: putstatic #3 // -> i 14: aload_1 // <- lock引用 15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList 16: goto 24 19: astore_2 // e -> slot 2 20: aload_1 // <- lock引用 21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList 22: aload_2 // <- slot 2 (e) 23: athrow // throw e 24: return Exception table: from to target type 6 16 19 any 19 22 19 any LineNumberTable: line 8: 0 line 9: 6 line 10: 14 line 11: 24 LocalVariableTable: Start Length Slot Name Signature 0 25 0 args [Ljava/lang/String; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame*/ offset_delta = 19 locals = [ class \\\"[Ljava/lang/String;\\\", class java/lang/Object ] stack = [ class java/lang/Throwable ] * frame_type = 250 /* chop */ offset_delta = 4\",\"锁住的是对象实例或类对象\"]},\"72\":{\"h\":\"对象头\",\"t\":[\"对象头由以下三部分组成：\",\"1，Mark Word\",\"2，指向类的指针\",\"3，数组长度（只有数组对象才有）\"]},\"73\":{\"h\":\"\",\"t\":[\"img\",\"img\"]},\"74\":{\"h\":\"\",\"t\":[\"该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。\",\"Java对象的类数据保存在方法区。\"]},\"75\":{\"h\":\"\",\"t\":[\"只有数组对象保存了这部分数据。\",\"该数据在32位和64位JVM中长度都是32bit。\"]},\"76\":{\"h\":\"偏向锁\",\"t\":[\"轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。\",\"Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后检查\",\"这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。\",\"static final Object obj = new Object(); public static void m1() { synchronized( obj ) { // 同步块 A m2(); } } public static void m2() { synchronized( obj ) { // 同步块 B m3(); } } public static void m3() { synchronized( obj ) { // 同步块 C } }\"]},\"77\":{\"h\":\"偏向状态\",\"t\":[\"|--------------------------------------------------------------------|--------------------| | Mark Word (64 bits) | State | |--------------------------------------------------------------------|--------------------| | unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 | Normal | |--------------------------------------------------------------------|--------------------| | thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 | Biased | |--------------------------------------------------------------------|--------------------| | ptr_to_lock_record:62 | 00 | Lightweight Locked | |--------------------------------------------------------------------|--------------------| | ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked | |--------------------------------------------------------------------|--------------------| | | 11 | Marked for GC | |--------------------------------------------------------------------|--------------------|\"]},\"78\":{\"h\":\"撤销 - 调用对象 hashCode\",\"t\":[\"调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销\",\"轻量级锁会在锁记录中记录 hashCode\",\"重量级锁会在 Monitor 中记录 hashCode\",\"在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking\"]},\"79\":{\"h\":\"撤销 - 其它线程使用对象\",\"t\":[\"当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁\",\"private static void test2() throws InterruptedException { Dog d = new Dog(); Thread t1 = new Thread(() -> { synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } synchronized (TestBiased.class) { TestBiased.class.notify(); } // 如果不用 wait/notify 使用 join 必须打开下面的注释 // 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的 /*try { System.in.read(); } catch (IOException e) { e.printStackTrace(); }*/ }, \\\"t1\\\"); t1.start(); Thread t2 = new Thread(() -> { synchronized (TestBiased.class) { try { TestBiased.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); }, \\\"t2\\\"); t2.start(); }\",\"输出\",\"[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 [t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001\"]},\"80\":{\"h\":\"撤销 - 调用 wait/notify\",\"t\":[\"public static void main(String[] args) throws InterruptedException { Dog d = new Dog(); Thread t1 = new Thread(() -> { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); try { d.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \\\"t1\\\"); t1.start(); new Thread(() -> { try { Thread.sleep(6000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (d) { log.debug(\\\"notify\\\"); d.notify(); } }, \\\"t2\\\").start(); }\",\"输出\",\"[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 [t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101 [t2] - notify [t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010\"]},\"81\":{\"h\":\"批量重偏向\",\"t\":[\"如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象\",\"的 Thread ID\",\"当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至\",\"加锁线程\",\"private static void test3() throws InterruptedException { Vector<Dog> list = new Vector<>(); Thread t1 = new Thread(() -> { for (int i = 0; i < 30; i++) { Dog d = new Dog(); list.add(d); synchronized (d) { log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } } synchronized (list) { list.notify(); } }, \\\"t1\\\"); t1.start(); Thread t2 = new Thread(() -> { synchronized (list) { try { list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"===============> \\\"); for (int i = 0; i < 30; i++) { Dog d = list.get(i); log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \\\"t2\\\"); t2.start(); }\",\"输出\",\"[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - ===============> [t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101\"]},\"82\":{\"h\":\"批量撤销\",\"t\":[\"当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象\",\"都会变为不可偏向的，新建的对象也是不可偏向的\",\"static Thread t1,t2,t3; private static void test4() throws InterruptedException { Vector<Dog> list = new Vector<>(); int loopNumber = 39; t1 = new Thread(() -> { for (int i = 0; i < loopNumber; i++) { Dog d = new Dog(); list.add(d); synchronized (d) { log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } } LockSupport.unpark(t2); }, \\\"t1\\\"); t1.start(); t2 = new Thread(() -> { LockSupport.park(); log.debug(\\\"===============> \\\"); for (int i = 0; i < loopNumber; i++) { Dog d = list.get(i); log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } LockSupport.unpark(t3); }, \\\"t2\\\"); t2.start(); t3 = new Thread(() -> { LockSupport.park(); log.debug(\\\"===============> \\\"); for (int i = 0; i < loopNumber; i++) { Dog d = list.get(i); log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \\\"\\\\t\\\" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \\\"t3\\\"); t3.start(); t3.join(); log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true)); }\"]},\"83\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。\",\"轻量级锁对使用者是透明的，即语法仍然是 synchronized。\",\"img\",\"创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word\",\"让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\",\"如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\",\"如果 cas 失败，有两种情况 \",\"如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程\",\"如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数\",\"img\",\"当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\",\"img\",\"当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \",\"成功，则解锁成功\",\"失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\"]},\"84\":{\"h\":\"锁膨胀\",\"t\":[\"如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。\",\"static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 } }\",\"当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\",\"img\",\"这时 Thread-1 加轻量级锁CAS失败，进入锁膨胀流程 \",\"即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址\",\"然后自己进入 Monitor 的 EntryList BLOCKED\",\"img\",\"当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程\"]},\"85\":{\"h\":\"锁消除\",\"t\":[\"锁消除是指JVM在编译过程中通过静态分析技术检测到一些不可能存在竞争条件的锁，从而将其消除的优化过程。当JVM确定某个锁对象不会发生竞争时，就可以安全地消除对该锁的获取和释放操作，从而减少了锁操作的开销。\",\"来分析如下代码：\",\"StringBuffer sBuffer = new StringBuffer(); sBuffer.append(\\\"a\\\"); sBuffer.append(\\\"b\\\"); sBuffer.append(\\\"c\\\"); sBuffer.append(\\\"d\\\");\",\"此时由于StringBuffer对象是线程安全的，但是在单线程运行环境下，这些加锁解锁操作完全没有必要，因此编译器就会帮我们省去这些锁\",\"注意：synchronized消除锁的策略是比较保守的，明显不会发生线程安全问题的代码才会消除锁，例如：\",\"变量只涉及局部变量，没有全局变量\",\"多个线程只对变量做读取操作，不涉及修改操作\",\"@Fork(1) @BenchmarkMode(Mode.AverageTime) @Warmup(iterations=3) @Measurement(iterations=5) @OutputTimeUnit(TimeUnit.NANOSECONDS) public class MyBenchmark { static int x = 0; @Benchmark public void a() throws Exception { x++; } @Benchmark public void b() throws Exception { Object o = new Object(); synchronized (o) { x++; } } }\",\"java -jar benchmarks.jar\",\"Benchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.542 0.056 ns/op c.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op\",\"java -XX:-EliminateLocks -jar benchmarks.jar\",\"Benchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.507 0.108 ns/op c.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op\"]},\"86\":{\"h\":\"锁粗化\",\"t\":[\"对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。\",\"如果在同一段代码逻辑中，多次频繁的加锁解锁操作，编译器和JVM会帮助我们将其合并为一次加锁解锁操作。\"]},\"87\":{\"h\":\"Synchronized 的四种锁状态\",\"t\":[\"无锁：\",\"偏向锁：偏向某个线程使用，如果有其他线程尝试获取偏向锁，则会撤销偏向模式，升级为轻量级锁。\",\"轻量级锁：多个线程交替使用，轻量级锁使用CAS（Compare And Swap）操作来尝试获取锁。如果CAS操作成功，线程就获得了锁；如果失败，证明有多个线程同时使用，即发生竞争，达到次数升级重量级锁\",\"重量级锁：重量级锁是 synchronized 的最终状态，当锁处于这个状态时，所有等待获取锁的线程都会被挂起，直到锁被释放。\"]},\"88\":{\"h\":\"ReentrantLock\",\"t\":[\"是类，基于AQS实现，具有原子性，有序性，可见性，可重入性。\",\"公平锁\",\"非公平锁\"]},\"89\":{\"h\":\"Synchronized和ReentrantLock对比\"},\"90\":{\"h\":\"ReentrantReadWriteLock\"},\"91\":{\"h\":\"CAS：ABA问题，自旋问题，单个变量操作\",\"t\":[\"CAS（Compare And Swap）是一种原子操作，用于实现多线程环境下的同步操作。CAS 操作包含三个操作数：内存位置（V）、旧的预期值（A）和新值（B）。当且仅当预期值 A 和内存位置 V 的值相同时，CAS 会将内存位置 V 的值更新为新值B。\"]},\"92\":{\"h\":\"AQS\",\"t\":[\"AbstractQueuedSynchronizer（AQS）是Java中用于实现锁和同步器的基础框架。它提供了一种队列同步器的实现方式，可以用于构建各种同步器，如ReentrantLock、Semaphore、CountDownLatch等。AQS的核心思想是使用一个FIFO的等待队列来管理线程的获取和释放锁的顺序，同时使用一个volatile变量来表示锁的状态。AQS的实现方式是通过继承来扩展，子类需要实现tryAcquire和tryRelease等方法来控制锁的获取和释放。AQS是Java并发编程中的重要概念，也是Java并发包中的核心组件之一。\",\"image-20240715233123923\",\"Executor：执行线程的顶级接口。\",\"Executors：工厂类，用于创建不同类型的线程池。\",\"ExecutorService：管理任务提交和线程池的接口。\",\"ThreadPoolExecutor：可扩展的线程池类。\",\"ScheduledExecutorService：用于定时任务的线程池接口。\"]},\"93\":{\"h\":\"Semaphore\",\"t\":[\"在Java中，Semaphore是一个同步辅助类，它提供了一种更为复杂的方式来控制同时访问某些资源的线程数量。Semaphore本质上是一个计数信号量，用来限制对某些资源的并发访问。\"]},\"94\":{\"h\":\"Semaphore 原理\",\"t\":[\"Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后\",\"停车场显示空余车位减一\",\"刚开始，permits（state）为 3，这时 5 个线程来获取资源\",\"img\",\"假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列\",\"park 阻塞\",\"img\",\"这时 Thread-4 释放了 permits，状态如下\",\"img\",\"接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接\",\"下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态\",\"img\"]},\"95\":{\"h\":\"的主要特点包括\",\"t\":[\"计数器：Semaphore内部有一个计数器，表示同时允许访问资源的线程数量。\",\"获取（Acquire）：线程调用Semaphore的acquire()方法来获取一个许可。如果计数器大于0，计数器减1，线程成功获取许可；如果计数器为0，则线程会被阻塞，直到其他线程释放许可。\",\"释放（Release）：线程完成资源使用后，调用release()方法来释放一个许可，此时计数器加1，可能会唤醒等待的线程。\",\"公平性（Fairness）：可以创建一个公平的Semaphore，它按照线程请求资源的顺序来分配许可，而非公平的Semaphore则可能允许线程饥饿。\",\"尝试获取（Try Acquire）：Semaphore提供了tryAcquire()方法，允许线程尝试获取许可而不被阻塞。如果获取成功，返回true；如果失败（即没有可用的许可），则返回false。 1.\"]},\"96\":{\"h\":\"使用 的一个简单例子：\",\"t\":[\"// 创建一个计数为1的Semaphore，表示一次只允许一个线程访问资源 Semaphore semaphore = new Semaphore(1); // 线程尝试获取许可 semaphore.acquire(); // 线程使用资源 // ... // 线程使用完资源后释放许可 semaphore.release();\",\"Semaphore可以用于多种同步场景，比如限制数据库连接池的大小、控制线程池中的线程数量等。它比synchronized关键字和ReentrantLock提供了更多的灵活性。\"]},\"97\":{\"h\":\"CountDownLatch\",\"t\":[\"允许一个或多个线程等待一组操作在其他线程中完成。用来进行线程同步协作，等待所有线程完成倒计时。\",\"其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一。\",\"public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(3); new Thread(() -> { log.debug(\\\"begin...\\\"); sleep(1); latch.countDown(); log.debug(\\\"end...{}\\\", latch.getCount()); }).start(); new Thread(() -> { log.debug(\\\"begin...\\\"); sleep(2); latch.countDown(); log.debug(\\\"end...{}\\\", latch.getCount()); }).start(); new Thread(() -> { log.debug(\\\"begin...\\\"); sleep(1.5); latch.countDown(); log.debug(\\\"end...{}\\\", latch.getCount()); }).start(); log.debug(\\\"waiting...\\\"); latch.await(); log.debug(\\\"wait end...\\\"); }\"]},\"98\":{\"h\":\"CyclicBarrier 类\",\"t\":[\"使一组线程到达某个点后继续执行。循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。\",\"CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行 new Thread(()->{ System.out.println(\\\"线程1开始..\\\"+new Date()); try { cb.await(); // 当个数不足时，等待 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } System.out.println(\\\"线程1继续向下运行...\\\"+new Date()); }).start(); new Thread(()->{ System.out.println(\\\"线程2开始..\\\"+new Date()); try { Thread.sleep(2000); } catch (InterruptedException e) { } try { cb.await(); // 2 秒后，线程个数够2，继续运行 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } System.out.println(\\\"线程2继续向下运行...\\\"+new Date()); }).start();\",\"注意 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比\",\"喻为『人满发车』\"]},\"99\":{\"h\":\"Exchanger\",\"t\":[\"允许在并发线程之间交换数据。\"]},\"100\":{\"h\":\"CompletableFuture\",\"t\":[\"CompletableFuture是Java 8引入的一个异步编程工具类，用于处理异步任务的结果和执行流程。它提供了一种简洁而强大的方式来处理异步操作，包括任务的串行执行、并行执行、组合以及异常处理等。\"]},\"101\":{\"h\":\"LockSupport\",\"t\":[\"提供线程阻塞和唤醒操作的工具类。\",\"在Java中，park方法属java.util.concurrent.locks.LockSupport工具类。LockSupport提供了一些静态方法，用于线程之间的线程阻塞和唤醒操作，park方法就是其中之一。\",\"park方法的作用是阻塞当前线程，直到它被其他线程通过调用LockSupport.unpark(Thread thread)方法唤醒。这通常用于实现锁和其他同步器的框架，以及那些需要更细粒度控制线程阻塞和唤醒的高级并发应用程序。\",\"park方法的用法非常简单，它没有参数，调用后当前线程就会挂起。以下是park方法的一个基本示例：\",\"LockSupport.park();\",\"这行代码会使当前线程进入等待状态，直到另一个线程调用LockSupport.unpark(Thread thread)，其中thread是当前线程的引用，来唤醒它。\",\"LockSupport还提供了一些变体的park方法，允许你指定一个阻塞时间：\",\"LockSupport.parkNanos(long nanos)：阻塞当前线程，直到另一个线程唤醒它或者超过指定的纳秒时间。\",\"LockSupport.parkUntil(long deadline)：阻塞当前线程，直到另一个线程唤醒它或者当前时间超过了指定的截止时间。\",\"使用park和unpark的方法可以在没有使用锁的情况下实现线程间的协作，这在某些情况下可以提高性能，因为它们避免了使用重量级的锁机制。然而，它们也要求开发者更仔细地管理线程的生命周期和状态，以避免常见的并发问题，如死锁。\",\"下面是一个使用park和unpark的简单示例：\",\"public class ParkUnparkExample { public static void main(String[] args) { Thread thread = new Thread(() -> { System.out.println(\\\"Thread is running and will park now.\\\"); LockSupport.park(); System.out.println(\\\"Thread was unparked and is now running again.\\\"); }); thread.start(); // 稍等一下，确保线程已经进入park状态 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 唤醒线程 LockSupport.unpark(thread); } }\",\"在这个例子中，新线程启动后会打印一条消息，然后调用park方法进入等待状态。主线程稍等一秒钟后调用unpark方法唤醒等待的线程，线程被唤醒后继续执行并打印另一条消息。\"]},\"102\":{\"c\":[\"JVM\"]},\"103\":{\"c\":[\"jvm\"]},\"104\":{\"h\":\"Java虚拟机\",\"t\":[\"Java 虚拟机\",\"img\",\"Java Class\",\"ClassLoader\"]},\"105\":{\"h\":\"1.程序计数器\"},\"106\":{\"h\":\"1.1定义\",\"t\":[\"Program Counter Register 程序计数器（寄存器） 作用：是记录下一条 jvm 指令的执行地址行号。 特点：\",\"是线程私有的\",\"不会存在内存溢出\",\"0: getstatic #20 // PrintStream out = System.out; 3: astore_1 // -- 4: aload_1 // out.println(1); 5: iconst_1 // -- 6: invokevirtual #26 // -- 9: aload_1 // out.println(2); 10: iconst_2 // -- 11: invokevirtual #26 // -- 14: aload_1 // out.println(3); 15: iconst_3 // -- 16: invokevirtual #26 // -- 19: aload_1 // out.println(4); 20: iconst_4 // -- 21: invokevirtual #26 // -- 24: aload_1 // out.println(5); 25: iconst_5 // -- 26: invokevirtual #26 // -- 29: return\",\"解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。\",\"多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。\"]},\"107\":{\"h\":\"2.虚拟机栈\",\"t\":[\"img\"]},\"108\":{\"h\":\"2.1 定义\",\"t\":[\"每个线程运行需要的内存空间，称为虚拟机栈\",\"每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存\",\"每个线程只能有一个活动栈帧，对应着当前正在执行的方法\",\"public class main1 { public static void main(String[] args) { method1(); } public static void method1() { method2(1, 2); } public static int method2(int a, int b) { int c = a + b; return c; } }\",\"img\",\"问题辨析：\",\"垃圾回收是否涉及栈内存？ 不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。\",\"栈内存分配越大越好吗？ 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\",\"方法呢的局部变量是否线程安全 \",\"如果方法内部的变量没有逃离方法的作用范围，它是线程安全的\",\"如果是局部变量引用了对象，并逃离了方法的范围，那就要考虑线程安全问题。\",\"public class main1 { public static void main(String[] args) { } //下面各个方法会不会造成线程安全问题？ //不会 public static void m1() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); } //会，可能会有其他线程使用这个对象 public static void m2(StringBuilder sb) { sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); } //会，其他线程可能会拿到这个线程的引用 public static StringBuilder m3() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); return sb; } }\"]},\"109\":{\"h\":\"2.2 栈内存溢出\",\"t\":[\"Java.lang.stackOverflowError 栈内存溢出\",\"导致栈内存溢出的情况：\",\"栈帧****过多导致栈内存溢出\",\"栈帧****过大导致栈内存溢出\",\"栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！\",\"img\",\"设置虚拟机栈内存大小：\",\"img\"]},\"110\":{\"h\":\"2.3 线程运行诊断\",\"t\":[\"案例：CPU占用过高\",\"Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程\",\"用top定位哪个进程对cpu的占用过高\",\"ps H -eo pid,tid,%cpu | grep 进程id ，刚才通过top查到的进程号，用ps命令进一步定位是哪个线程引起的cpu占用过高\",\"jstack 进程id，通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16进制的，需要转换\"]},\"111\":{\"h\":\"3.本地方法栈\",\"t\":[\"一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。\"]},\"112\":{\"h\":\"4.堆\"},\"113\":{\"h\":\"4.1 定义\",\"t\":[\"通过new关键字创建的对象都会使用堆内存\"]},\"114\":{\"h\":\"4.2特点\",\"t\":[\"它是线程共享的，堆中对象都需要考虑线程安全的问题\",\"有垃圾回收机制\"]},\"115\":{\"h\":\"4.3堆内存溢出\",\"t\":[\"java.lang.OutofMemoryError ：java heap space 堆内存溢出\",\"案例：\",\"/** * 演示堆内存溢出 java.lang.OutOfMemoryError: Java heap space * -Xmx8m ，最大堆空间的jvm虚拟机参数，默认是4g */ public class main1 { public static void main(String[] args) { int i = 0; try { ArrayList<String> list = new ArrayList<>();// new 一个list 存入堆中 String a = \\\"hello\\\"; while (true) { list.add(a);// 不断地向list 中添加 a a = a + a; i++; } } catch (Throwable e) {// list 使用结束，被jc 垃圾回收 e.printStackTrace(); System.out.println(i); } } }\",\"结果：\",\"java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at com.itcast.itheima.xpp.main1.main(main1.java:14) 22\"]},\"116\":{\"h\":\"4.4堆内存诊断\",\"t\":[\"jps工具\",\"查看当前系统中有哪些 java 进程\",\"jmap 工具\",\"查看堆内存占用情况 jmap - heap 进程id\",\"jconsole 工具\",\"图形界面的，多功能的监测工具，可以连续监测\",\"jvisualvm 工具\"]},\"117\":{\"h\":\"5.方法区\"},\"118\":{\"h\":\"5.1 定义\",\"t\":[\"Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！\"]},\"119\":{\"h\":\"5.2 组成\",\"t\":[\"永久代用的堆内存\",\"元空间用的本地****内存\",\"Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图\",\"img\"]},\"120\":{\"h\":\"5.3 方法区内存溢出\",\"t\":[\"1.8以前会导致永久代内存溢出java.lang.OutOfMemoryError: PermGen space\",\"1.8以后会导致元空间内存溢出java.lang.OutOfMemoryError: Metaspace\",\"1.8 之前会导致永久代内存溢出 \",\"使用 -XX:MaxPermSize=8m 指定永久代内存大小\",\"1.8 之后会导致元空间内存溢出 \",\"使用 -XX:MaxMetaspaceSize=8m 指定元空间大小\",\"/** * 演示元空间内存溢出:java.lang.OutOfMemoryError: Metaspace * -XX:MaxMetaspaceSize=8m */ public class main1 extends ClassLoader {//可以用来加载类的二进制字节码 public static void main(String[] args) { int j = 0; try { main1 test = new main1(); for (int i = 0; i < 10000; i++,j++) { //ClassWriter 作用是生产类的二进制字节码 ClassWriter cw = new ClassWriter(0); //版本号，public，类名 cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \\\"Class\\\" + i, null, \\\"java/lang/Object\\\", null); //返回 byte[] byte[] code = cw.toByteArray(); //执行类的加载 test.defineClass(\\\"Class\\\" + i, code, 0, code.length); } } finally { System.out.println(j); } } } Exception in thread \\\"main\\\" java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at com.itcast.itheima.xpp.main1.main(main1.java:26) 4865 Process finished with exit code 1\"]},\"121\":{\"h\":\"5.4 通过反编译来查看类的信息\",\"t\":[\"获得对应类的.class文件，javac xxx.java\",\"在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入\",\"img\",\"输入 javac对应类的绝对路径\",\"F:\\\\JAVA\\\\JDK8.0\\\\bin>javac F:\\\\Thread_study\\\\src\\\\com\\\\nyima\\\\JVM\\\\day01\\\\Main.java\",\"输入完成后，对应的目录下就会出现类的.class文件\",\"在控制台输入 javap -v 类的绝对路径\",\"javap -v F:\\\\Thread_study\\\\src\\\\com\\\\nyima\\\\JVM\\\\day01\\\\Main.class\",\"然后能在控制台看到反编译以后类的信息了 \",\"类的基本信息\",\"img\",\"常量池\",\"img\",\"虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）\",\"img\"]},\"122\":{\"h\":\"5.5 运行时常量池\",\"t\":[\"常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\",\"运行时常量池：常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\"]},\"123\":{\"h\":\"5.6 常量池与串池StringTable的关系\",\"t\":[\"StringTable 特性\",\"常量池中的字符串仅是符号，只有在被用到时才会转化为对象\",\"利用串池的机制，来避免重复创建字符串对象\",\"字符串变量拼接的原理是StringBuilder\",\"字符串常量拼接的原理是编译器优化\",\"可以使用intern方法，主动将串池中还没有的字符串对象放入串池中 \",\"1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回\",\"1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回\",\"栗子1：\",\"public class StringTableStudy { public static void main(String[] args) { String a = \\\"a\\\"; String b = \\\"b\\\"; String ab = \\\"ab\\\"; } }\",\"常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，还没有成为java字符串\",\"0: ldc #2 // String a 2: astore_1 3: ldc #3 // String b 5: astore_2 6: ldc #4 // String ab 8: astore_3 9: return\",\"当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，并放入串池中（hashtable结构 不可扩容）\",\"当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中\",\"当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中\",\"最终StringTable [“a”, “b”, “ab”]\",\"注意：字符串对象的创建都是懒惰的，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。\",\"栗子2：使用拼接字符串****变量对象创建字符串的过程\",\"public class HelloWorld { public static void main(String[] args) { String s1 = \\\"a\\\"; String s2 = \\\"b\\\"; String s3 = \\\"ab\\\"; String s4=s1+s2;//new StringBuilder().append(\\\"a\\\").append(\\\"2\\\").toString() new String(\\\"ab\\\") System.out.println(s3==s4);//false //结果为false,因为s3是存在于串池之中，s4是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中 } }\",\"反编译后的结果\",\" Code: stack=2, locals=5, args_size=1 0: ldc #2 // String a 2: astore_1 3: ldc #3 // String b 5: astore_2 6: ldc #4 // String ab 8: astore_3 9: new #5 // class java/lang/StringBuilder 12: dup 13: invokespecial #6 // Method java/lang/StringBuilder.\\\"<init>\\\":()V 16: aload_1 17: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String ;)Ljava/lang/StringBuilder; 20: aload_2 21: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String ;)Ljava/lang/StringBuilder; 24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/Str ing; 27: astore 4 29: return\",\"通过拼接的方式来创建字符串的过程是：StringBuilder().append(“a”).append(“b”).toString()\",\"最后的toString方法的返回值是一个新的字符串，但字符串的值和拼接的字符串一致，但是两个不同的字符串，一个存在于串池之中，一个存在于堆内存之中\",\"栗子3：使用拼接字符串常量对象的方法创建字符串\",\"public class HelloWorld { public static void main(String[] args) { String s1 = \\\"a\\\"; String s2 = \\\"b\\\"; String s3 = \\\"ab\\\"; String s4=s1+s2;//new StringBuilder().a|ppend(\\\"a\\\").append(\\\"2\\\").toString() new String(\\\"ab\\\") String s5=\\\"a\\\"+\\\"b\\\"; System.out.println(s5==s3);//true } }\",\"反编译后的结果\",\" Code: stack=2, locals=6, args_size=1 0: ldc #2 // String a 2: astore_1 3: ldc #3 // String b 5: astore_2 6: ldc #4 // String ab 8: astore_3 9: new #5 // class java/lang/StringBuilder 12: dup 13: invokespecial #6 // Method java/lang/StringBuilder.\\\"<init>\\\":()V 16: aload_1 17: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String ;)Ljava/lang/StringBuilder; 20: aload_2 21: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String ;)Ljava/lang/StringBuilder; 24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/Str ing; 27: astore 4 //ab3初始化时直接从串池中获取字符串 29: ldc #4 // String ab 31: astore 5 33: return\",\"使用拼接字符串常量的方法来创建新的字符串时，因为内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab，而创建ab的时候已经在串池中放入了“ab”，所以s5直接从串池中获取值，所以进行的操作和 s3= “ab” 一致。\",\"使用拼接字符串变量的方法来创建新的字符串时，因为内容是变量，只能在运行期确定它的值，所以需要使用StringBuilder来创建\",\"intern方法 1.8：\",\"调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\",\"如果串池中没有该字符串对象，则放入成功\",\"如果有该字符串对象，则放入失败\",\"无论放入是否成功，都会返回串池中的字符串对象\",\"public class HelloWorld { public static void main(String[] args) { String x = \\\"ab\\\"; String s = new String(\\\"a\\\") + new String(\\\"b\\\"); String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，这两种情况都会把串池中的对象返回 System.out.println(s2 == x);//true System.out.println(s == x);//false } }\"]},\"124\":{\"h\":\"\",\"t\":[\"答：编译器在编译期间会把abc作为常量放在常量池中，这两个语句都会去字符串常量池中检查是否已经存在 “abc”，区别在于new会在堆中创建一个新的对象，String str2 = \\\"abc\\\" 返回字符串常量池的引用。\"]},\"125\":{\"h\":\"\",\"t\":[\"String s3 = \\\"ab\\\";String s4=s1+s2; //newStringBuilder**().a|ppend(\\\"a\\\").append(\\\"2\\\").toString() new String(\\\"ab\\\")** String s5=\\\"a\\\"+\\\"b\\\";\",\"这类题记住编译器在编译期间会把字符字面量作为常量放在常量池中，如果操作的是对象和变量是不会放入常量池中的。\",\"intern方法 1.6：\",\"调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\",\"如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中\",\"如果有该字符串对象，则放入失败\",\"无论放入是否成功，都会返回串池中的字符串对象\",\"面试题（1.8）：\",\"package com.itcast.itheima.xpp; public class main { public static void main(String[] args) { String s1=\\\"a\\\"; String s2=\\\"b\\\"; String s3=\\\"a\\\"+\\\"b\\\"; String s4=s1+s2; String s5=\\\"ab\\\"; String s6=s4.intern(); System.out.println(s3==s4);//false System.out.println(s3==s5);//true System.out.println(s3==s6);//true String x2=new String(\\\"c\\\")+new String(\\\"d\\\"); String x1=\\\"cd\\\"; x2.intern(); System.out.println(x1==x2);//false String x4=new String(\\\"e\\\")+new String(\\\"f\\\"); x4.intern(); String x3=\\\"ef\\\"; System.out.println(x3==x4);//true } }\"]},\"126\":{\"h\":\"5.7 StringTable 位置\",\"t\":[\"img\",\"JDK1.6 时，StringTable是属于常量池的一部分。\",\"JDK1.8 以后，StringTable是放在堆中的。\"]},\"127\":{\"h\":\"5.8 StringTable 垃圾回收\",\"t\":[\"StringTable在内存紧张时，会发生垃圾回收\",\"-Xmx10m 指定堆内存大小 -XX:+PrintStringTableStatistics 打印字符串常量池信息 -XX:+PrintGCDetails -verbose:gc 打印 gc 的次数，耗费时间等信息\",\"/** * 演示 StringTable 垃圾回收 * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc */ public class Code_05_StringTableTest { public static void main(String[] args) { int i = 0; try { for(int j = 0; j < 10000; j++) { // j = 100, j = 10000 String.valueOf(j).intern(); i++; } }catch (Exception e) { e.printStackTrace(); }finally { System.out.println(i); } } }\"]},\"128\":{\"h\":\"5.9 StringTable 性能调优\",\"t\":[\"因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间\",\"-XX:StringTableSize=桶个数（最少设置为 1009 以上）\",\"考虑是否需要将字符串对象入池 可以通过 intern 方法减少重复入池\"]},\"129\":{\"h\":\"6.直接内存\"},\"130\":{\"h\":\"6.1 定义\",\"t\":[\"属于操作系统，常见于NIO操作时，用于数据缓冲区\",\"分配回收成本较高，但读写性能高\",\"不受JVM内存回收管理\"]},\"131\":{\"h\":\"6.2 使用直接内存的好处\",\"t\":[\"文件读写流程：\",\"img\",\"因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。\",\"使用了 DirectBuffer 文件读取流程\",\"img\",\"直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。\"]},\"132\":{\"h\":\"\",\"t\":[\"public class Main { static int _100MB = 1024 * 1024 * 100; public static void main(String[] args) throws IOException { List<ByteBuffer> list = new ArrayList<>(); int i = 0; try { while (true) { ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100MB); list.add(byteBuffer); i++; } } finally { System.out.println(i); } } } //输出： 2 Exception in thread \\\"main\\\" java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:694) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at main.Main.main(Main.java:19)\",\"直接内存释放原理：\",\"直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过unsafe.freeMemory来手动释放\",\"通过申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？\",\"//通过ByteBuffer申请1M的直接内存ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\",\"allocateDirect的实现：\",\"public static ByteBuffer allocateDirect(int capacity) {return new DirectByteBuffer(capacity);}\",\"DirectByteBuffer类：\",\"DirectByteBuffer(int cap) { // package-private super(-1, 0, cap, cap); boolean pa = VM.isDirectMemoryPageAligned(); int ps = Bits.pageSize(); long size = Math.max(1L, (long)cap + (pa ? ps : 0)); Bits.reserveMemory(size, cap); long base = 0; try { base = unsafe.allocateMemory(size); //申请内存 } catch (OutOfMemoryError x) { Bits.unreserveMemory(size, cap); throw x; } unsafe.setMemory(base, size, (byte) 0); if (pa && (base % ps != 0)) { // Round up to page boundary address = base + ps - (base & (ps - 1)); } else { address = base; } cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象 att = null; }\",\"这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存\",\"public void clean() { if (remove(this)) { try { this.thunk.run(); //调用run方法 } catch (final Throwable var2) { AccessController.doPrivileged(new PrivilegedAction<Void>() { public Void run() { if (System.err != null) { (new Error(\\\"Cleaner terminated abnormally\\\", var2)).printStackTrace(); } System.exit(1); return null; } }); }\",\"run方法：\",\"public void run() { if (address == 0) { // Paranoia return; } unsafe.freeMemory(address); //释放直接内存中占用的内存 address = 0; Bits.unreserveMemory(size, capacity); }\",\"直接内存的回收机制总结：\",\"使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法\",\"ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存\"]},\"133\":{\"h\":\"6.3 直接内存回收原理\",\"t\":[\"public class Code_06_DirectMemoryTest { public static int _1GB = 1024 * 1024 * 1024; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { // method(); method1(); } // 演示 直接内存 是被 unsafe 创建与回收 private static void method1() throws IOException, NoSuchFieldException, IllegalAccessException { Field field = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); field.setAccessible(true); Unsafe unsafe = (Unsafe)field.get(Unsafe.class); long base = unsafe.allocateMemory(_1GB); unsafe.setMemory(base,_1GB, (byte)0); System.in.read(); unsafe.freeMemory(base); System.in.read(); } // 演示 直接内存被 释放 private static void method() throws IOException { ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB); System.out.println(\\\"分配完毕\\\"); System.in.read(); System.out.println(\\\"开始释放\\\"); byteBuffer = null; System.gc(); // 手动 gc System.in.read(); } } /** * -XX:+DisableExplicitGC 显示的 */ private static void method() throws IOException { ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB); System.out.println(\\\"分配完毕\\\"); System.in.read(); System.out.println(\\\"开始释放\\\"); byteBuffer = null; System.gc(); // 手动 gc 失效 System.in.read(); }\",\"一般用 jvm 调优时，会加上下面的参数：\",\"-XX:+DisableExplicitGC // 静止显示的 GC\",\"意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。\"]},\"134\":{\"h\":\"1.如何判断对象可以回收\"},\"135\":{\"h\":\"1.1 引用计数法\",\"t\":[\"当一个对象被其他变量引用，该对象计数加一，当某个变量不在引用该对象，其计数减一\",\"当一个对象引用没有被其他变量引用时，即计数变为0时，该对象就可以被回收\"]},\"136\":{\"h\":\"：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放\",\"t\":[\"img\"]},\"137\":{\"h\":\"1.2 可达性分析算法\",\"t\":[\"JVM中的垃圾回收器通过可达性分析来探索所有存活的对象\",\"扫描堆中的对象，看能否沿着GCRoot对象为起点的引用链找到该对象，如果找不到，则表示可以回收\"]},\"138\":{\"h\":\"可以作为 的对象\",\"t\":[\"虚拟机栈（栈帧中的本地变量表）中引用的对象。\",\"方法区中类静态属性引用的对象\",\"方法区中常量引用的对象\",\"本地方法栈中JNI（即一般说的Native方法）引用的对象\",\"所有被同步锁（synchronized关键字）持有的对象。\"]},\"139\":{\"h\":\"使用Memory Analyzer (MAT)分析。\",\"t\":[\"public static void main(String[] args) throws IOException { ArrayList<Object> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"b\\\"); list.add(1); System.out.println(1); System.in.read(); list = null; System.out.println(2); System.in.read(); System.out.println(\\\"end\\\"); }\",\"对于以上代码，可以使用如下命令将堆内存信息转储成一个文件，然后使用 Eclipse Memory Analyzer 工具进行分析。 第一步： 使用 jps 命令，查看程序的进程\",\"img\",\"第二步：\",\"img\",\"使用 jmap -dump:format=b,live,file=1.bin 16104 命令转储文件 dump：转储文件 format=b：二进制文件 file：文件名 16104：进程的id 第三步：打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析。\",\"img\",\"分析的 gc root，找到了 ArrayList 对象，然后将 list 置为null，再次转储，那么 list 对象就会被回收。\"]},\"140\":{\"h\":\"1.3 五种引用\",\"t\":[\"img\"]},\"141\":{\"h\":\"\",\"t\":[\"只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收\"]},\"142\":{\"h\":\"\",\"t\":[\"仅有【软引用】引用该对象时，在垃圾回收后，内存****仍不足时会再次出发垃圾回收，回收软引用对象\",\"可以配合【引用队列】来释放软引用自身\"]},\"143\":{\"h\":\"\",\"t\":[\"仅有【弱引用】引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象\",\"可以配合【引用队列】来释放弱引用自身\"]},\"144\":{\"h\":\"\",\"t\":[\"必须配合【引用队列】使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将【虚引用】入队， 由 Reference Handler 线程调用虚引用相关方法释放【直接内存】\",\"如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存\"]},\"145\":{\"h\":\"\",\"t\":[\"无需手动编码，但其内部配合【引用队列】使用，在垃圾回收时，【终结器引用】入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过【终结器引用】找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象\",\"如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了\"]},\"146\":{\"h\":\"\",\"t\":[\"public class Demo1 { public static void main(String[] args) { final int _4M = 4*1024*1024; //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用 List<SoftReference<byte[]>> list = new ArrayList<>(); SoftReference<byte[]> ref= new SoftReference<>(new byte[_4M]); } } /** * 演示 软引用 * -Xmx20m -XX:+PrintGCDetails -verbose:gc */ public class Code_08_SoftReferenceTest { public static int _4MB = 4 * 1024 * 1024; public static void main(String[] args) throws IOException { method2(); } // 设置 -Xmx20m , 演示堆内存不足, public static void method1() throws IOException { ArrayList<byte[]> list = new ArrayList<>(); for(int i = 0; i < 5; i++) { list.add(new byte[_4MB]); } System.in.read(); } // 演示 软引用 public static void method2() throws IOException { ArrayList<SoftReference<byte[]>> list = new ArrayList<>(); for(int i = 0; i < 5; i++) { SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB]); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); } System.out.println(\\\"循环结束：\\\" + list.size()); for(SoftReference<byte[]> ref : list) { System.out.println(ref.get()); } } }\",\"method1 方法解析： 首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。\",\"img\",\"method2 方法解析： 在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：\",\"img\",\"上面的代码中，当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。\",\"修改 method2 如下：\",\"// 演示 软引用 搭配引用队列 public static void method3() throws IOException { //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用 ArrayList<SoftReference<byte[]>> list = new ArrayList<>(); ///使用引用队列，用于移除引用为空的软引用对象 ReferenceQueue<byte[]> queue = new ReferenceQueue<>(); for(int i = 0; i < 5; i++) { // 关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去 SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB], queue); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); } // 从队列中获取无用的 软引用对象，并移除 Reference<? extends byte[]> poll = queue.poll(); //遍历引用队列，如果有元素，则移除 while(poll != null) { list.remove(poll); poll = queue.poll(); } System.out.println(\\\"=====================\\\"); for(SoftReference<byte[]> ref : list) { System.out.println(ref.get()); } }\",\"img\"]},\"147\":{\"h\":\"\",\"t\":[\"弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference\",\"public class Code_09_WeakReferenceTest { public static void main(String[] args) { // method1(); method2(); } public static int _4MB = 4 * 1024 *1024; // 演示 弱引用 public static void method1() { List<WeakReference<byte[]>> list = new ArrayList<>(); for(int i = 0; i < 10; i++) { WeakReference<byte[]> weakReference = new WeakReference<>(new byte[_4MB]); list.add(weakReference); for(WeakReference<byte[]> wake : list) { System.out.print(wake.get() + \\\",\\\"); } System.out.println(); } } // 演示 弱引用搭配 引用队列 public static void method2() { List<WeakReference<byte[]>> list = new ArrayList<>(); ReferenceQueue<byte[]> queue = new ReferenceQueue<>(); for(int i = 0; i < 9; i++) { WeakReference<byte[]> weakReference = new WeakReference<>(new byte[_4MB], queue); list.add(weakReference); for(WeakReference<byte[]> wake : list) { System.out.print(wake.get() + \\\",\\\"); } System.out.println(); } System.out.println(\\\"===========================================\\\"); Reference<? extends byte[]> poll = queue.poll(); while (poll != null) { list.remove(poll); poll = queue.poll(); } for(WeakReference<byte[]> wake : list) { System.out.print(wake.get() + \\\",\\\"); } } }\"]},\"148\":{\"h\":\"2. 垃圾回收算法\"},\"149\":{\"h\":\"2.1 标记清除\",\"t\":[\"img\",\"定义：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间\",\"注意：这里的清除并不是将内存空间字节清零，而是记录这段内存的起始地址，下次分配内存的时候，会直接覆盖这段内存。\",\"优点：速度快\",\"缺点：容易产生内存碎片。一旦分配较大内存的对象，由于内存不连续，导致无法分配，最后就会造成内存溢出问题\"]},\"150\":{\"h\":\"2.2 标记整理\",\"t\":[\"img\",\"定义：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后整理剩余的对象，将可用的对象移动到一起，使内存更加紧凑，连续的空间就更多。\",\"优点：不会有内存碎片\",\"缺点：整理时需要重新处理引用关系，速度慢\"]},\"151\":{\"h\":\"2.3 复制\",\"t\":[\"img\",\"定义：将内存分为等大小的两个区域，FROM和TO（TO中为空）。将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。\",\"优点：不会有内存碎片\",\"缺点：会占用双倍的内存空间。\"]},\"152\":{\"h\":\"3. 分代垃圾回收\",\"t\":[\"将堆内存分为新生代和老年代，新生代有划分为伊甸园，幸存区To，幸存区From。\",\"img\"]},\"153\":{\"h\":\"3.1 回收流程\",\"t\":[\"对象首先分配在伊甸园区域\",\"img\",\"新生代空间不足时，触发 MinorGC，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to\",\"img\",\"img\",\"img\",\"再次创建对象，若新生代的伊甸园又满了，则会再次触发 MinorGC（minor gc 会引发 stop the world（可以看下go语言的垃圾三色标记机制，减少STW），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1\",\"img\",\"当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），因为java对象头只用4个bit来表示，最大表示2进制1111。\",\"img\",\"当老年代空间不足，会先尝试触发MinorGC，如果之后空间仍不足，那么触发 Full GC，stop the world的时间更长\"]},\"154\":{\"h\":\"3.2 GC 分析\"},\"155\":{\"h\":\"\",\"t\":[\"含义参数堆初始大小-Xms堆最大大小-Xmx 或 -XX:MaxHeapSize=size新生代大小-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )幸存区比例（动态）-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy幸存区比例-XX:SurvivorRatio=ratio晋升阈值-XX:MaxTenuringThreshold=threshold晋升详情-XX:+PrintTenuringDistributionGC详情-XX:+PrintGCDetails -verbose:gcFullGC 前 MinorGCXX:+ScavengeBeforeFullGC\",\"public class Code_10_GCTest { private static final int _512KB = 512 * 1024; private static final int _1MB = 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; // -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc public static void main(String[] args) { List<byte[]> list = new ArrayList<>(); list.add(new byte[_6MB]); list.add(new byte[_512KB]); list.add(new byte[_6MB]); list.add(new byte[_512KB]); list.add(new byte[_6MB]); } }\",\"通过上面的代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，使用前需要设置 jvm 参数。\"]},\"156\":{\"h\":\"\",\"t\":[\"遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代\",\"/** * 演示内存的分配策略 */ public class Main { private static final int _512KB = 512 * 1024; private static final int _1MB = 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC public static void main(String[] args) throws InterruptedException { ArrayList<byte[]> list=new ArrayList<>(); list.add(new byte[_8MB]); } }\",\"img\"]},\"157\":{\"h\":\"\",\"t\":[\"某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常\",\"/** * 演示内存的分配策略 */ public class Main { private static final int _512KB = 512 * 1024; private static final int _1MB = 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC public static void main(String[] args) throws InterruptedException { new Thread(() -> { ArrayList<byte[]> list = new ArrayList<>(); list.add(new byte[_8MB]); list.add(new byte[_8MB]); }).start(); //主线程还是会正常执行 System.out.println(\\\"sleep....\\\"); Thread.sleep(1000L); } }\",\"img\"]},\"158\":{\"h\":\"4. 垃圾回收器\",\"t\":[\"img\",\"垃圾收集器特点算法适用场景优点缺点Serial最基本、历史最悠久的单线程垃圾收集器。新生代采用标记-复制算法运行在 Client 模式下的虚拟机简单、高效垃圾回收时必须暂停其他所有的工作线程ParNewSerial 收集器的多线程版本新生代采用标记-复制算法运行在 Server 模式下的虚拟机并行，效率高 Parallel Scavenge使用标记-复制算法的多线程收集器，关注吞吐量新生代采用标记-复制算法JDK1.8 默认收集器在注重吞吐量及CPU资源的场合吞吐量高 Serial OldSerial 收集器的老年代版本标记-整理算法在 JDK<1.5与 Parallel Scavenge 收集器搭配使用作为CMS收集器的后备方案简单、高效垃圾回收时必须暂停其他所有的工作线程Parallel OldParallel Scavenge 收集器的老年代标记-整理算法在注重吞吐量及CPU资源的场合吞吐量高 CMS多线程的垃圾收集器（用户线程和垃圾回收线程可以同时进行）标记-清除算法希望系统停顿时间最短，注重服务的响应速度的场景并发收集、低停顿对 CPU 资源敏感，无法处理浮动垃圾，产生垃圾碎片G1一款面向服务器的垃圾收集器，并行并发，空间整合，可预测的停顿时间标记-复制算法服务端应用、针对具有大内存多处理器的机器停顿时间可控、基本无空间碎片可能存在空间浪费、程序运行时的额外执行负载高\",\"相关概念：\",\"并行****收集：指多条垃圾收集线程并行工作，但此时用户线程****仍处于等待状态\",\"并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上\",\"吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%\"]},\"159\":{\"h\":\"4.1 串行（Serial + SerialOld，新生代复制，老年代标记整理）\",\"t\":[\"单线程\",\"堆内存小，适合个人电脑\",\"img\",\"开启串行回收器：\",\"XX:+UseSerialGC = Serial + SerialOld，新生代Serial ，老年代SerialOld\",\"安全点：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。\",\"阻塞：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态\",\"Serial 收集器：\",\"定义：Serial收集器是最基本的、发展历史最悠久的收集器\",\"特点：单线程收集器。采用复制算法。工作在新生代\",\"Serial 收集器是最基本的、发展历史最悠久的收集器 特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！\",\"Serial Old收集器：\",\"定义：Serial Old是Serial收集器的老年代版本\",\"特点：单线程收集器。采用标记-整理算法。工作在老年代\",\"同样是单线程收集器，采用标记-整理算法\",\"ParNew 收集器 ParNew 收集器其实就是 Serial 收集器的多线程版本 特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题\"]},\"160\":{\"h\":\"4.2 吞吐量优先\",\"t\":[\"多线程\",\"堆内存较大，多核cpu\",\"让单位时间****内暂停时间（STW）最短\",\"JDK1.8默认使用的垃圾回收器\",\"img\",\"-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC -XX:+UseAdaptiveSizePolicy -XX:GCTimeRatio=ratio // 1/(1+radio) -XX:MaxGCPauseMillis=ms // 200ms -XX:ParallelGCThreads=n\",\"Parallel 收集器：\",\"定义：与吞吐量关系密切，故也称为吞吐量优先收集器\",\"特点：并行****的，工作于新生代，采用复制算法\",\"与吞吐量关系密切，故也称为吞吐量优先收集器 特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）\",\"该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）\",\"GC自适应调节策略： Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。 当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、 晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。\",\"Parallel Scavenge 收集器使用两个参数控制吞吐量：\",\"XX:MaxGCPauseMillis=ms 控制最大的垃圾收集停顿时间（默认200ms）\",\"XX:GCTimeRatio=rario 直接设置吞吐量的大小\",\"Parallel Old 收集器：\",\"定义：是Parallel 收集器的老年代版本\",\"特点：并行****的，工作与老年代，采用标记-整理算法\",\"是 Parallel Scavenge 收集器的老年代版本 特点：多线程，采用标记-整理算法（老年代没有幸存区）\"]},\"161\":{\"h\":\"4.3 响应时间优先\",\"t\":[\"多线程\",\"堆内存较大，多核cpu\",\"尽可能让单次的暂停时间（STW）最短\",\"img\",\"-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads -XX:CMSInitiatingOccupancyFraction=percent -XX:+CMSScavengeBeforeRemark\",\"CMS****收集器：\",\"定义：Concurrent Mark Sweep（并发，标记，清除）\",\"特点：基于标记-清除算法的垃圾回收器。是并发的。工作在老年代。\",\"Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片 应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b/s 服务\",\"CMS收集器的运行过程分为下列4步：\",\"初始标记：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。\",\"并发标记：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。\",\"重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题\",\"并发清除：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！\",\"CMS 收集器的内存回收过程是与用户线程一起并发执行的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。\",\"ParNew 收集器：\",\"定义：ParNew收集器其实就是Serial收集器的多线程版本\",\"特点：工作在新生代，基于复制算法的垃圾回收器。\"]},\"162\":{\"h\":\"4.4 Garbage First\",\"t\":[\"JDK 9以后默认使用，而且替代了CMS 收集器\",\"适用场景：\",\"同时注重吞吐量****（Throughput）和****低延迟（Low latency），默认的暂停目标是 200 ms\",\"超大堆内存，会将堆划分为多个大小相等的 Region\",\"整体上是 标记+整理 算法，两个区域之间是 复制 算法\",\"相关参数： JDK8 并不是默认开启的，所需要参数开启\",\"-XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time\",\"垃圾回收****阶段：\",\"img\",\"新生代伊甸园垃圾回收—–>内存不足，新生代回收+并发标记—–>混合收集，回收新生代伊甸园、幸存区、老年代内存——>新生代伊甸园垃圾回收（重新开始）\",\"Young Collection：对新生代垃圾收集 Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。 Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。\"]},\"163\":{\"h\":\"Young Collection\",\"t\":[\"新生代存在 STW： 分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！ E：eden，S：幸存区，O：老年代 新生代收集会产生 STW ！\",\"E：伊甸园 S：幸存区 O：老年代\",\"img\",\"img\",\"img\"]},\"164\":{\"h\":\"：\",\"t\":[\"CM：并发标记\",\"在 Young GC 时会对 GC Root 进行初始标记\",\"在老年代占用堆内存的比例达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定，由下面的 JVM 参数决定 -XX:InitiatingHeapOccupancyPercent=percent （默认45%）\",\"img\"]},\"165\":{\"h\":\"\",\"t\":[\"会对E S O 进行全面的回收\",\"最终标记（Remark）会STW\",\"拷贝存活（Evacuation）会STW\",\"-XX:MaxGCPauseMills:xxx ：用于指定最长的停顿时间\",\"img\",\"问：为什么有的老年代被拷贝了，有的没拷贝？\",\"因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）\"]},\"166\":{\"h\":\"\",\"t\":[\"SerialGC\",\"新生代内存不足发生的垃圾收集 - minor gc\",\"老年代内存不足发生的垃圾收集 - full gc\",\"ParallelGC\",\"新生代内存不足发生的垃圾收集 - minor gc\",\"老年代内存不足发生的垃圾收集 - full gc\",\"CMS\",\"新生代内存不足发生的垃圾收集 - minor gc\",\"老年代内存不足\",\"G1\",\"新生代内存不足发生的垃圾收集 - minor gc\",\"老年代内存不足（老年代所占内存超过阈值） \",\"如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理\",\"如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。\"]},\"167\":{\"h\":\"Young Collection 跨代引用\",\"t\":[\"新生代回收的跨代引用（老年代引用新生代）问题\",\"img\",\"卡表：老年代被划为一个个卡表\",\"Remembered Set：Remembered Set 存在于E（新生代）中，用于保存新生代对象对应的脏卡\",\"脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡\",\"在引用变更时通过post-write barried + dirty card queue\",\"concurrent refinement threads 更新 Remembered Set\",\"img\"]},\"168\":{\"h\":\"\",\"t\":[\"重新标记阶段 在垃圾回收时，收集器处理对象的过程中\",\"黑色：已被处理，需要保留的\",\"灰色：正在处理中的\",\"白色：还未处理的\",\"img\",\"img\",\"img\",\"但是在并发标记过程中，有可能黑色A被处理了以后未引用C，后面又引用了C，这时就会用到remark\",\"之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态\",\"在并发标记阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它\",\"img\",\"img\"]},\"169\":{\"h\":\"：\",\"t\":[\"优点：节省大量内存\",\"缺点：略微多占用了 cpu 时间，新生代回收时间略微增加\",\"例如：\",\"String s1 = new String(\\\"hello\\\"); // char[]{'h','e','l','l','o'} String s2 = new String(\\\"hello\\\"); // char[]{'h','e','l','l','o'}\",\"将所有新分配的字符串（底层是char[]）放入一个队列\",\"当新生代回收时，G1并发检查是否有重复的字符串\",\"如果字符串的值一样，就让他们引用同一个字符串对象\",\"注意，其与String.intern的区别 \",\"intern关注的是字符串对象\",\"字符串去重关注的是char[]\",\"在JVM内部，使用了不同的字符串表\",\"-XX:+UseStringDeduplication\"]},\"170\":{\"h\":\"\",\"t\":[\"所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类\",\"-XX:+ClassUnloadingWithConcurrentMark 默认启用\"]},\"171\":{\"h\":\"JDK 8u60 回收巨型对象\",\"t\":[\"一个对象大于region的一半时，就称为巨型对象\",\"G1不会对巨型对象进行拷贝\",\"回收时被优先考虑\",\"G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉\",\"img\",\"JDK 9 并发标记起始时间的调整：\",\"并发标记必须在堆空间占满前完成，否则退化为 FullGC\",\"JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent\",\"JDK 9 可以动态调整 \",\"-XX:InitiatingHeapOccupancyPercent 用来设置初始值\",\"进行数据采样并动态调整\",\"总会添加一个安全的空档空间\"]},\"172\":{\"h\":\"5. 垃圾回收调优\",\"t\":[\"查看虚拟机参数命令\",\"D:\\\\JavaJDK1.8\\\\bin\\\\java -XX:+PrintFlagsFinal -version | findstr \\\"GC\\\"\",\"可以根据参数去查询具体的信息\"]},\"173\":{\"h\":\"5.1 调优领域\",\"t\":[\"内存\",\"锁竞争\",\"cpu 占用\",\"io\",\"gc\"]},\"174\":{\"h\":\"5.2 确定目标\",\"t\":[\"低延迟/高吞吐量？ 选择合适的GC，科学运算注重吞吐量，互联网注重低延迟。\",\"CMS G1 ZGC，低延迟\",\"ParallelGC，高吞吐量\",\"Zing\"]},\"175\":{\"h\":\"5.3 最快的 GC是不发生GC\",\"t\":[\"首先排除减少因为自身编写的代码而引发的内存问题\",\"查看 Full GC 前后的内存占用，考虑以下几个问题 \",\"数据是不是太多？ \",\"resultSet = statement.executeQuery(“select * from 大表 limit n”)\",\"数据表示是否太臃肿 \",\"对象图\",\"对象大小 16 Integer 24 int 4\",\"是否存在内存泄漏 \",\"static Map map …\",\"软\",\"弱\",\"第三方缓存实现 redis......\"]},\"176\":{\"h\":\"5.4 新生代调优\",\"t\":[\"新生代的特点 \",\"所有的 new 操作分配内存都是非常廉价的 \",\"TLAB thread-local allocation buffer（可防止多个线程创建对象时的干扰）\",\"死亡对象回收零代价\",\"大部分对象用过即死（朝生夕死）\",\"Minor GC 所用时间远小于 Full GC\",\"新生代内存越大越好么？ \",\"不是 \",\"新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降\",\"新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长\",\"新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜\",\"img\",\"幸存区需要能够保存 当前活跃对象+需要晋升的对象\",\"晋升阈值配置得当，让长时间存活的对象尽快晋升\",\"-XX:MaxTenuringThreshold=threshold -XX:+PrintTenuringDistrubution\"]},\"177\":{\"h\":\"5.5 老年代调优\",\"t\":[\"以 CMS 为例：\",\"CMS 的老年代内存越大越好\",\"先尝试不做调优，如果没有 Full GC 那么已经，否者先尝试调优新生代。\",\"观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3\",\"-XX:CMSInitiatingOccupancyFraction=percent\"]},\"178\":{\"h\":\"5.6 案例\",\"t\":[\"案例1：Full GC 和 Minor GC 频繁 案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS） 案例3：老年代充裕情况下，发生 Full GC（jdk1.7）\",\"img\"]},\"179\":{\"h\":\"1. 类文件结构\",\"t\":[\"一个简单的 HelloWorld.java\",\"// HelloWorld 示例 public class HelloWorld { public static void main(String[] args) { System.out.println(\\\"hello world\\\"); } }\",\"执行 javac -parameters -d . HellowWorld.java\",\"Linux 为：od -t xC HelloWorld.class\",\"编译为 HelloWorld.class 得到的字节码文件是这个样子的：\",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14\",\"根据 JVM 规范，类文件结构如下\",\"u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];\"]},\"180\":{\"h\":\"1.1 魔数\",\"t\":[\"u4 magic\",\"对应字节码文件 0~3 字节，表示它是否是【class】类型的文件\",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\",\"ca fe ba be ：意思是 .class 文件，不同的东西有不同的魔数，比如 jpg、png 图片等！\"]},\"181\":{\"h\":\"1.2 版本\",\"t\":[\"u2 minor_version; u2 major_version; 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 00 00 00 34：34H（16进制） = 52（10进制），代表JDK8\",\"对应字节码文件 4~7 字节，表示类的版本 00 34（52） 表示是 Java 8\",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\"]},\"182\":{\"h\":\"1.3 常量池\",\"t\":[\"参考文档 传送门\",\"Constant Type\",\"Value\",\"CONSTANT_Class\",\"7\",\"CONSTANT_Fieldref\",\"9\",\"CONSTANT_Methodref\",\"10\",\"CONSTANT_InterfaceMethodref\",\"11\",\"CONSTANT_String\",\"8\",\"CONSTANT_Integer\",\"3\",\"CONSTANT_Float\",\"4\",\"CONSTANT_Long\",\"5\",\"CONSTANT_Double\",\"6\",\"CONSTANT_NameAndType\",\"12\",\"CONSTANT_Utf8\",\"1\",\"CONSTANT_MethodHandle\",\"15\",\"CONSTANT_MethodType\",\"16\",\"CONSTANT_InvokeDynamic\",\"18\",\"8~9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1~#34项，注意 #0 项不计入，也没有值，\",\"分析过程，碰到属于Constant Type的值就去表中找类型，\",\"比如第一项0a是CONSTANT_Methodref，00 06 00 15引用了常量池中 #6 和 #21 项，后面09是CONSTANT_Fieldref，00 16 00 17表示它引用了常量池中 #22 和 # 23 项，依次类推，另外utf-8的串用2个字节来表示长度，后面是数据。\",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\",\"第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】\",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\",\"第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】 \",\"0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\",\"0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07\",\"第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项\",\"0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07\",\"第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26\",\"项来获得这个方法的【所属类】和【方法名】\",\"0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07\",\"第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项\",\"0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07\",\"第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项 \",\"0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07\",\"0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29\",\"第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 <init> 】\",\"0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29\",\"第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值\",\"0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29\",\"0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e\",\"第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】\",\"0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e\",\"第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65是【LineNumberTable】 \",\"0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e\",\"0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63\",\"第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】 \",\"0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63\",\"0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01\",\"第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】 \",\"0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01\",\"0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63\",\"第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】 \",\"0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63\",\"0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f\",\"0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16\",\"第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】\",\"0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16\",\"第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值\",\"0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16\",\"0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72\",\"0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13\",\"第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】\",\"0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13\",\"第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】 \",\"0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13\",\"0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69\",\"0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61\",\"第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】 \",\"0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61\",\"0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46\",\"第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】 \",\"0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46\",\"0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64\",\"第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】 \",\"0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64\",\"0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e\",\"第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项\",\"0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e\",\"第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项\",\"0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e\",\"第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项 \",\"0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e\",\"0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64\",\"第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】\",\"0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64\",\"第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项\",\"0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74\",\"第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项\",\"0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74\",\"第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】 \",\"0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74\",\"0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c\",\"0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61\",\"第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】 \",\"0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61\",\"0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61\",\"第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】 \",\"0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61\",\"0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f\",\"第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】 \",\"0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f\",\"0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72\",\"第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】 \",\"0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72\",\"0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76\",\"Flag Name Value Interpretation\",\"ACC_PUBLIC 0x0001\",\"Declared public ; may be accessed from outside its\",\"package.\",\"ACC_FINAL 0x0010 Declared final ; no subclasses allowed.\",\"ACC_SUPER 0x0020\",\"Treat superclass methods specially when invoked by the\",\"invokespecial instruction.\",\"ACC_INTERFACE 0x0200 Is an interface, not a class.\",\"ACC_ABSTRACT 0x0400 Declared abstract ; must not be instantiated.\",\"ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code.\",\"ACC_ANNOTATION 0x2000 Declared as an annotation type.\",\"ACC_ENUM 0x4000 Declared as an enum type.\",\"第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】 \",\"0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76\",\"0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d\",\"第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】\",\"0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a\",\"第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】 \",\"0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a\",\"0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b\",\"0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01\"]},\"183\":{\"h\":\"1.4 访问标识与继承信息\",\"t\":[\"21 表示该 class 是一个类，公共的\",\"0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01\",\"05 表示根据常量池中 #5 找到本类全限定名\",\"0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01\",\"06 表示根据常量池中 #6 找到父类全限定名\",\"0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01\",\"表示接口的数量，本类为 0\",\"0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01\"]},\"184\":{\"h\":\"2. 字节码指令\",\"t\":[\"可参考： 字节码指令\",\"img\",\"img\"]},\"185\":{\"h\":\"2.1 javap工具\",\"t\":[\"Oracle 提供了 javap 工具来反编译 class 文件，还有其他的idea插件可以直接查看。\",\"javap -v 类名.class\"]},\"186\":{\"h\":\"2.2 图解方法执行流程\"},\"187\":{\"h\":\"（1）\",\"t\":[\"public class Demo3_1 { public static void main(String[] args) { int a = 10; int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); } }\"]},\"188\":{\"h\":\"（2）编译后的字节码文件\",\"t\":[\"C:\\\\Users\\\\30287\\\\IdeaProjects\\\\paiXppLL\\\\src\\\\main>javap -v Main.class Classfile /C:/Users/30287/IdeaProjects/paiXppLL/src/main/Main.class Last modified 2021-10-14; size 419 bytes MD5 checksum eda2e7897356a975438fe5899c0b4a6c Compiled from \\\"Main.java\\\" public class main.Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object.\\\"<init>\\\":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // hello world! #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // main/Main #6 = Class #22 // java/lang/Object #7 = Utf8 <init> #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // \\\"<init>\\\":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 hello world! #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 main/Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V { public main.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\\\"<init>\\\":()V 4: return LineNumberTable: line 13: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello world! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 15: 0 line 16: 8 }\"]},\"189\":{\"h\":\"（3）常量池载入运行时常量池\",\"t\":[\"常量池也属于方法区，只不过这里单独提出来了\",\"img\"]},\"190\":{\"h\":\"（4）\",\"t\":[\"img\"]},\"191\":{\"h\":\"（5）main 线程开始运行，分配栈帧内存\",\"t\":[\"stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位\",\"img\"]},\"192\":{\"h\":\"\",\"t\":[\"将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有\",\"sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）\",\"ldc 将一个 int 压入操作数栈\",\"ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）\",\"这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了****常量池\",\"img\",\"istore 1 将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中 对应代码中的 a = 10\",\"img\",\"img\",\"ldc #3\",\"读取运行时常量池中 #3 ，即 32768 (超过 short 最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中\",\"注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的。\",\"img\",\"istore 2 将操作数栈中的元素弹出，放到局部变量表的 2 号位置\",\"img\",\"iload1 iload2 将局部变量表中 1 号位置和 2 号位置的元素放入操作数栈中。因为只能在操作数栈中执行运算操作\",\"img\",\"img\",\"iadd 将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中。\",\"img\",\"img\",\"istore 3 将操作数栈中的元素弹出，放入局部变量表的3号位置。\",\"img\",\"getstatic #4 在运行时常量池中找到 #4 ，发现是一个对象，在堆内存中找到该对象，并将其引用放入操作数栈中\",\"img\",\"img\",\"iload 3 将局部变量表中 3 号位置的元素压入操作数栈中。\",\"img\",\"img\",\"invokevirtual #5\",\"找到常量池 #5 项，\",\"定位到方法区 java/io/PrintStream.println:(I)V 方法\",\"生成新的栈帧（分配 locals、stack等）\",\"传递参数，执行新栈帧中的字节码\",\"img\",\"执行完毕，弹出栈帧 清除 main 操作数栈内容\",\"img\",\"return 完成 main 方法调用，弹出 main 栈帧，程序结束\"]},\"193\":{\"h\":\"2.3 练习 - 分析 i++\",\"t\":[\"代码\",\"package cn.itcast.jvm.t3.bytecode; /** * 从字节码角度分析 a++ 相关题目 */ public class Demo3_2 { public static void main(String[] args) { int a = 10; int b = a++ + ++a + a--; System.out.println(a); System.out.println(b); } } public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: iinc 1, 1 10: iload_1 11: iadd 12: iload_1 13: iinc 1, -1 16: iadd 17: istore_2 18: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 21: iload_1 22: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 25: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 28: iload_2 29: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 32: return LineNumberTable: line 8: 0 line 9: 3 line 10: 18 line 11: 25 line 12: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava/lang/String; 3 30 1 a I 18 15 2 b I\",\"分析：\",\"注意 iinc 指令是直接在局部变量 slot 上进行运算\",\"a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\",\"img\"]},\"194\":{\"h\":\"2.4 条件判断指令\",\"t\":[\"指令\",\"助记符\",\"含义\",\"0x99\",\"ifeq\",\"判断是否 == 0\",\"0x9a\",\"ifne\",\"判断是否 != 0\",\"0x9b\",\"iflt\",\"判断是否 < 0\",\"几点说明：\",\"byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节\",\"goto 用来进行跳转到指定行号的字节码\",\"public class Demo3_3 { public static void main(String[] args) { int a = 0; if(a == 0) { a = 10; } else { a = 20; } } } 0: iconst_0 1: istore_1 2: iload_1 3: ifne 12 6: bipush 10 8: istore_1 9: goto 15 12: bipush 20 14: istore_1 15: return\",\"思考\",\"细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎么办？\",\"参考 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp\"]},\"195\":{\"h\":\"2.5 循环控制指令\",\"t\":[\"其实循环控制还是前面介绍的那些指令，例如 while 循环：\",\"public class Demo3_4 { public static void main(String[] args) { int a = 0; while (a < 10) { a++; } } } 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 14 8: iinc 1, 1 11: goto 2 14: return\",\"再比如 do while 循环：\",\"public class Demo3_5 { public static void main(String[] args) { int a = 0; do { a++; } while (a < 10); } } 字节码是： 0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return\",\"最后再看看 for 循环：\",\"public class Demo3_6 { public static void main(String[] args) { for (int i = 0; i < 10; i++) { } } } 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 14 8: iinc 1, 1 11: goto 2 14: return\",\"注意\",\"比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归😊\"]},\"196\":{\"h\":\"2.6 练习-判断结果\",\"t\":[\"public class Code_11_ByteCodeTest { public static void main(String[] args) { int i = 0; int x = 0; while (i < 10) { x = x++; i++; } System.out.println(x); // 0 } }\",\"img\",\"为什么最终的 x 结果为 0 呢？ 通过分析字节码指令即可知晓\",\"Code: stack=2, locals=3, args_size=1 // 操作数栈分配2个空间，局部变量表分配 3 个空间 0: iconst_0 // 准备一个常数 0 1: istore_1 // 将常数 0 放入局部变量表的 1 号槽位 i = 0 2: iconst_0 // 准备一个常数 0 3: istore_2 // 将常数 0 放入局部变量的 2 号槽位 x = 0 4: iload_1 // 将局部变量表 1 号槽位的数放入操作数栈中 5: bipush 10 // 将数字 10 放入操作数栈中，此时操作数栈中有 2 个数 7: if_icmpge 21 // 比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到 21 。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空 10: iload_2 // 将局部变量 2 号槽位的数放入操作数栈中，放入的值是 0 11: iinc 2, 1 // 将局部变量 2 号槽位的数加 1 ，自增后，槽位中的值为 1 14: istore_2 //将操作数栈中的数放入到局部变量表的 2 号槽位，2 号槽位的值又变为了0 15: iinc 1, 1 // 1 号槽位的值自增 1 18: goto 4 // 跳转到第4条指令 21: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 24: iload_2 25: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 28: return\"]},\"197\":{\"h\":\"2.7 构造方法\",\"t\":[\"cinit()V\",\"public class Code_12_CinitTest { static int i = 10; static { i = 20; } static { i = 30; } public static void main(String[] args) { System.out.println(i); // 30 } }\",\"编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()V ：\",\"stack=1, locals=0, args_size=0 0: bipush 10 2: putstatic #3 // Field i:I 5: bipush 20 7: putstatic #3 // Field i:I 10: bipush 30 12: putstatic #3 // Field i:I 15: return\",\"cinit()V 方法会在类加载的初始化阶段被调用\",\"init()V\",\"public class Main { private String a = \\\"s1\\\"; { b = 20; } private int b = 10; { a = \\\"s2\\\"; } public Main(String a, int b) { this.a = a; this.b = b; } public static void main(String[] args) { Main d = new Main(\\\"s3\\\", 30); System.out.println(d.a);//s3 System.out.println(d.b);//30 } }\",\"编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后\",\"Code: stack=2, locals=3, args_size=3 0: aload_0 1: invokespecial #1 // super.<init>()V 4: aload_0 5: ldc #2 // <- \\\"s1\\\" 7: putfield #3 // -> this.a 10: aload_0 11: bipush 20 // <- 20 13: putfield #4 // -> this.b 16: aload_0 17: bipush 10 // <- 10 19: putfield #4 // -> this.b 22: aload_0 23: ldc #5 // <- \\\"s2\\\" 25: putfield #3 // -> this.a 28: aload_0 // ------------------------------ 29: aload_1 // <- slot 1(a) \\\"s3\\\" | 30: putfield #3 // -> this.a | 33: aload_0 | 34: iload_2 // <- slot 2(b) 30 | 35: putfield #4 // -> this.b -------------------- 38: return\"]},\"198\":{\"h\":\"2.8 方法调用\",\"t\":[\"看一下几种不同的方法调用对应的字节码指令\",\"package main; public class Main { public Main() { } private void test1() { } private final void test2() { } public void test3() { } public static void test4() { } public static void main(String[] args) { Main m = new Main(); m.test1(); m.test2(); m.test3(); Main.test4(); } }\",\"不同方法在调用时，对应的虚拟机指令有所区别：\",\"私有、构造、被final修饰的方法，在调用时都使用invokespecial指令，属于静态绑定\",\"普通成员方法在调用时，使用invokevirtual指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定，属于动态绑定，即支持多态\",\"静态方法在调用时使用invokestatic指令\",\"对应的字节码文件：\",\" Code: stack=2, locals=2, args_size=1 0: new #2 // class main/Main 3: dup 4: invokespecial #3 // Method \\\"<init>\\\":()V 7: astore_1 8: aload_1 9: invokespecial #4 // Method test1:()V 12: aload_1 13: invokespecial #5 // Method test2:()V 16: aload_1 17: invokevirtual #6 // Method test3:()V 20: invokestatic #7 // Method test4:()V 23: return\",\"new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈\",\"dup 是复制操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 \\\"<init>\\\":()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量\",\"终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定\",\"普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态，成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】\",\"比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了😂\",\"还有一个执行 invokespecial 的情况是通过 super 调用父类方法\"]},\"199\":{\"h\":\"2.9 多态的原理\",\"t\":[\"因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令\",\"在执行invokevirtual指令时，经历了以下几个步骤\",\"先通过栈帧中对象的引用找到对象\",\"分析对象头，找到对象实际的Class\",\"Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了\",\"查询vtable找到方法的具体地址\",\"执行方法的字节码\",\"package cn.itcast.jvm.t3.bytecode; import java.io.IOException; /** * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩 * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */ public class Demo3_10 { public static void test(Animal animal) { animal.eat(); System.out.println(animal.toString()); } public static void main(String[] args) throws IOException { test(new Cat()); test(new Dog()); System.in.read(); } } abstract class Animal { public abstract void eat(); @Override public String toString() { return \\\"我是\\\" + this.getClass().getSimpleName(); } } class Dog extends Animal { @Override public void eat() { System.out.println(\\\"啃骨头\\\"); } } class Cat extends Animal { @Override public void eat() { System.out.println(\\\"吃鱼\\\"); } }\"]},\"200\":{\"h\":\"1）运行代码\",\"t\":[\"停在 System.in.read() 方法上，这时运行 jps 获取进程 id\"]},\"201\":{\"h\":\"2）运行 HSDB 工具\",\"t\":[\"进入 JDK 安装目录，执行\",\"java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB\",\"进入图形界面 attach 进程 id\"]},\"202\":{\"h\":\"3）查找某个对象\",\"t\":[\"打开 Tools -> Find Object By Query\",\"输入\",\"select d from cn.itcast.jvm.t3.bytecode.Dog d\",\"点击 Execute 执行\",\"img\"]},\"203\":{\"h\":\"4）查看对象内存结构\",\"t\":[\"点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是\",\"MarkWord，后 8 字节就是对象的 Class 指针\",\"但目前看不到它的实际地址\",\"img\"]},\"204\":{\"h\":\"5）查看对象 Class 的内存地址\",\"t\":[\"可以通过 Windows -> Console 进入命令行模式，执行\",\"mem 0x00000001299b4978 2\",\"mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）\",\"结果中第二行 0x000000001b7d4028 即为 Class 的内存地址\",\"img\"]},\"205\":{\"h\":\"6）查看类的 vtable\",\"t\":[\"方法1：Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面\",\"img\",\"方法2：或者 Tools -> Class Browser 输入 Dog 查找，可以得到相同的结果\",\"img\",\"无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态相关的，final，static 不会列入）\",\"那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到：\",\"0x000000001b7d4028 1b8 + --------------------- 0x000000001b7d41e0\",\"通过 Windows -> Console 进入命令行模式，执行\",\"mem 0x000000001b7d41e0 6 0x000000001b7d41e0: 0x000000001b3d1b10 0x000000001b7d41e8: 0x000000001b3d15e8 0x000000001b7d41f0: 0x000000001b7d35e8 0x000000001b7d41f8: 0x000000001b3d1540 0x000000001b7d4200: 0x000000001b3d1678 0x000000001b7d4208: 0x000000001b7d3fa8\",\"就得到了 6 个虚方法的入口地址\"]},\"206\":{\"h\":\"7）验证方法地址\",\"t\":[\"通过 Tools -> Class Browser 查看每个类的方法定义，比较可知\",\"img\",\"Dog - public void eat() @0x000000001b7d3fa8 Animal - public java.lang.String toString() @0x000000001b7d35e8; Object - protected void finalize() @0x000000001b3d1b10; Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8; Object - public native int hashCode() @0x000000001b3d1540; Object - protected native java.lang.Object clone() @0x000000001b3d1678;\",\"对号入座，发现\",\"eat() 方法是 Dog 类自己的\",\"toString() 方法是继承 String 类的\",\"finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的\"]},\"207\":{\"h\":\"8）小结\",\"t\":[\"当执行 invokevirtual 指令时，\",\"先通过栈帧中的对象引用找到对象\",\"分析对象头，找到对象的实际 Class\",\"Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了\",\"查表得到方法的具体地址\",\"执行方法的字节码\"]},\"208\":{\"h\":\"2.10 异常处理\"},\"209\":{\"h\":\"（1）try-catch\",\"t\":[\"public class Main { public static void main(String[] args) { int i = 0; try { i = 10; } catch (Exception e) { i = 20; } } }\",\"对应的字节码文件（为了抓住重点，下面的字节码省略了不重要的部分）：\",\" Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 12 8: astore_2 9: bipush 20 11: istore_1 12: return Exception table: from to target type 2 5 8 Class java/lang/Exception\",\"可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号\",\"8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）\"]},\"210\":{\"h\":\"（2）多个 single-catch 块的情况\",\"t\":[\"public class Demo3_11_2 { public static void main(String[] args) { int i = 0; try { i = 10; } catch (ArithmeticException e) { i = 30; } catch (NullPointerException e) { i = 40; } catch (Exception e) { i = 50; } } }\",\"对应的字节码文件：\",\"public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 26 8: astore_2 9: bipush 30 11: istore_1 12: goto 26 15: astore_2 16: bipush 40 18: istore_1 19: goto 26 22: astore_2 23: bipush 50 25: istore_1 26: return Exception table: from to target type 2 5 8 Class java/lang/ArithmeticException 2 5 15 Class java/lang/NullPointerException 2 5 22 Class java/lang/Exception LineNumberTable: ... LocalVariableTable: Start Length Slot Name Signature 9 3 2 e Ljava/lang/ArithmeticException; 16 3 2 e Ljava/lang/NullPointerException; 23 3 2 e Ljava/lang/Exception; 0 27 0 args [Ljava/lang/String; 2 25 1 i I StackMapTable: ... MethodParameters: ...\",\"因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用\"]},\"211\":{\"h\":\"（3）multi-catch 的情况\",\"t\":[\"public class Demo3_11_3 { public static void main(String[] args) { try { Method test = Demo3_11_3.class.getMethod(\\\"test\\\"); test.invoke(null); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } public static void test() { System.out.println(\\\"ok\\\"); } } public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: ldc #2 2: ldc #3 4: iconst_0 5: anewarray #4 8: invokevirtual #5 11: astore_1 12: aload_1 13: aconst_null 14: iconst_0 15: anewarray #6 18: invokevirtual #7 21: pop 22: goto 30 25: astore_1 26: aload_1 27: invokevirtual #11 // e.printStackTrace:()V 30: return Exception table: from to target type 0 22 25 Class java/lang/NoSuchMethodException 0 22 25 Class java/lang/IllegalAccessException 0 22 25 Class java/lang/reflect/InvocationTargetException LineNumberTable: ... LocalVariableTable: Start Length Slot Name Signature 12 10 1 test Ljava/lang/reflect/Method; 26 4 1 e Ljava/lang/ReflectiveOperationException; 0 31 0 args [Ljava/lang/String; StackMapTable: ... MethodParameters: ...\"]},\"212\":{\"h\":\"（4）finally\",\"t\":[\"public class Main { public static void main(String[] args) { int i = 0; try { i = 10; } catch (Exception e) { i = 20; } finally { i = 30; } } }\",\"对应的字节码文件：\",\" Code: stack=1, locals=4, args_size=1 0: iconst_0 1: istore_1 //try块 2: bipush 10 4: istore_1 5: bipush 30 //try块执行完后，会执行finally 7: istore_1 8: goto 27 //catch块 11: astore_2 12: bipush 20 14: istore_1 //catch块执行完，会执行finally 15: bipush 30 17: istore_1 18: goto 27 //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码 21: astore_3 22: bipush 30 24: istore_1 25: aload_3 26: athrow //抛出异常 27: return Exception table: from to target type 2 5 11 Class java/lang/Exception 2 5 21 any //剩余的异常类型，比如 Error 11 15 21 any //剩余的异常类型，比如 Erro\",\"可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程\",\"注意：\",\"虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次\"]},\"213\":{\"h\":\"（5）finally中的return\",\"t\":[\"public class Main { public static void main(String[] args) { int result = test(); System.out.println(result);//20 } public static int test() { try { return 10; } finally { return 20; } } }\",\"对应的字节码文件：\",\"Code: stack=1, locals=3, args_size=0 0: bipush 10 2: istore_0 3: iload_0 4: istore_1 // 暂存返回值 5: bipush 20 7: istore_0 8: iload_0 9: ireturn // ireturn 会返回操作数栈顶的整型值 20 // 如果出现异常，还是会执行finally 块中的内容，没有抛出异常 10: astore_2 11: bipush 20 13: istore_0 14: iload_0 15: ireturn // 这里没有 athrow 了，也就是如果在 finally 块中如果有返回操作的话，且 try 块中出现异常，会吞掉异常！ Exception table: from to target type 0 5 10 any\",\"由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准\",\"跟前一个中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常\",\"所以不要在finally中进行返回操作\",\"运行下面的代码，不会抛出异常：\",\"public class Main { public static void main(String[] args) { int result = test(); System.out.println(result); } public static int test() { try { int i = 1 / 0; return 10; } finally { return 20; } } }\"]},\"214\":{\"h\":\"（6）finally不带return\",\"t\":[\"public class Main { public static void main(String[] args) { int i = Main.test(); System.out.println(i);//输出为10 } public static int test() { int i = 10; try { return i; } finally { i = 20; } } }\",\"对应的字节码文件：\",\"Code: stack=1, locals=3, args_size=0 0: bipush 10 2: istore_0 //赋值给i 10 3: iload_0 //加载到操作数栈顶 4: istore_1 //加载到局部变量表的1号位置 5: bipush 20 7: istore_0 //赋值给i 20 8: iload_1 //加载局部变量表1号位置的数10到操作数栈 9: ireturn //返回操作数栈顶元素 10 10: astore_2 11: bipush 20 13: istore_0 14: aload_2 //加载异常 15: athrow //抛出异常 Exception table: from to target type 3 5 10 any\"]},\"215\":{\"h\":\"2.11 synchronized\",\"t\":[\"public class Code_19_SyncTest { public static void main(String[] args) { Object lock = new Object(); synchronized (lock) { System.out.println(\\\"ok\\\"); } } } Code: stack=2, locals=4, args_size=1 0: new #2 // class java/lang/Object 3: dup // 复制一份栈顶，然后压入栈中。用于函数消耗 4: invokespecial #1 // Method java/lang/Object.\\\"<init>\\\":()V 7: astore_1 // 将栈顶的对象地址方法 局部变量表中 1 中 8: aload_1 // 加载到操作数栈 9: dup // 复制一份，放到操作数栈，用于加锁时消耗 10: astore_2 // 将操作数栈顶元素弹出，暂存到局部变量表的 2 号槽位。这时操作数栈中有一份对象的引用 11: monitorenter // 加锁 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: ldc #4 // String ok 17: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_2 // 加载对象到栈顶 21: monitorexit // 释放锁 22: goto 30 // 异常情况的解决方案 释放锁！ 25: astore_3 26: aload_2 27: monitorexit 28: aload_3 29: athrow 30: return // 异常表！ Exception table: from to target type 12 22 25 any 25 28 25 any\"]},\"216\":{\"h\":\"3. 编译器处理\",\"t\":[\"所谓的 语法糖 ，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利 注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。\"]},\"217\":{\"h\":\"3.1 默认构造器\",\"t\":[\"public class Candy1 {}\",\"编译成class后的代码：\",\"public class Candy1 { // 这个无参构造器是java编译器帮我们加上的 public Candy1() { // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.\\\" <init>\\\":()V super(); } }\"]},\"218\":{\"h\":\"3.2 自动拆装箱\",\"t\":[\"基本类型和其包装类型的相互转换过程，称为拆装箱 在 JDK 5 以后，它们的转换可以在编译期自动完成\",\"这个特性是 JDK 5 开始加入的， 如下代码 ：\",\"public class Candy2 { public static void main(String[] args) { Integer x = 1; int y = x; } }\",\"这段代码在 JDK 5 之前是无法编译通过的，必须改写下面这样 :\",\"public class Candy2 { public static void main(String[] args) { //基本类型转包装类型→装箱 Integer x = Integer.valueOf(1); //包装类型转基本类型→拆箱 int y = x.intValue(); } }\",\"转换过程如下\",\"public class Candy2 { public static void main(String[] args) { // 基本类型赋值给包装类型，称为装箱 Integer x = Integer.valueOf(1); // 包装类型赋值给基本类型，称谓拆箱 int y = x.intValue(); } }\"]},\"219\":{\"h\":\"3.3 泛型集合取值\",\"t\":[\"泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了（实际上有一些类信息没被擦除，为了反射使用），实际的类型都当做了 Object 类型来处理：\",\"public class Candy3 { public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(10); // 实际调用的是 List.add(Object e) Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index); } }\",\"所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：\",\"// 需要将 Object 转为 Integer Integer x = (Integer)list.get(0);\",\"如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：\",\"// 需要将 Object 转为 Integer, 并执行拆箱操作 int x = ((Integer)list.get(0)).intValue();\",\"对应字节码：\",\"Code: stack=2, locals=3, args_size=1 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.\\\"<init>\\\":()V 7: astore_1 8: aload_1 9: bipush 10 11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; //这里进行了泛型擦除，实际调用的是add(Objcet o) 14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 19: pop 20: aload_1 21: iconst_0 //这里也进行了泛型擦除，实际调用的是get(Object o) 22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; //这里进行了类型转换，将Object转换成了Integer 27: checkcast #7 // class java/lang/Integer 30: astore_2 31: return\",\"所以调用 get 函数取值时，有一个类型转换的操作。\",\"Integer x = (Integer) list.get(0);\",\"如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作\",\"int x = (Integer) list.get(0).intValue();\"]},\"220\":{\"h\":\"3.4反射获取泛型信息\",\"t\":[\"擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息\",\"public cn.itcast.jvm.t3.candy.Candy3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\\\" <init>\\\":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/itcast/jvm/t3/candy/Candy3; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.\\\" <init>\\\":()V 7: astore_1 8: aload_1 9: bipush 10 11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 19: pop 20: aload_1 21: iconst_0 22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; 27: checkcast #7 // class java/lang/Integer 30: astore_2 31: return LineNumberTable: line 8: 0 line 9: 8 line 10: 20 line 11: 31 LocalVariableTable: Start Length Slot Name Signature 0 32 0 args [Ljava/lang/String; 8 24 1 list Ljava/util/List; LocalVariableTypeTable: Start Length Slot Name Signature 8 24 1 list Ljava/util/List<Ljava/lang/Integer;>;\",\"使用反射可以得到，参数的类型以及泛型类型。泛型反射代码如下：\",\" public static void main(String[] args) throws NoSuchMethodException { // 1. 拿到方法 Method method = Code_20_ReflectTest.class.getMethod(\\\"test\\\", List.class, Map.class); // 2. 得到泛型参数的类型信息 Type[] types = method.getGenericParameterTypes(); for(Type type : types) { // 3. 判断参数类型是否，带泛型的类型。 if(type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; // 4. 得到原始类型 System.out.println(\\\"原始类型 - \\\" + parameterizedType.getRawType()); // 5. 拿到泛型类型 Type[] arguments = parameterizedType.getActualTypeArguments(); for(int i = 0; i < arguments.length; i++) { System.out.printf(\\\"泛型参数[%d] - %s\\\\n\\\", i, arguments[i]); } } } } public Set<Integer> test(List<String> list, Map<Integer, Object> map) { return null; } 原始类型 - interface java.util.List 泛型参数[0] - class java.lang.String 原始类型 - interface java.util.Map 泛型参数[0] - class java.lang.Integer 泛型参数[1] - class java.lang.Object\"]},\"221\":{\"h\":\"3.5 可变参数\",\"t\":[\"可变参数也是 JDK 5 开始加入的新特性： 例如：\",\"public class Candy4 { public static void foo(String... args) { // 将 args 赋值给 arr ，可以看出 String... 实际就是 String[] String[] arr = args; System.out.println(arr.length); } public static void main(String[] args) { foo(\\\"hello\\\", \\\"world\\\"); } }\",\"可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：\",\"public class Candy4 { public Candy4 {} public static void foo(String[] args) { String[] arr = args; System.out.println(arr.length); } public static void main(String[] args) { foo(new String[]); } }\",\"注意，如果调用的是 foo() ，即未传递参数时，等价代码为 foo(new String[]{}) ，创建了一个空数组，而不是直接传递的 null .\"]},\"222\":{\"h\":\"3.6 foreach 循环\",\"t\":[\"仍是 JDK 5 开始引入的语法糖，数组的循环：\",\"public class Candy5_1 { public static void main(String[] args) { int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖哦 for (int e : array) { System.out.println(e); } } }\",\"编译器会帮我们转换为\",\"public class Candy5_1 { public Candy5_1() { } public static void main(String[] args) { int[] array = new int[]{1, 2, 3, 4, 5}; for(int i = 0; i < array.length; ++i) { int e = array[i]; System.out.println(e); } } }\",\"如果是集合使用 foreach\",\"public class Candy5_2 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1,2,3,4,5); for (Integer i : list) { System.out.println(i); } } }\",\"集合要使用 foreach ，需要该集合类实现了 Iterable 接口，因为集合的遍历需要用到迭代器 Iterator.\",\"public class Candy5 { public Candy5(){} public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5); // 获得该集合的迭代器 Iterator<Integer> iterator = list.iterator(); while(iterator.hasNext()) { Integer x = iterator.next(); System.out.println(x); } } }\",\"注意 ：foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其 中 Iterable 用来获取集合的迭代器（ Iterator ）\"]},\"223\":{\"h\":\"3.7 switch 字符串\",\"t\":[\"从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：\",\"public class Cnady6 { public static void main(String[] args) { String str = \\\"hello\\\"; switch (str) { case \\\"hello\\\" : System.out.println(\\\"h\\\"); break; case \\\"world\\\" : System.out.println(\\\"w\\\"); break; default: break; } } }\",\"注意： switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚\",\"会被编译器转换为：\",\"public class Candy6 { public Candy6() { } public static void main(String[] args) { String str = \\\"hello\\\"; int x = -1; // 通过字符串的 hashCode + value 来判断是否匹配 switch (str.hashCode()) { // hello 的 hashCode case 99162322 : // 再次比较，因为字符串的 hashCode 有可能相等 if(str.equals(\\\"hello\\\")) { x = 0; } break; // world 的 hashCode case 11331880 : if(str.equals(\\\"world\\\")) { x = 1; } break; default: break; } // 用第二个 switch 在进行输出判断 switch (x) { case 0: System.out.println(\\\"h\\\"); break; case 1: System.out.println(\\\"w\\\"); break; default: break; } } }\",\"过程说明：\",\"在编译期间，单个的 switch 被分为了两个 \",\"第一个用来匹配字符串，并给 x 赋值 \",\"字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法\",\"使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 冲突（如 BM 和 C .）\",\"第二个用来根据x的值来决定输出语句\",\"以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。\",\"问：为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突。\",\"例如 BM 和 C. 这两个字符串的hashCode值都是 2123 ，如果有如下代码：\",\"public class Candy6_1 { public static void choose(String str) { switch (str) { case \\\"BM\\\": { System.out.println(\\\"h\\\"); break; } case \\\"C.\\\": { System.out.println(\\\"w\\\"); break; } } } }\",\"会被编译器转换为：\",\"public class Candy6_1 { public Candy6_1() { } public static void choose(String var0) { byte var2 = -1; switch(var0.hashCode()) { case 2123: if (var0.equals(\\\"C.\\\")) { var2 = 1; } else if (var0.equals(\\\"BM\\\")) { var2 = 0; } default: switch(var2) { case 0: System.out.println(\\\"h\\\"); break; case 1: System.out.println(\\\"w\\\"); } } } }\"]},\"224\":{\"h\":\"3.8 switch 枚举\",\"t\":[\"enum SEX { MALE, FEMALE; } public class Candy7 { public static void main(String[] args) { SEX sex = SEX.MALE; switch (sex) { case MALE: System.out.println(\\\"man\\\"); break; case FEMALE: System.out.println(\\\"woman\\\"); break; default: break; } } } enum SEX { MALE, FEMALE; } public class Candy7 { /** * 定义一个合成类（仅 jvm 使用，对我们不可见） * 用来映射枚举的 ordinal 与数组元素的关系 * 枚举的 ordinal 表示枚举对象的序号，从 0 开始 * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 */ static class $MAP { // 数组大小即为枚举元素个数，里面存放了 case 用于比较的数字 static int[] map = new int[2]; static { // ordinal 即枚举元素对应所在的位置，MALE 为 0 ，FEMALE 为 1 map[SEX.MALE.ordinal()] = 1; map[SEX.FEMALE.ordinal()] = 2; } } public static void main(String[] args) { SEX sex = SEX.MALE; // 将对应位置枚举元素的值赋给 x ，用于 case 操作 int x = $MAP.map[sex.ordinal()]; switch (x) { case 1: System.out.println(\\\"man\\\"); break; case 2: System.out.println(\\\"woman\\\"); break; default: break; } } }\"]},\"225\":{\"h\":\"3.9 枚举类\",\"t\":[\"JDK 7 新增了枚举类，以前面的性别枚举为例：\",\"public enum Sex { MALE,FEMALE }\",\"转换后的代码\",\"public final class Sex extends Enum<Sex> { // 对应枚举类中的元素 public static final Sex MALE; public static final Sex FEMALE; private static final Sex[] $VALUES; static { // 调用构造函数，传入枚举元素的值及 ordinal MALE = new Sex(\\\"MALE\\\", 0); FEMALE = new Sex(\\\"FEMALE\\\", 1); $VALUES = new Sex[]{MALE, FEMALE}; } // 调用父类中的方法 private Sex(String name, int ordinal) { super(name, ordinal); } public static Sex[] values() { return $VALUES.clone(); } public static Sex valueOf(String name) { return Enum.valueOf(Sex.class, name); } }\"]},\"226\":{\"h\":\"3.10 try-with-resources\",\"t\":[\"JDK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’\",\"try(资源变量 = 创建资源对象) { } catch() { }\",\"其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with- resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：\",\"public class Candy9 { public static void main(String[] args) { try(InputStream is = new FileInputStream(\\\"d:\\\\\\\\1.txt\\\")){ System.out.println(is); } catch (IOException e) { e.printStackTrace(); } } }\",\"会被转换为：\",\"public class Candy9 { public Candy9() { } public static void main(String[] args) { try { InputStream is = new FileInputStream(\\\"d:\\\\\\\\1.txt\\\"); Throwable t = null; try { System.out.println(is); } catch (Throwable e1) { // t 是我们代码出现的异常 t = e1; throw e1; } finally { // 判断了资源不为空 if (is != null) { // 如果我们代码有异常 if (t != null) { try { is.close(); } catch (Throwable e2) { // 如果 close 出现异常，作为被压制异常添加 t.addSuppressed(e2); } } else { // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e is.close(); } } } } catch (IOException e) { e.printStackTrace(); } } }\",\"为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：\",\"public class Test6 { public static void main(String[] args) { try (MyResource resource = new MyResource()) { int i = 1/0; } catch (Exception e) { e.printStackTrace(); } } } class MyResource implements AutoCloseable { public void close() throws Exception { throw new Exception(\\\"close 异常\\\"); } }\",\"输出：\",\"java.lang.ArithmeticException: / by zero at test.Test6.main(Test6.java:7) Suppressed: java.lang.Exception: close 异常 at test.MyResource.close(Test6.java:18) at test.Test6.main(Test6.java:6)\"]},\"227\":{\"h\":\"3.11 方法重写时的桥接方法\",\"t\":[\"我们都知道，方法重写时对返回值分两种情况： 父子类的返回值完全一致 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）\",\"class A { public Number m() { return 1; } } class B extends A { @Override // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 public Integer m() { return 2; } }\",\"对于子类，java 编译器会做如下处理：\",\"class B extends A { public Integer m() { return 2; } // 此方法才是真正重写了父类 public Number m() 方法 public synthetic bridge Number m() { // 调用 public Integer m() return m(); } }\",\"其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以 用下面反射代码来验证：\",\"public static void main(String[] args) { for(Method m : B.class.getDeclaredMethods()) { System.out.println(m); } }\",\"结果：\",\"public java.lang.Integer cn.ali.jvm.test.B.m() public java.lang.Number cn.ali.jvm.test.B.m()\"]},\"228\":{\"h\":\"3.12 匿名内部类\",\"t\":[\"public class Candy10 { public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\\\"running...\\\"); } }; } }\",\"转换后的代码\",\"public class Candy10 { public static void main(String[] args) { // 用额外创建的类来创建匿名内部类对象 Runnable runnable = new Candy10$1(); } } // 创建了一个额外的类，实现了 Runnable 接口 final class Candy10$1 implements Runnable { public Demo8$1() {} @Override public void run() { System.out.println(\\\"running...\\\"); } }\",\"引用局部变量的匿名内部类，源代码：\",\"public class Candy11 { public static void test(final int x) { Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\\\"ok:\\\" + x); } }; } }\",\"转换后代码：\",\"// 额外生成的类 final class Candy11$1 implements Runnable { int val$x; Candy11$1(int x) { this.val$x = x; } public void run() { System.out.println(\\\"ok:\\\" + this.val$x); } } public class Candy11 { public static void test(final int x) { Runnable runnable = new Candy11$1(x); } }\",\"注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。\",\"这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是final的：因为在创建Candy11$1对象时，将x的值赋值给了Candy11$1对象的vala属性，所以x不应该再发生变化了，如果变化，那么ualx属性没有机会再跟着一起变化\"]},\"229\":{\"h\":\"4. 类加载阶段\"},\"230\":{\"h\":\"4.1 加载\",\"t\":[\"将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有： \",\"_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用\",\"_super 即父类\",\"_ﬁelds 即成员变量\",\"_methods 即方法\",\"_constants 即常量池\",\"_class_loader 即类加载器\",\"_vtable 虚方法表\",\"_itable 接口方法\",\"如果这个类还有父类没有加载，先加载父类\",\"加载和链接可能是交替运行的\",\"instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中，可以通过HSDB工具查看。\",\"instanceKlass和_java_mirror（java镜像类）互相保存了对方的地址\",\"类的对象在对象头中保存了 *.class 的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息\",\"img\",\"注意\",\"instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中\",\"可以通过前面介绍的 HSDB 工具查看\"]},\"231\":{\"h\":\"4.2 链接\"},\"232\":{\"h\":\"（1）验证\",\"t\":[\"验证类是否符合 JVM规范，安全性检查 用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行\"]},\"233\":{\"h\":\"（2）准备\",\"t\":[\"为 static 变量分配空间，设置默认值\",\"static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了\",\"static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成\",\"如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成\",\"如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成\",\"public class Code_22_AnalysisTest { public static void main(String[] args) throws ClassNotFoundException, IOException { ClassLoader classLoader = Code_22_AnalysisTest.class.getClassLoader(); Class<?> c = classLoader.loadClass(\\\"cn.ali.jvm.test.C\\\"); // new C(); System.in.read(); } } class C { D d = new D(); } class D { }\"]},\"234\":{\"h\":\"（3）解析\",\"t\":[\"将常量池中的符号引用解析为直接引用\",\"package cn.itcast.jvm.t3.load; /** * 解析的含义 */ public class Load2 { public static void main(String[] args) throws ClassNotFoundException, IOException { ClassLoader classloader = Load2.class.getClassLoader(); // loadClass 方法不会导致类的解析和初始化 Class<?> c = classloader.loadClass(\\\"cn.itcast.jvm.t3.load.C\\\"); // new C(); System.in.read(); } } class C { D d = new D(); } class D { }\"]},\"235\":{\"h\":\"4-3 初始化\"},\"236\":{\"h\":\"（1）<cinit>()v 方法\",\"t\":[\"初始化即调用 \\\\<cinit>()V，虚拟机会保证这个类的【构造方法】的线程安全\"]},\"237\":{\"h\":\"（2）发生的时机\",\"t\":[\"类的初始化的懒惰的，以下情况会初始化：\",\"main 方法所在的类，总会被首先初始化\",\"首次访问这个类的静态变量或静态方法时\",\"子类初始化，如果父类还没初始化，会引发\",\"子类访问父类的静态变量，只会触发父类的初始化\",\"Class.forName\",\"new 会导致初始化\",\"以下情况不会初始化：\",\"访问类的 static ﬁnal 静态常量（基本类型和字符串）\",\"类对象.class 不会触发初始化\",\"创建该类对象的数组\",\"类加载器的.loadClass方法\",\"Class.forName的参数2为false时\",\"验证类是否被初始化，可以看改类的静态代码块是否被执行\",\"这里一个例子来验证：（实验时请先全部注释，每次只执行其中一个）\",\"public class Load3 { static { System.out.println(\\\"main init\\\"); } public static void main(String[] args) throws ClassNotFoundException { // 1. 静态常量（基本类型和字符串）不会触发初始化 System.out.println(B.b); // 2. 类对象.class 不会触发初始化 System.out.println(B.class); // 3. 创建该类的数组不会触发初始化 System.out.println(new B[0]); // 4. 不会初始化类 B，但会加载 B、A ClassLoader cl = Thread.currentThread().getContextClassLoader(); cl.loadClass(\\\"cn.itcast.jvm.t3.B\\\"); // 5. 不会初始化类 B，但会加载 B、A ClassLoader c2 = Thread.currentThread().getContextClassLoader(); Class.forName(\\\"cn.itcast.jvm.t3.B\\\", false, c2); // 1. 首次访问这个类的静态变量或静态方法时 System.out.println(A.a); // 2. 子类初始化，如果父类还没初始化，会引发 System.out.println(B.c); // 3. 子类访问父类静态变量，只触发父类初始化 System.out.println(B.a); // 4. 会初始化类 B，并先初始化类 A Class.forName(\\\"cn.itcast.jvm.t3.B\\\"); } } class A { static int a = 0; static { System.out.println(\\\"a init\\\"); } } class B extends A { final static double b = 5.0; static boolean c = false; static { System.out.println(\\\"b init\\\"); } }\"]},\"238\":{\"h\":\"4）练习\",\"t\":[\"从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化\",\"public class Load2 { public static void main(String[] args) { System.out.println(E.a); System.out.println(E.b); // 会导致 E 类初始化，因为 Integer 是包装类 System.out.println(E.c); } } class E { public static final int a = 10; public static final String b = \\\"hello\\\"; public static final Integer c = 20; static { System.out.println(\\\"E cinit\\\"); } }\",\"典型应用 - 完成懒惰初始化单例模式\",\"public class Singleton { private Singleton() { } // 内部类中保存单例 private static class LazyHolder { static final Singleton INSTANCE = new Singleton(); } // 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 public static Singleton getInstance() { return LazyHolder.INSTANCE; } }\",\"以上的实现特点是：\",\"懒惰实例化\",\"初始化时的线程安全是有保障的\"]},\"239\":{\"h\":\"5.类加载器\",\"t\":[\"类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等！\",\"以 JDK 8 为例：\",\"名称加载的类说明\",\"名称\",\"加载的类\",\"说明\",\"Bootstrap ClassLoader（启动类加载器）\",\"JAVA_HOME/jre/lib\",\"无法直接访问\",\"Extension ClassLoader(拓展类加载器)\",\"JAVA_HOME/jre/lib/ext\",\"上级为Bootstrap，显示为null\",\"Application ClassLoader(应用程序类加载器)\",\"classpath\",\"上级为Extension\",\"自定义类加载器\",\"自定义\",\"上级为Application\"]},\"240\":{\"h\":\"5.1 启动类的加载器\",\"t\":[\"可通过在控制台输入指令，使得类被启动类加器加载\",\"用 Bootstrap 类加载器加载类：\",\"package cn.itcast.jvm.t3.load; public class F { static { System.out.println(\\\"bootstrap F init\\\"); } } package cn.itcast.jvm.t3.load; public class Load5_1 { public static void main(String[] args) throws ClassNotFoundException { Class<?> aClass = Class.forName(\\\"cn.itcast.jvm.t3.load.F\\\"); System.out.println(aClass.getClassLoader()); } } E:\\\\git\\\\jvm\\\\out\\\\production\\\\jvm>java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5 bootstrap F init null\",\"-Xbootclasspath 表示设置 bootclasspath\",\"其中 /a:. 表示将当前目录追加至 bootclasspath 之后\",\"可以用这个办法替换核心类 \",\"java -Xbootclasspath:<new bootclasspath>\",\"也可以追加 \",\"java -Xbootclasspath/a:<追加路径>（后追加）\",\"java -Xbootclasspath/p:<追加路径>（前追加）\"]},\"241\":{\"h\":\"5.2 扩展类的加载器\",\"t\":[\"如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。\",\"package cn.itcast.jvm.t3.load; public class G { static { System.out.println(\\\"classpath G init\\\"); } } classpath G init sun.misc.Launcher$AppClassLoader@18b4aac2 package cn.itcast.jvm.t3.load; public class G { static { System.out.println(\\\"ext G init\\\"); } } E:\\\\git\\\\jvm\\\\out\\\\production\\\\jvm>jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单 正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%)\",\"将 jar 包拷贝到 JAVA_HOME/jre/lib/ext\",\"重新执行 Load5_2\",\"输出\",\"ext G init sun.misc.Launcher$ExtClassLoader@29453f44\"]},\"242\":{\"h\":\"5.3 双亲委派模式\",\"t\":[\"当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。\",\"当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。\",\"如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；\",\"若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。\",\"所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则\",\"loadClass源码\",\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先查找该类是否已经被该类加载器加载过了 Class<?> c = findLoadedClass(name); // 如果没有被加载过 if (c == null) { long t0 = System.nanoTime(); try { // 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp，但它显示为null if (parent != null) { c = parent.loadClass(name, false); } else { // 看是否被启动类加载器加载过 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader //捕获异常，但不做任何处理 } if (c == null) { // 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常 // 然后让应用类加载器去找 classpath 下找该类 long t1 = System.nanoTime(); c = findClass(name); // 记录时间 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } }\"]},\"243\":{\"h\":\"5.4 自定义类加载器\",\"t\":[\"使用场景\",\"想加载非 classpath 随意路径中的类文件\",\"通过接口来使用实现，希望解耦时，常用在框架设计\",\"这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器\",\"步骤\",\"继承 ClassLoader 父类\",\"要遵从双亲委派机制，重写 ﬁndClass 方法 不是重写 loadClass 方法，否则不会走双亲委派机制\",\"读取类文件的字节码\",\"调用父类的 deﬁneClass 方法来加载类\",\"使用者调用该类加载器的 loadClass 方法\",\"破坏双亲委派模式\",\"双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代 \",\"建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法\",\"双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的 \",\"如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式\",\"双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的 \",\"这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等\"]},\"244\":{\"h\":\"5.5 线程上下文类加载器\"},\"245\":{\"h\":\"背景\",\"t\":[\"我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写\",\"Class.forName(\\\"com.mysql.jdbc.Driver\\\")\",\"也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？ 让我们追踪一下源码：\",\"public class DriverManager { // 注册驱动的集合 private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>(); // 初始化驱动 static { loadInitialDrivers(); println(\\\"JDBC DriverManager initialized\\\"); }\",\"先不看别的，看看 DriverManager 的类加载器：\",\"System.out.println(DriverManager.class.getClassLoader());\",\"打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？\"]},\"246\":{\"h\":\"SPI 服务提供接口\",\"t\":[\"继续看 loadInitialDrivers() 方法：\",\"private static void loadInitialDrivers() { String drivers; try { drivers = AccessController.doPrivileged(new PrivilegedAction<String> () { public String run() { return System.getProperty(\\\"jdbc.drivers\\\"); } }); } catch (Exception ex) { drivers = null; } // 1）使用 ServiceLoader 机制加载驱动，即 SPI AccessController.doPrivileged(new PrivilegedAction<Void>() { public Void run() { ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); Iterator<Driver> driversIterator = loadedDrivers.iterator(); try{ while(driversIterator.hasNext()) { driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; } }); println(\\\"DriverManager.initialize: jdbc.drivers = \\\" + drivers); // 2）使用 jdbc.drivers 定义的驱动名加载驱动 if (drivers == null || drivers.equals(\\\"\\\")) { return; } String[] driversList = drivers.split(\\\":\\\"); println(\\\"number of Drivers:\\\" + driversList.length); for (String aDriver : driversList) { try { println(\\\"DriverManager.Initialize: loading \\\" + aDriver); // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(\\\"DriverManager.Initialize: load failed: \\\" + ex); } } }\",\"先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载 再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI） 约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称\",\"image-20240715200831758\"]},\"247\":{\"h\":\"使用\",\"t\":[\"这样就可以使用\",\"ServiceLoader<接口类型> allImpls = ServiceLoader.load(接口类型.class); Iterator<接口类型> iter = allImpls.iterator(); while(iter.hasNext()) { iter.next(); }\",\"来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：\",\"JDBC\",\"Servlet 初始化器\",\"Spring 容器\",\"Dubbo（对 SPI 进行了扩展）\"]},\"248\":{\"h\":\"原理\",\"t\":[\"接着看 ServiceLoader.load 方法:\",\"public static <S> ServiceLoader<S> load(Class<S> service) { // 获取线程上下文类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); }\",\"线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中：\",\"private S nextService() { if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class<?> c = null; try { c = Class.forName(cn, false, loader); } catch (ClassNotFoundException x) { fail(service, \\\"Provider \\\" + cn + \\\" not found\\\"); } if (!service.isAssignableFrom(c)) { fail(service, \\\"Provider \\\" + cn + \\\" not a subtype\\\"); } try { S p = service.cast(c.newInstance()); providers.put(cn, p); return p; } catch (Throwable x) { fail(service, \\\"Provider \\\" + cn + \\\" could not be instantiated\\\", x); } throw new Error(); // This cannot happen }\"]},\"249\":{\"h\":\"6、运行期优化\"},\"250\":{\"h\":\"6.1 即时编译\"},\"251\":{\"h\":\"（1）分层编译\",\"t\":[\"JVM 将执行状态分成了 5 个层次：\",\"0层：解释执行，用解释器将字节码翻译为机器码\",\"1层：使用 C1 即时编译器编译执行（不带 proﬁling）\",\"2层：使用 C1 即时编译器编译执行（带基本的profiling）\",\"3层：使用 C1 即时编译器编译执行（带完全的profiling）\",\"4层：使用 C2 即时编译器编译执行\",\"proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等\",\"public class JIT1 { public static void main(String[] args) { for (int i = 0; i < 200; i++) { long start = System.nanoTime(); for (int j = 0; j < 1000; j++) { new Object(); } long end = System.nanoTime(); System.out.printf(\\\"%d\\\\t%d\\\\n\\\",i,(end - start)); } } }\",\"即时编译器（JIT）与解释器的区别：\",\"解释器 \",\"将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释\",\"是将字节码解释为针对所有平台都通用的机器码\",\"即时编译器 \",\"将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译\",\"根据平台类型，生成平台特定的机器码\",\"对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码\",\"逃逸分析：\",\"发现新建的对象是否逃逸。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析\"]},\"252\":{\"h\":\"（2）方法内联\",\"t\":[\"举个栗子：\",\"private static int square(final int i) { return i * i; }\",\"System.out.println(square(9));\",\"如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置：\",\"System.out.println(9 * 9);\",\"还能够进行常量折叠（constant folding）的优化\",\"System.out.println(8);\",\"public class JIT2 { // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印 inlining 信息 // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining // -XX:+PrintCompilation 打印编译信息 public static void main(String[] args) { int x = 0; for (int i = 0; i < 500; i++) { long start = System.nanoTime(); for (int j = 0; j < 1000; j++) { x = square(9); } long end = System.nanoTime(); System.out.printf(\\\"%d\\\\t%d\\\\t%d\\\\n\\\",i,x,(end - start)); } } private static int square(final int i) { return i * i; } }\"]},\"253\":{\"h\":\"（3）字段优化\",\"t\":[\"JMH 基准测试请参考：http://openjdk.java.net/projects/code-tools/jmh/ 创建 maven 工程，添加依赖如下\",\"<dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-core</artifactId> <version>${jmh.version}</version> </dependency> <dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-generator-annprocess</artifactId> <version>${jmh.version}</version> <scope>provided</scope> </dependency>\",\"package test; import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.RunnerException; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; @Warmup(iterations = 2, time = 1) @Measurement(iterations = 5, time = 1) @State(Scope.Benchmark) public class Benchmark1 { int[] elements = randomInts(1_000); private static int[] randomInts(int size) { Random random = ThreadLocalRandom.current(); int[] values = new int[size]; for (int i = 0; i < size; i++) { values[i] = random.nextInt(); } return values; } @Benchmark public void test1() { for (int i = 0; i < elements.length; i++) { doSum(elements[i]); } } @Benchmark public void test2() { int[] local = this.elements; for (int i = 0; i < local.length; i++) { doSum(local[i]); } } @Benchmark public void test3() { for (int element : elements) { doSum(element); } } static int sum = 0; @CompilerControl(CompilerControl.Mode.INLINE) static void doSum(int x) { sum += x; } public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(Benchmark1.class.getSimpleName()) .forks(1) .build(); new Runner(opt).run(); } }\",\"首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：\",\"Benchmark Mode Samples Score Score error Units t.Benchmark1.test1 thrpt 5 2420286.539 390747.467 ops/s t.Benchmark1.test2 thrpt 5 2544313.594 91304.136 ops/s t.Benchmark1.test3 thrpt 5 2469176.697 450570.647 ops/s\",\"接下来禁用 doSum 方法内联\",\"@CompilerControl(CompilerControl.Mode.DONT_INLINE) static void doSum(int x) { sum += x; }\",\"测试结果如下：\",\"Benchmark Mode Samples Score Score error Units t.Benchmark1.test1 thrpt 5 296141.478 63649.220 ops/s t.Benchmark1.test2 thrpt 5 371262.351 83890.984 ops/s t.Benchmark1.test3 thrpt 5 368960.847 60163.391 ops/s\",\"分析： 在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化： 如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：\",\"@Benchmark public void test1() { // elements.length 首次读取会缓存起来 -> int[] local for (int i = 0; i < elements.length; i++) { // 后续 999 次 求长度 <- local sum += elements[i]; // 1000 次取下标 i 的元素 <- local } }\",\"可以节省 1999 次 Field 读取操作 但如果 doSum 方法没有内联，则不会进行上面的优化 练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果\"]},\"254\":{\"h\":\"6.2 反射优化\",\"t\":[\"public class Reflect1 { public static void foo() { System.out.println(\\\"foo...\\\"); } public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Method foo = Demo3.class.getMethod(\\\"foo\\\"); for(int i = 0; i<=16; i++) { foo.invoke(null); } } }\",\"foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现 invoke 方法源码\",\"import java.lang.reflect.Method; import sun.reflect.misc.ReflectUtil; class NativeMethodAccessorImpl extends MethodAccessorImpl { private final Method method; private DelegatingMethodAccessorImpl parent; private int numInvocations; NativeMethodAccessorImpl(Method method) { this.method = method; } public Object invoke(Object target, Object[] args) throws IllegalArgumentException, InvocationTargetException { // inflationThreshold 膨胀阈值，默认 15 if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) { // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右 MethodAccessorImpl generatedMethodAccessor = (MethodAccessorImpl) (new MethodAccessorGenerator()) .generateMethod( this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers() ); this.parent.setDelegate(generatedMethodAccessor); } // 调用本地实现 return invoke0(this.method, target, args); } void setParent(DelegatingMethodAccessorImpl parent) { this.parent = parent; } private static native Object invoke0(Method method, Object target, Object[] args); }\",\"当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1 可以使用阿里的 arthas 工具查看：\",\"java -jar arthas-boot.jar\",\"很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。\",\"简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障\",\"JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 JMM 体现在以下几个方面 \",\"原子性 - 保证指令不会受到线程上下文切换的影响\",\"可见性 - 保证指令不会受 cpu 缓存的影响\",\"有序性 - 保证指令不会受 cpu 指令并行优化的影响\"]},\"255\":{\"h\":\"1. 原子性\"},\"256\":{\"h\":\"1-1 问题解析\",\"t\":[\"提出问题：两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？\",\"public class Demo1 { static int i = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int j = 0; j < 50000; j++) { i++; } }); Thread t2 = new Thread(() -> { for (int j = 0; j < 50000; j++) { i--; } }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); } }\",\"以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。\",\"例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 iadd // 加法 putstatic i // 将修改后的值存入静态变量i\",\"而对应 i-- 也是类似：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 isub // 减法 putstatic i // 将修改后的值存入静态变量i\",\"而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：\",\"image-20240715213034845\",\"如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：\",\"// 假设i的初始值为0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 getstatic i // 线程1-获取静态变量i的值 线程内i=1 iconst_1 // 线程1-准备常量1 isub // 线程1-自减 线程内i=0 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=0\",\"但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：\",\"// 假设i的初始值为0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1\",\"出现正数的情况：\",\"// 假设i的初始值为0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1\"]},\"257\":{\"h\":\"1-2 解决方法 -加锁\"},\"258\":{\"h\":\"（1）synchronized（同步关键字）\",\"t\":[\"语法：\",\"synchronized( 对象 ) { 要作为原子操作代码 }\",\"用 synchronized 解决并发问题：\",\"public class Demo1 { static int i = 0; static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int j = 0; j < 50000; j++) { synchronized (obj) { i++; } } }); Thread t2 = new Thread(() -> { for (int j = 0; j < 50000; j++) { synchronized (obj) { i--; } } }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i);//输出为0 } }\",\"为什么需要这里的 obj 对象呢？\",\"我们可以这样理解：可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。\",\"当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。\",\"这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。\",\"当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count-- 代码。\",\"怎么从JVM角度理解呢？（这里引用《Java并发编程的艺术》里的一段话）\",\"从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter 和monitorexit指令实现的。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。\"]},\"259\":{\"h\":\"2.可见性\"},\"260\":{\"h\":\"2-1 退不出的循环\",\"t\":[\"先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：\",\"static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()->{ while(run){ // .... } }); t.start(); Thread.sleep(1000); run = false; // 线程t不会如预想的停下来 }\",\"为什么会这样？\",\"初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。\",\"image-20240715222147607\",\"因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率\",\"image-20240715222337696\",\"1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值\",\"image-20240715222432570\"]},\"261\":{\"h\":\"2-2 解决办法\"},\"262\":{\"h\":\"（1）volatile（易变关键字）\",\"t\":[\"它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存，保证了共享变量的可见性，但不能保证原子性\",\"public class Demo1 { volatile static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { while (run) { // .... } }); t.start(); Thread.sleep(1000); run = false; // 线程t如预想的停下来 } }\",\"注意：\",\"synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但 缺点是synchronized是属于重量级操作，性能相对更低\",\"如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也 能正确看到对 run 变量的修改了，想一想为什么？\",\"进入println源码：\",\"public void println(int x) { synchronized (this) { print(x); newLine(); } }\",\"可以看出加了synchronized，保证了每次run变量都会从主存中获取\"]},\"263\":{\"h\":\"2-3 可见性\",\"t\":[\"前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：\",\"getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 t 获取 run false\",\"比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解 决指令交错\",\"// 假设i的初始值为0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1\",\"虚拟机调优\",\"参考文章：https://blog.csdn.net/qq_45966440/article/details/120824295?spm=1001.2014.3001.5502\",\"参考文章：https://blog.csdn.net/weixin_50280576/article/details/113742011\",\"参考视频：https://www.bilibili.com/video/BV1yE411Z7AP?p=19&spm_id_from=pageDriver&vd_source=cd81f8812505504b960957155cd81114\"]},\"264\":{\"c\":[\"JVM\"]},\"265\":{\"c\":[\"jvm\"]},\"266\":{\"h\":\"Redis\"},\"267\":{\"c\":[\"Redis\"]},\"268\":{\"h\":\"Redis缓存穿透-布隆过滤器\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"269\":{\"h\":\"缓存穿透\",\"t\":[\"我举个蘑菇博客中的案例来说，我现在有一个博客详情页，然后博客详情页中的内容假设是存储在Redis中的，然后通过博客的Uid进行获取，正常的情况是：用户进入博客详情页，然后通过uid获取redis中缓存的文章详情，如果有内容就直接访问，如果不存在内容，那么需要访问数据库，然后从数据库中查询我们的博客详情后，然后在存储到redis中，最后在把数据返回给我们的页面。\",\"但是可能存在一些非法用户，他可能会模拟出很多不存在的key，然后通过该key去请求后台，首先redis的缓存没有命中，那么就去请求数据库，最后数据库没有查询出该内容，这样很多个非法的请求直接打在数据库中，可能会导致数据库直接宕机，无法对外提供服务。这就是我们所说的缓存穿透问题\"]},\"270\":{\"h\":\"简单的解决方法\",\"t\":[\"针对这个情况，我们有一种简单的解决方法就是，在数据库没有查询该条数据的时候，我们让该key缓存一个 空数据，这样用户再次以该key请求后台的时候，会直接返回null，避免了再次请求数据库。\"]},\"271\":{\"h\":\"布隆过滤器\"},\"272\":{\"h\":\"什么是布隆过滤器\",\"t\":[\"布隆过滤器的巨大作用 ，就是能够迅速判断一个元素是否存在一个集合中。因此次他有如下几个使用场景\",\"网站爬虫对URL的去重，避免爬取相同的URL\",\"反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否是垃圾邮件（同理，垃圾短信）\",\"缓存穿透，将所有可能的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时，迅速返回避免缓存以及DB挂掉。\"]},\"273\":{\"h\":\"原理\",\"t\":[\"布隆过滤器其内部维护了一个全为0的bit数组，需要说明的是，布隆过滤器有一个误判的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间多少。\",\"假设，根据误判率，我们生成一个10位的bit数组，以及2个hash函数 f1 和 f2，如下图所示：生成的数组的位数 和 hash函数的数量，我们不用去关心如何生成的，这是有数学论文进行验证。\",\"img\",\"然后我们输入一个集合，集合中包含 N1 和 N2，我们通过计算 f1(N1) = 2，f2(N1) = 5，则将数组下标为2 和下标为5的位置设置成1，就得到了下图\",\"img\",\"同理，我们再次进行计算 N2的值， f1(N2) = 3，f2(N2) = 6。得到如下所示的图\",\"img\",\"这个时候，假设我们有第三个数N3过来了，我们需要判断N3是否在集合 [N1,N2]中，我们需要做的操作就是，使用f1 和 f2 计算出数组中的地址\",\"若值恰巧都位于上图的红色位置，我们认为 N3在集合 [N1,N2] 中\",\"若值有一个不位于上图的红色部分，我们认为N3不在集合[N1,N2] 中\",\"这就是布隆过滤器的计算原理\"]},\"274\":{\"h\":\"使用\",\"t\":[\"在java中使用布隆过滤器，我们需要首先引入依赖，布隆过滤器拥有Google提供的一个开箱即用的组件，来帮助我们实现布隆过滤器，其实布隆过滤器的核心思想其实并不难，难的是在于如何设计随机映射函数，到底映射几次，二进制向量设置多少比较合适。\",\"<dependencies> <dependency> <groupId>com.google.guava</groupId> <artifactId>guava</artifactId> <version>22.0</version> </dependency> </dependencies>\",\"然后我们编写代码，测试某元素是否存在于百万元素集合中\",\" private static int size = 1000000;//预计要插入多少数据 private static double fpp = 0.01;//期望的误判率 private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp); public static void main(String[] args) { //插入数据 for (int i = 0; i < 1000000; i++) { bloomFilter.put(i); } int count = 0; for (int i = 1000000; i < 2000000; i++) { if (bloomFilter.mightContain(i)) { count++; System.out.println(i + \\\"误判了\\\"); } } System.out.println(\\\"总共的误判数:\\\" + count); }\"]},\"275\":{\"h\":\"代码分析\",\"t\":[\"上面的代码中，我们创建了一个布隆过滤器，其中有两个重要的参数，分别是我们要预计插入的数据和我们所期望的误判率，误判率率不能为0。\",\"我们首先向布隆过滤器中插入 0 ~ 100万条数据，然后在用 100万 ~ 200万的数据进行测试\",\"我们输出结果，查看一下误判率\",\"1999501误判了 1999567误判了 1999640误判了 1999697误判了 1999827误判了 1999942误判了 总共的误判数:10314\",\"现在有100万不存在的数据，误判了10314次，我们计算一下误判率\",\"10314 / 1000000 = 0.010314\",\"和我们之前定义的误判率为0.01相差无几\"]},\"276\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/rinack/p/9712477.html\",\"https://www.jianshu.com/p/2104d11ee0a2\",\"https://www.cnblogs.com/CodeBear/p/10911177.html\"]},\"277\":{\"c\":[\"Redis\"]},\"278\":{\"c\":[\"缓存穿透\",\"布隆过滤器\"]},\"279\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"280\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"281\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"282\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"283\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"284\":{\"c\":[\"使用指南\"]},\"285\":{\"c\":[\"页面配置\",\"使用指南\"]},\"286\":{\"h\":\"苹果 1\"},\"287\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"288\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"289\":{\"c\":[\"苹果\"]},\"290\":{\"c\":[\"红\",\"大\",\"圆\"]},\"291\":{\"h\":\"苹果 2\",\"t\":[\"一个被星标了的苹果文章。\"]},\"292\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"293\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"294\":{\"c\":[\"苹果\"]},\"295\":{\"c\":[\"红\",\"大\",\"圆\"]},\"296\":{\"h\":\"苹果 3\"},\"297\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"298\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"299\":{\"c\":[\"苹果\",\"水果\"]},\"300\":{\"c\":[\"红\",\"大\",\"圆\"]},\"301\":{\"h\":\"苹果 4\"},\"302\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"303\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"304\":{\"c\":[\"苹果\",\"水果\"]},\"305\":{\"c\":[\"红\",\"大\",\"圆\"]},\"306\":{\"h\":\"香蕉 1\"},\"307\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"308\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"309\":{\"c\":[\"香蕉\",\"水果\"]},\"310\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"311\":{\"h\":\"香蕉 2\",\"t\":[\"一个被数字 10 星标了的香蕉文章。\"]},\"312\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"313\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"314\":{\"c\":[\"香蕉\",\"水果\"]},\"315\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"316\":{\"h\":\"香蕉 3\"},\"317\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"318\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"319\":{\"c\":[\"香蕉\"]},\"320\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"321\":{\"h\":\"香蕉 4\"},\"322\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"323\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"324\":{\"c\":[\"香蕉\"]},\"325\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"326\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"327\":{\"h\":\"Posts\"},\"328\":{\"h\":\"Apple\"},\"329\":{\"h\":\"Banana\"}},\"dirtCount\":0,\"index\":[[\"星标了的香蕉文章\",{\"1\":{\"311\":1}}],[\"长\",{\"2\":{\"310\":1,\"315\":1,\"320\":1,\"325\":1}}],[\"长度为\",{\"1\":{\"205\":1}}],[\"弯曲的\",{\"2\":{\"310\":1,\"315\":1,\"320\":1,\"325\":1}}],[\"黄\",{\"2\":{\"310\":1,\"315\":1,\"320\":1,\"325\":1}}],[\"香蕉\",{\"0\":{\"306\":1,\"311\":1,\"316\":1,\"321\":1},\"2\":{\"309\":1,\"314\":1,\"319\":1,\"324\":1}}],[\"苹果\",{\"0\":{\"286\":1,\"291\":1,\"296\":1,\"301\":1},\"2\":{\"289\":1,\"294\":1,\"299\":1,\"304\":1}}],[\"现在有100万不存在的数据\",{\"1\":{\"275\":1}}],[\"误判率率不能为0\",{\"1\":{\"275\":1}}],[\"误判率越高则数组越小\",{\"1\":{\"273\":1}}],[\"误判率越低\",{\"1\":{\"273\":1}}],[\"误判了10314次\",{\"1\":{\"275\":1}}],[\"误判了\",{\"1\":{\"274\":1}}],[\"插入数据\",{\"1\":{\"274\":1}}],[\"插件\",{\"1\":{\"216\":1}}],[\"插件来实现\",{\"1\":{\"12\":1}}],[\"期望的误判率\",{\"1\":{\"274\":1}}],[\"预计要插入多少数据\",{\"1\":{\"274\":1}}],[\"测试某元素是否存在于百万元素集合中\",{\"1\":{\"274\":1}}],[\"测试结果如下\",{\"1\":{\"253\":2}}],[\"二进制向量设置多少比较合适\",{\"1\":{\"274\":1}}],[\"二进制文件\",{\"1\":{\"139\":1}}],[\"到底映射几次\",{\"1\":{\"274\":1}}],[\"难的是在于如何设计随机映射函数\",{\"1\":{\"274\":1}}],[\"迅速返回避免缓存以及db挂掉\",{\"1\":{\"272\":1}}],[\"避免爬取相同的url\",{\"1\":{\"272\":1}}],[\"避免了再次请求数据库\",{\"1\":{\"270\":1}}],[\"网站爬虫对url的去重\",{\"1\":{\"272\":1}}],[\"什么是布隆过滤器\",{\"0\":{\"272\":1}}],[\"什么时候触发\",{\"1\":{\"155\":2}}],[\"空数据\",{\"1\":{\"270\":1}}],[\"空间整合\",{\"1\":{\"158\":1}}],[\"针对这个情况\",{\"1\":{\"270\":1}}],[\"针对具有大内存多处理器的机器停顿时间可控\",{\"1\":{\"158\":1}}],[\"他可能会模拟出很多不存在的key\",{\"1\":{\"269\":1}}],[\"他可以避免线程从自己的工作缓存中查找变量的值\",{\"1\":{\"262\":1}}],[\"布隆过滤器拥有google提供的一个开箱即用的组件\",{\"1\":{\"274\":1}}],[\"布隆过滤器有一个误判的概念\",{\"1\":{\"273\":1}}],[\"布隆过滤器其内部维护了一个全为0的bit数组\",{\"1\":{\"273\":1}}],[\"布隆过滤器的巨大作用\",{\"1\":{\"272\":1}}],[\"布隆过滤器\",{\"0\":{\"268\":1,\"271\":1},\"2\":{\"278\":1}}],[\"布局包括\",{\"1\":{\"6\":1}}],[\"布局\",{\"0\":{\"6\":1},\"2\":{\"8\":1}}],[\"布局与功能禁用\",{\"0\":{\"3\":1,\"56\":1}}],[\"qq\",{\"1\":{\"263\":1}}],[\"query\",{\"1\":{\"202\":1}}],[\"queue\",{\"1\":{\"146\":5,\"147\":4,\"167\":1}}],[\"决指令交错\",{\"1\":{\"263\":1}}],[\"性能相对更低\",{\"1\":{\"262\":1}}],[\"性能调优\",{\"0\":{\"128\":1}}],[\"易变关键字\",{\"0\":{\"262\":1}}],[\"秒之后\",{\"1\":{\"260\":1}}],[\"秒后\",{\"1\":{\"98\":1}}],[\"退不出的循环\",{\"0\":{\"260\":1}}],[\"退出同步块解锁时\",{\"1\":{\"84\":1}}],[\"里的一段话\",{\"1\":{\"258\":1}}],[\"里面存放了\",{\"1\":{\"224\":1}}],[\"怎么从jvm角度理解呢\",{\"1\":{\"258\":1}}],[\"怎么能正确加载\",{\"1\":{\"245\":1}}],[\"房间\",{\"1\":{\"258\":1}}],[\"房间出来\",{\"1\":{\"258\":1}}],[\"假设我们有第三个数n3过来了\",{\"1\":{\"273\":1}}],[\"假设\",{\"1\":{\"273\":1}}],[\"假设i的初始值为0\",{\"1\":{\"256\":3,\"263\":1}}],[\"假设其中\",{\"1\":{\"94\":1}}],[\"减法\",{\"1\":{\"256\":1}}],[\"减少对主存中\",{\"1\":{\"260\":1}}],[\"减少可能的比较\",{\"1\":{\"223\":1}}],[\"减少stw\",{\"1\":{\"153\":1}}],[\"零\",{\"1\":{\"256\":1}}],[\"负数\",{\"1\":{\"256\":1}}],[\"吗\",{\"1\":{\"256\":1}}],[\"各做\",{\"1\":{\"256\":1}}],[\"提高效率\",{\"1\":{\"260\":1}}],[\"提出问题\",{\"1\":{\"256\":1}}],[\"提供线程阻塞和唤醒操作的工具类\",{\"1\":{\"101\":1}}],[\"提供了\",{\"1\":{\"185\":1}}],[\"提供了一些原子类\",{\"1\":{\"65\":1}}],[\"提供了更灵活的线程通信方式\",{\"1\":{\"59\":1}}],[\"提供更高级的线程通信和同步机制\",{\"1\":{\"59\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"14\":1}}],[\"体现在以下几个方面\",{\"1\":{\"254\":1}}],[\"体现的是\",{\"1\":{\"61\":1,\"247\":1}}],[\"硬件内存\",{\"1\":{\"254\":1}}],[\"缓存穿透\",{\"0\":{\"269\":1},\"1\":{\"272\":1},\"2\":{\"278\":1}}],[\"缓存的影响\",{\"1\":{\"254\":1}}],[\"缓存\",{\"1\":{\"254\":1}}],[\"抽象概念\",{\"1\":{\"254\":1}}],[\"共享内存\",{\"1\":{\"254\":1}}],[\"傻傻分不清\",{\"1\":{\"254\":1}}],[\"很多人将\",{\"1\":{\"254\":1}}],[\"倍左右\",{\"1\":{\"254\":1}}],[\"膨胀阈值\",{\"1\":{\"254\":1}}],[\"反垃圾邮件\",{\"1\":{\"272\":1}}],[\"反锁住门\",{\"1\":{\"258\":1}}],[\"反射优化\",{\"0\":{\"254\":1}}],[\"反编译后的结果\",{\"1\":{\"123\":2}}],[\"观察测试结果\",{\"1\":{\"253\":1}}],[\"观察发现\",{\"1\":{\"177\":1}}],[\"修饰符\",{\"1\":{\"253\":1,\"262\":1}}],[\"修改\",{\"1\":{\"146\":1,\"263\":1}}],[\"求长度\",{\"1\":{\"253\":1}}],[\"次调用使用的是\",{\"1\":{\"254\":1}}],[\"次取下标\",{\"1\":{\"253\":1}}],[\"次\",{\"1\":{\"253\":2,\"254\":1,\"256\":1}}],[\"次后\",{\"1\":{\"81\":1,\"82\":1}}],[\"伪代码\",{\"1\":{\"253\":1}}],[\"添加\",{\"1\":{\"253\":1}}],[\"添加依赖如下\",{\"1\":{\"253\":1}}],[\"添加被压制异常\",{\"1\":{\"226\":1}}],[\"粘贴到调用者的位置\",{\"1\":{\"252\":1}}],[\"举个栗子\",{\"1\":{\"252\":1}}],[\"逃逸分析\",{\"1\":{\"251\":1}}],[\"总共的误判数\",{\"1\":{\"274\":1,\"275\":1}}],[\"总的目标是发现热点代码\",{\"1\":{\"251\":1}}],[\"总会被首先初始化\",{\"1\":{\"237\":1}}],[\"总会添加一个安全的空档空间\",{\"1\":{\"171\":1}}],[\"回边次数\",{\"1\":{\"251\":1}}],[\"回收时被优先考虑\",{\"1\":{\"171\":1}}],[\"回收巨型对象\",{\"0\":{\"171\":1}}],[\"回收后\",{\"1\":{\"165\":1}}],[\"回收新生代伊甸园\",{\"1\":{\"162\":1}}],[\"回收以后会交换两个幸存区\",{\"1\":{\"153\":1}}],[\"回收流程\",{\"0\":{\"153\":1}}],[\"回收软引用对象\",{\"1\":{\"142\":1}}],[\"带完全的profiling\",{\"1\":{\"251\":1}}],[\"带基本的profiling\",{\"1\":{\"251\":1}}],[\"带泛型的类型\",{\"1\":{\"220\":1}}],[\"具体代码在\",{\"1\":{\"248\":1}}],[\"具有原子性\",{\"1\":{\"88\":1}}],[\"面向接口编程+解耦\",{\"1\":{\"247\":1}}],[\"面试题\",{\"1\":{\"125\":1}}],[\"约定如下\",{\"1\":{\"246\":1}}],[\"机制加载驱动\",{\"1\":{\"246\":1}}],[\"机制来保证可见性\",{\"1\":{\"65\":1}}],[\"正常的情况是\",{\"1\":{\"269\":1}}],[\"正确加载的\",{\"1\":{\"245\":1}}],[\"正在添加\",{\"1\":{\"241\":1}}],[\"正在处理中的\",{\"1\":{\"168\":1}}],[\"驱动\",{\"1\":{\"245\":1}}],[\"背景\",{\"0\":{\"245\":1}}],[\"模块热部署\",{\"1\":{\"243\":1}}],[\"模式下的虚拟机并行\",{\"1\":{\"158\":1}}],[\"模式下的虚拟机简单\",{\"1\":{\"158\":1}}],[\"模式\",{\"1\":{\"61\":1}}],[\"门的名词\",{\"1\":{\"243\":1}}],[\"热\",{\"1\":{\"243\":1}}],[\"热牛奶\",{\"1\":{\"0\":1}}],[\"建议用户重写findclass\",{\"1\":{\"243\":1}}],[\"远古\",{\"1\":{\"243\":1}}],[\"双亲委派模型的第三次\",{\"1\":{\"243\":1}}],[\"双亲委派模型的第二次\",{\"1\":{\"243\":1}}],[\"双亲委派模型的第一次\",{\"1\":{\"243\":1}}],[\"双亲委派模式\",{\"0\":{\"242\":1}}],[\"破坏双亲委派模式\",{\"1\":{\"243\":1}}],[\"要作为原子操作代码\",{\"1\":{\"258\":1}}],[\"要遵从双亲委派机制\",{\"1\":{\"243\":1}}],[\"要么就全部都不执行\",{\"1\":{\"65\":1}}],[\"父类\",{\"1\":{\"243\":1}}],[\"父子类的返回值完全一致\",{\"1\":{\"227\":1}}],[\"继承\",{\"1\":{\"243\":1}}],[\"继续看\",{\"1\":{\"246\":1}}],[\"继续运行\",{\"1\":{\"98\":1}}],[\"继续执行\",{\"1\":{\"98\":1}}],[\"步骤\",{\"1\":{\"243\":1}}],[\"容器\",{\"1\":{\"243\":1,\"247\":1}}],[\"容易产生内存碎片\",{\"1\":{\"149\":1}}],[\"希望解耦时\",{\"1\":{\"243\":1}}],[\"希望系统停顿时间最短\",{\"1\":{\"161\":1}}],[\"随意路径中的类文件\",{\"1\":{\"243\":1}}],[\"想一想为什么\",{\"1\":{\"262\":1}}],[\"想象成两个人\",{\"1\":{\"258\":1}}],[\"想象成一个房间\",{\"1\":{\"258\":1}}],[\"想加载非\",{\"1\":{\"243\":1}}],[\"想想\",{\"1\":{\"226\":1}}],[\"记录时间\",{\"1\":{\"242\":1}}],[\"记得去掉\",{\"1\":{\"78\":1}}],[\"捕获异常\",{\"1\":{\"242\":1}}],[\"若值有一个不位于上图的红色部分\",{\"1\":{\"273\":1}}],[\"若值恰巧都位于上图的红色位置\",{\"1\":{\"273\":1}}],[\"若extclassloader也加载失败\",{\"1\":{\"242\":1}}],[\"若新生代的伊甸园又满了\",{\"1\":{\"153\":1}}],[\"压缩了\",{\"1\":{\"241\":1}}],[\"压入操作数栈\",{\"1\":{\"192\":4,\"198\":1}}],[\"启动类的加载器\",{\"0\":{\"240\":1}}],[\"启动类加载器\",{\"1\":{\"239\":1}}],[\"应用程序类加载器\",{\"1\":{\"239\":1}}],[\"应用场景\",{\"1\":{\"161\":1}}],[\"显示为null\",{\"1\":{\"239\":1}}],[\"显示的\",{\"1\":{\"133\":1}}],[\"拓展类加载器\",{\"1\":{\"239\":1}}],[\"说明\",{\"1\":{\"239\":1}}],[\"说明轻量级锁进行了锁膨胀或已经升级为重量级锁\",{\"1\":{\"83\":1}}],[\"名称\",{\"1\":{\"239\":1}}],[\"名称加载的类说明\",{\"1\":{\"239\":1}}],[\"名+类型\",{\"1\":{\"182\":3}}],[\"懒惰实例化\",{\"1\":{\"238\":1}}],[\"才会导致内部类加载和初始化其静态成员\",{\"1\":{\"238\":1}}],[\"才有上述的效果\",{\"1\":{\"71\":1}}],[\"典型应用\",{\"1\":{\"238\":1}}],[\"访问类的\",{\"1\":{\"237\":1}}],[\"访问标识与继承信息\",{\"0\":{\"183\":1}}],[\"首次读取会缓存起来\",{\"1\":{\"253\":1}}],[\"首次访问这个类的静态变量或静态方法时\",{\"1\":{\"237\":2}}],[\"首先redis的缓存没有命中\",{\"1\":{\"269\":1}}],[\"首先启用\",{\"1\":{\"253\":1}}],[\"首先查找该类是否已经被该类加载器加载过了\",{\"1\":{\"242\":1}}],[\"首先排除减少因为自身编写的代码而引发的内存问题\",{\"1\":{\"175\":1}}],[\"首先会设置一个堆内存的大小为\",{\"1\":{\"146\":1}}],[\"初始状态\",{\"1\":{\"260\":1}}],[\"初始化器\",{\"1\":{\"247\":1}}],[\"初始化驱动\",{\"1\":{\"245\":1}}],[\"初始化时的线程安全是有保障的\",{\"1\":{\"238\":1}}],[\"初始化即调用\",{\"1\":{\"236\":1}}],[\"初始化\",{\"0\":{\"235\":1},\"1\":{\"238\":1}}],[\"初始标记\",{\"1\":{\"161\":1}}],[\"验证类是否被初始化\",{\"1\":{\"237\":1}}],[\"验证类是否符合\",{\"1\":{\"232\":1}}],[\"验证\",{\"0\":{\"232\":1}}],[\"验证方法地址\",{\"0\":{\"206\":1}}],[\"元数据\",{\"1\":{\"230\":2}}],[\"元空间用的本地\",{\"1\":{\"119\":1}}],[\"暴露给\",{\"1\":{\"230\":1}}],[\"klass\",{\"1\":{\"230\":1}}],[\"ﬁndclass\",{\"1\":{\"243\":1}}],[\"ﬁnal\",{\"1\":{\"198\":1,\"233\":2,\"237\":1}}],[\"ﬁelds\",{\"1\":{\"230\":1}}],[\"ﬁeld\",{\"1\":{\"230\":1}}],[\"描述\",{\"1\":{\"230\":1}}],[\"值发生了改变\",{\"1\":{\"228\":1}}],[\"值后\",{\"1\":{\"228\":1}}],[\"声明的\",{\"1\":{\"228\":1}}],[\"局部变量必须是final的\",{\"1\":{\"228\":1}}],[\"局部变量必须是\",{\"1\":{\"228\":1}}],[\"局部变量表中\",{\"1\":{\"215\":1}}],[\"局部变量表中有4个槽位\",{\"1\":{\"191\":1}}],[\"局部变量表分配\",{\"1\":{\"196\":1}}],[\"额外生成的类\",{\"1\":{\"228\":1}}],[\"源代码\",{\"1\":{\"228\":1}}],[\"源码\",{\"1\":{\"216\":1}}],[\"源码方式\",{\"1\":{\"216\":1}}],[\"源码编译为\",{\"1\":{\"216\":1}}],[\"实现\",{\"1\":{\"254\":1}}],[\"实现了\",{\"1\":{\"228\":1}}],[\"实验时请先全部注释\",{\"1\":{\"237\":1}}],[\"实际会产生如下的\",{\"1\":{\"256\":1}}],[\"实际就是\",{\"1\":{\"221\":1}}],[\"实际调用的是get\",{\"1\":{\"219\":1}}],[\"实际调用的是add\",{\"1\":{\"219\":1}}],[\"实际调用的是\",{\"1\":{\"219\":2}}],[\"实际的类型都当做了\",{\"1\":{\"219\":1}}],[\"实际上有一些类信息没被擦除\",{\"1\":{\"219\":1}}],[\"实际是在编译期间计算好的\",{\"1\":{\"192\":1}}],[\"匿名内部类则值不一致\",{\"1\":{\"228\":1}}],[\"匿名内部类\",{\"0\":{\"228\":1}}],[\"见下面的例子\",{\"1\":{\"227\":1}}],[\"子类访问父类静态变量\",{\"1\":{\"237\":1}}],[\"子类访问父类的静态变量\",{\"1\":{\"237\":1}}],[\"子类初始化\",{\"1\":{\"237\":2}}],[\"子类\",{\"1\":{\"227\":1}}],[\"子类返回值可以是父类返回值的子类\",{\"1\":{\"227\":1}}],[\"子类需要实现tryacquire和tryrelease等方法来控制锁的获取和释放\",{\"1\":{\"92\":1}}],[\"我现在有一个博客详情页\",{\"1\":{\"269\":1}}],[\"我举个蘑菇博客中的案例来说\",{\"1\":{\"269\":1}}],[\"我们计算一下误判率\",{\"1\":{\"275\":1}}],[\"我们输出结果\",{\"1\":{\"275\":1}}],[\"我们首先向布隆过滤器中插入\",{\"1\":{\"275\":1}}],[\"我们创建了一个布隆过滤器\",{\"1\":{\"275\":1}}],[\"我们认为n3不在集合\",{\"1\":{\"273\":1}}],[\"我们认为\",{\"1\":{\"273\":1}}],[\"我们需要首先引入依赖\",{\"1\":{\"274\":1}}],[\"我们需要做的操作就是\",{\"1\":{\"273\":1}}],[\"我们需要判断n3是否在集合\",{\"1\":{\"273\":1}}],[\"我们再次进行计算\",{\"1\":{\"273\":1}}],[\"我们通过计算\",{\"1\":{\"273\":1}}],[\"我们不用去关心如何生成的\",{\"1\":{\"273\":1}}],[\"我们生成一个10位的bit数组\",{\"1\":{\"273\":1}}],[\"我们让该key缓存一个\",{\"1\":{\"270\":1}}],[\"我们有一种简单的解决方法就是\",{\"1\":{\"270\":1}}],[\"我们可以这样理解\",{\"1\":{\"258\":1}}],[\"我们则可以将其编译成机器码\",{\"1\":{\"251\":1}}],[\"我们无需耗费时间将其编译成机器码\",{\"1\":{\"251\":1}}],[\"我们在使用\",{\"1\":{\"245\":1}}],[\"我们都知道\",{\"1\":{\"227\":1}}],[\"我是\",{\"1\":{\"199\":1}}],[\"我是不是偏向错了呢\",{\"1\":{\"81\":1}}],[\"生成平台特定的机器码\",{\"1\":{\"251\":1}}],[\"生成的数组的位数\",{\"1\":{\"273\":1}}],[\"生成的\",{\"1\":{\"226\":1}}],[\"生成新的栈帧\",{\"1\":{\"192\":1}}],[\"出现正数的情况\",{\"1\":{\"256\":1}}],[\"出现负数的情况\",{\"1\":{\"256\":1}}],[\"出现的异常就是最后\",{\"1\":{\"226\":1}}],[\"出现异常\",{\"1\":{\"212\":1,\"226\":1}}],[\"语句块既可以保证代码块的原子性\",{\"1\":{\"262\":1}}],[\"语句块\",{\"1\":{\"226\":1}}],[\"语法糖\",{\"1\":{\"216\":1}}],[\"语法\",{\"0\":{\"18\":1},\"1\":{\"14\":1,\"29\":1,\"258\":1,\"283\":1}}],[\"语法进行了扩展\",{\"1\":{\"13\":1}}],[\"语法扩展\",{\"1\":{\"12\":1}}],[\"资源变量\",{\"1\":{\"226\":1}}],[\"资源敏感\",{\"1\":{\"158\":1}}],[\"$values\",{\"1\":{\"225\":3}}],[\"$map\",{\"1\":{\"224\":2}}],[\"$$\",{\"1\":{\"18\":2}}],[\"枚举类\",{\"0\":{\"225\":1}}],[\"枚举的\",{\"1\":{\"224\":1}}],[\"枚举\",{\"0\":{\"224\":1}}],[\"又利用\",{\"1\":{\"223\":1}}],[\"又是并行的多线程收集器\",{\"1\":{\"160\":1}}],[\"冲突\",{\"1\":{\"223\":2}}],[\"赋值在准备阶段完成\",{\"1\":{\"233\":1}}],[\"赋值在初始化阶段完成\",{\"1\":{\"233\":1}}],[\"赋值\",{\"1\":{\"223\":1}}],[\"赋值给\",{\"1\":{\"221\":1}}],[\"赋值给i\",{\"1\":{\"214\":2}}],[\"赋值给局部变量\",{\"1\":{\"198\":1}}],[\"配合\",{\"1\":{\"223\":1}}],[\"配置\",{\"0\":{\"11\":1}}],[\"集合中包含\",{\"1\":{\"273\":1}}],[\"集合中存放了\",{\"1\":{\"146\":1}}],[\"集合要使用\",{\"1\":{\"222\":1}}],[\"样\",{\"1\":{\"221\":1}}],[\"拿到泛型类型\",{\"1\":{\"220\":1}}],[\"拿到方法\",{\"1\":{\"220\":1}}],[\"得到如下所示的图\",{\"1\":{\"273\":1}}],[\"得到\",{\"1\":{\"254\":1}}],[\"得到原始类型\",{\"1\":{\"220\":1}}],[\"得到泛型参数的类型信息\",{\"1\":{\"220\":1}}],[\"得到的字节码文件是这个样子的\",{\"1\":{\"179\":1}}],[\"擦除的是字节码上的泛型信息\",{\"1\":{\"220\":1}}],[\"函数取值时\",{\"1\":{\"219\":1}}],[\"泛型参数\",{\"1\":{\"220\":4}}],[\"泛型反射代码如下\",{\"1\":{\"220\":1}}],[\"泛型也是在\",{\"1\":{\"219\":1}}],[\"泛型集合取值\",{\"0\":{\"219\":1}}],[\"称谓拆箱\",{\"1\":{\"218\":1}}],[\"称为装箱\",{\"1\":{\"218\":1}}],[\"称为拆装箱\",{\"1\":{\"218\":1}}],[\"称为虚拟机栈\",{\"1\":{\"108\":1}}],[\"转换后代码\",{\"1\":{\"228\":1}}],[\"转换后的代码\",{\"1\":{\"225\":1,\"228\":1}}],[\"转换过程如下\",{\"1\":{\"218\":1}}],[\"转为\",{\"1\":{\"219\":2}}],[\"转储文件\",{\"1\":{\"139\":1}}],[\"切记\",{\"1\":{\"216\":1}}],[\"几乎等价\",{\"1\":{\"216\":1}}],[\"几点说明\",{\"1\":{\"194\":1}}],[\"借助了\",{\"1\":{\"216\":1}}],[\"算是\",{\"1\":{\"216\":1}}],[\"算法\",{\"1\":{\"162\":2}}],[\"异常\",{\"1\":{\"226\":2}}],[\"异常表\",{\"1\":{\"215\":1}}],[\"异常情况的解决方案\",{\"1\":{\"215\":1}}],[\"异常处理\",{\"0\":{\"208\":1}}],[\"相等\",{\"1\":{\"239\":1}}],[\"相比\",{\"1\":{\"213\":1}}],[\"相关题目\",{\"1\":{\"193\":1}}],[\"相关参数\",{\"1\":{\"162\":1}}],[\"相关概念\",{\"1\":{\"158\":1}}],[\"跟前一个中的\",{\"1\":{\"213\":1}}],[\"跟现实的司机很像\",{\"1\":{\"62\":1}}],[\"了\",{\"1\":{\"213\":2}}],[\"了解详情\",{\"1\":{\"11\":1}}],[\"没有问题\",{\"1\":{\"256\":1}}],[\"没有命名冲突\",{\"1\":{\"227\":1}}],[\"没有抛出异常\",{\"1\":{\"213\":1}}],[\"没有全局变量\",{\"1\":{\"85\":1}}],[\"暂存到局部变量表的\",{\"1\":{\"215\":1}}],[\"暂存返回值\",{\"1\":{\"213\":1}}],[\"暂停其它用户的线程\",{\"1\":{\"153\":1}}],[\"暂停线程对象\",{\"1\":{\"62\":1}}],[\"暂停当前线程\",{\"1\":{\"62\":1}}],[\"虽然从字节码指令看来\",{\"1\":{\"212\":1}}],[\"流程以及\",{\"1\":{\"212\":1}}],[\"流程\",{\"1\":{\"212\":1}}],[\"份\",{\"1\":{\"212\":1}}],[\"剩余的异常类型流程\",{\"1\":{\"212\":1}}],[\"剩余的异常类型\",{\"1\":{\"212\":2}}],[\"抛出异常\",{\"1\":{\"212\":1,\"214\":1}}],[\"块内的代码\",{\"1\":{\"258\":1}}],[\"块中的\",{\"1\":{\"226\":1}}],[\"块中的内容\",{\"1\":{\"213\":1}}],[\"块中出现异常\",{\"1\":{\"213\":1}}],[\"块中如果有返回操作的话\",{\"1\":{\"213\":1}}],[\"块的情况\",{\"0\":{\"210\":1}}],[\"块以及\",{\"1\":{\"65\":1}}],[\"匹配异常类型\",{\"1\":{\"209\":1}}],[\"偏移\",{\"1\":{\"205\":1}}],[\"偏向某个线程使用\",{\"1\":{\"87\":1}}],[\"偏向状态\",{\"0\":{\"77\":1}}],[\"偏向锁\",{\"0\":{\"76\":1},\"1\":{\"87\":1}}],[\"行代码可能交错运行\",{\"1\":{\"256\":1}}],[\"行代码是顺序执行\",{\"1\":{\"256\":1}}],[\"行\",{\"1\":{\"204\":1}}],[\"点击超链接可以看到对象的内存结构\",{\"1\":{\"203\":1}}],[\"点击\",{\"1\":{\"202\":1}}],[\"安全性检查\",{\"1\":{\"232\":1}}],[\"安全点\",{\"1\":{\"159\":1}}],[\"安装目录\",{\"1\":{\"201\":1}}],[\"停在\",{\"1\":{\"200\":1}}],[\"停车场显示空余车位减一\",{\"1\":{\"94\":1}}],[\"吃鱼\",{\"1\":{\"199\":1}}],[\"啃骨头\",{\"1\":{\"199\":1}}],[\"查表得到方法的具体地址\",{\"1\":{\"207\":1}}],[\"查找类的规则\",{\"1\":{\"242\":1}}],[\"查找\",{\"1\":{\"205\":1}}],[\"查找某个对象\",{\"0\":{\"202\":1}}],[\"查询vtable找到方法的具体地址\",{\"1\":{\"199\":1}}],[\"查看一下误判率\",{\"1\":{\"275\":1}}],[\"查看每个类的方法定义\",{\"1\":{\"206\":1}}],[\"查看类的\",{\"0\":{\"205\":1}}],[\"查看对象\",{\"0\":{\"204\":1}}],[\"查看对象内存结构\",{\"0\":{\"203\":1}}],[\"查看\",{\"1\":{\"175\":1}}],[\"查看虚拟机参数命令\",{\"1\":{\"172\":1}}],[\"查看程序的进程\",{\"1\":{\"139\":1}}],[\"查看堆内存占用情况\",{\"1\":{\"116\":1}}],[\"查看当前系统中有哪些\",{\"1\":{\"116\":1}}],[\"查看详情\",{\"1\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1}}],[\"经历了以下几个步骤\",{\"1\":{\"199\":1}}],[\"普通成员方法是由\",{\"1\":{\"198\":1}}],[\"普通成员方法在调用时\",{\"1\":{\"198\":1}}],[\"终方法\",{\"1\":{\"198\":1}}],[\"终结器引用\",{\"1\":{\"145\":2}}],[\"另一方面\",{\"1\":{\"251\":1}}],[\"另一个要配合\",{\"1\":{\"198\":1}}],[\"另外\",{\"1\":{\"216\":1}}],[\"另外utf\",{\"1\":{\"182\":1}}],[\"私有方法\",{\"1\":{\"198\":1}}],[\"私有\",{\"1\":{\"198\":1}}],[\"看看\",{\"1\":{\"245\":1}}],[\"看是否被启动类加载器加载过\",{\"1\":{\"242\":1}}],[\"看是否被它的上级加载器加载过了\",{\"1\":{\"242\":1}}],[\"看到如下界面\",{\"1\":{\"205\":1}}],[\"看一下几种不同的方法调用对应的字节码指令\",{\"1\":{\"198\":1}}],[\"看能否沿着gcroot对象为起点的引用链找到该对象\",{\"1\":{\"137\":1}}],[\"形成新的构造方法\",{\"1\":{\"197\":1}}],[\"合并为一个特殊的方法\",{\"1\":{\"197\":1}}],[\"静态变量i=\",{\"1\":{\"256\":2,\"263\":1}}],[\"静态变量i=0\",{\"1\":{\"256\":1}}],[\"静态变量i=1\",{\"1\":{\"256\":3,\"263\":1}}],[\"静态常量\",{\"1\":{\"237\":2}}],[\"静态方法在调用时使用invokestatic指令\",{\"1\":{\"198\":1}}],[\"静态代码块和静态成员赋值的代码\",{\"1\":{\"197\":1}}],[\"静止显示的\",{\"1\":{\"133\":1}}],[\"构造\",{\"1\":{\"198\":1}}],[\"构造方法都是由\",{\"1\":{\"198\":1}}],[\"构造方法\",{\"0\":{\"197\":1},\"1\":{\"236\":1}}],[\"构造时设置\",{\"1\":{\"98\":1}}],[\"跳转到第4条指令\",{\"1\":{\"196\":1}}],[\"槽位中的值为\",{\"1\":{\"196\":1}}],[\"运算结束后操作数栈为空\",{\"1\":{\"196\":1}}],[\"运行期优化\",{\"0\":{\"249\":1}}],[\"运行下面的代码\",{\"1\":{\"213\":1}}],[\"运行\",{\"0\":{\"201\":1}}],[\"运行代码\",{\"0\":{\"200\":1}}],[\"运行用户代码时间\",{\"1\":{\"158\":2}}],[\"运行时常量池\",{\"0\":{\"122\":1},\"1\":{\"122\":1}}],[\"运行结束\",{\"1\":{\"61\":1}}],[\"准备常量1\",{\"1\":{\"256\":8,\"263\":2}}],[\"准备常数\",{\"1\":{\"71\":1}}],[\"准备\",{\"0\":{\"233\":1}}],[\"准备一个常数\",{\"1\":{\"196\":2}}],[\"呢\",{\"1\":{\"196\":1,\"245\":1}}],[\"判断了资源不为空\",{\"1\":{\"226\":1}}],[\"判断参数类型是否\",{\"1\":{\"220\":1}}],[\"判断结果\",{\"0\":{\"196\":1}}],[\"判断是否\",{\"1\":{\"194\":3}}],[\"殊途也能同归😊\",{\"1\":{\"195\":1}}],[\"细心的同学应当注意到\",{\"1\":{\"194\":1}}],[\"细节如图\",{\"1\":{\"146\":1}}],[\"思考一下\",{\"1\":{\"256\":1}}],[\"思考\",{\"1\":{\"194\":1}}],[\"比较一下之前我们将线程安全时举的例子\",{\"1\":{\"263\":1}}],[\"比较两个类是否\",{\"1\":{\"239\":1}}],[\"比较绕口\",{\"1\":{\"227\":1}}],[\"比较呢\",{\"1\":{\"223\":1}}],[\"比较可知\",{\"1\":{\"206\":1}}],[\"比较有意思的是\",{\"1\":{\"198\":1}}],[\"比较操作数栈中的两个数\",{\"1\":{\"196\":1}}],[\"比较\",{\"1\":{\"194\":1,\"195\":1}}],[\"比如第一项0a是constant\",{\"1\":{\"182\":1}}],[\"比如\",{\"1\":{\"180\":1,\"212\":2}}],[\"比如手动\",{\"1\":{\"133\":1}}],[\"比如限制数据库连接池的大小\",{\"1\":{\"96\":1}}],[\"助记符\",{\"1\":{\"194\":1}}],[\"条件判断指令\",{\"0\":{\"194\":1}}],[\"条件变量\",{\"1\":{\"59\":1}}],[\"练习\",{\"0\":{\"193\":1,\"196\":1,\"238\":1},\"1\":{\"253\":1}}],[\"弹出\",{\"1\":{\"192\":1}}],[\"弹出栈帧\",{\"1\":{\"192\":1}}],[\"完成静态变量的自增\",{\"1\":{\"256\":1}}],[\"完成类的加载和初始化\",{\"1\":{\"246\":1}}],[\"完成懒惰初始化单例模式\",{\"1\":{\"238\":1}}],[\"完成\",{\"1\":{\"192\":1}}],[\"传入枚举元素的值及\",{\"1\":{\"225\":1}}],[\"传递参数\",{\"1\":{\"192\":1}}],[\"传送门\",{\"1\":{\"182\":1}}],[\"定位到方法区\",{\"1\":{\"192\":1}}],[\"定义了一套在多线程读写共享数据时\",{\"1\":{\"254\":1}}],[\"定义了这些概念来规范多线程程序的内存一致性行为\",{\"1\":{\"65\":1}}],[\"定义的驱动名加载驱动\",{\"1\":{\"246\":1}}],[\"定义一个合成类\",{\"1\":{\"224\":1}}],[\"定义\",{\"0\":{\"108\":1,\"113\":1,\"118\":1,\"130\":1},\"1\":{\"149\":1,\"150\":1,\"151\":1,\"159\":2,\"160\":2,\"161\":2}}],[\"号槽位的值自增\",{\"1\":{\"196\":1}}],[\"号槽位的值又变为了0\",{\"1\":{\"196\":1}}],[\"号槽位的数加\",{\"1\":{\"196\":1}}],[\"号槽位的数放入操作数栈中\",{\"1\":{\"196\":2}}],[\"号槽位\",{\"1\":{\"196\":3,\"215\":1}}],[\"号位置的元素压入操作数栈中\",{\"1\":{\"192\":1}}],[\"号位置的元素放入操作数栈中\",{\"1\":{\"192\":1}}],[\"号位置和\",{\"1\":{\"192\":1}}],[\"号位置\",{\"1\":{\"192\":1}}],[\"号的内容需要在常量池中查找\",{\"1\":{\"121\":1}}],[\"放到操作数栈\",{\"1\":{\"215\":1}}],[\"放到局部变量表的\",{\"1\":{\"192\":1}}],[\"放入的值是\",{\"1\":{\"196\":1}}],[\"放入操作数栈中\",{\"1\":{\"196\":1}}],[\"放入局部变量的\",{\"1\":{\"196\":1}}],[\"放入局部变量表的3号位置\",{\"1\":{\"192\":1}}],[\"放入局部变量表的\",{\"1\":{\"192\":1,\"196\":1}}],[\"放入一个队列\",{\"1\":{\"169\":1}}],[\"放入串池\",{\"1\":{\"123\":1}}],[\"读取操作\",{\"1\":{\"253\":1}}],[\"读取类文件的字节码\",{\"1\":{\"243\":1}}],[\"读取运行时常量池中\",{\"1\":{\"192\":1}}],[\"读操作也是如此\",{\"1\":{\"67\":1}}],[\"读操作会从主内存中读取数据\",{\"1\":{\"67\":1}}],[\"范围的数字存入了\",{\"1\":{\"192\":1}}],[\"超过\",{\"1\":{\"192\":2}}],[\"超大堆内存\",{\"1\":{\"162\":1}}],[\"公共的\",{\"1\":{\"183\":1}}],[\"公平性\",{\"1\":{\"95\":1}}],[\"公平锁\",{\"1\":{\"88\":1}}],[\"两项\",{\"1\":{\"182\":3}}],[\"两个线程一个\",{\"1\":{\"263\":1}}],[\"两个线程对初始值为\",{\"1\":{\"256\":1}}],[\"两个区域之间是\",{\"1\":{\"162\":1}}],[\"两个对象的计数都为1\",{\"0\":{\"136\":1}}],[\"串\",{\"1\":{\"182\":23}}],[\"串行\",{\"0\":{\"159\":1}}],[\"成员变量\",{\"1\":{\"254\":1}}],[\"成员变量读取的优化\",{\"1\":{\"253\":1}}],[\"成员变量名\",{\"1\":{\"182\":1}}],[\"成员方法与静态方法调用的另一个区别是\",{\"1\":{\"198\":1}}],[\"成功\",{\"1\":{\"83\":1}}],[\"信息\",{\"1\":{\"182\":7,\"252\":1}}],[\"依次类推\",{\"1\":{\"182\":1}}],[\"项来获得这个成员变量的\",{\"1\":{\"182\":1}}],[\"项来获得这个方法的\",{\"1\":{\"182\":2}}],[\"项\",{\"1\":{\"182\":7,\"192\":1}}],[\"项不计入\",{\"1\":{\"182\":1}}],[\"碰到属于constant\",{\"1\":{\"182\":1}}],[\"参考视频\",{\"1\":{\"263\":1}}],[\"参考文章\",{\"1\":{\"263\":2}}],[\"参考文档\",{\"1\":{\"182\":1}}],[\"参考\",{\"0\":{\"276\":1},\"1\":{\"194\":1}}],[\"参数的类型以及泛型类型\",{\"1\":{\"220\":1}}],[\"参数决定\",{\"1\":{\"164\":1}}],[\"参数来限制垃圾收集的线程数\",{\"1\":{\"159\":1}}],[\"参数\",{\"1\":{\"155\":1,\"160\":1,\"199\":1,\"204\":2}}],[\"参数类型\",{\"1\":{\"122\":1}}],[\"代表jdk8\",{\"1\":{\"181\":1}}],[\"代码分析\",{\"0\":{\"275\":1}}],[\"代码热替换\",{\"1\":{\"243\":1}}],[\"代码\",{\"1\":{\"193\":1,\"258\":2}}],[\"代码都可以访问的一块区域\",{\"1\":{\"131\":1}}],[\"代码块同步是使用monitorenter\",{\"1\":{\"258\":1}}],[\"代码块和成员变量赋值的代码\",{\"1\":{\"197\":1}}],[\"代码块\",{\"1\":{\"83\":2}}],[\"版本\",{\"0\":{\"181\":1}}],[\"版本号\",{\"1\":{\"120\":1}}],[\"意思就是\",{\"1\":{\"205\":1}}],[\"意思就是禁止我们手动的\",{\"1\":{\"133\":1}}],[\"意思是\",{\"1\":{\"180\":1}}],[\"魔数\",{\"0\":{\"180\":1}}],[\"规范\",{\"1\":{\"179\":1}}],[\"规定了\",{\"1\":{\"65\":1}}],[\"根据误判率\",{\"1\":{\"273\":1}}],[\"根据平台类型\",{\"1\":{\"251\":1}}],[\"根据\",{\"1\":{\"179\":1}}],[\"根本就不该偏向\",{\"1\":{\"82\":1}}],[\"频繁\",{\"1\":{\"178\":1}}],[\"频繁触发\",{\"1\":{\"176\":1}}],[\"否者先尝试调优新生代\",{\"1\":{\"177\":1}}],[\"否则不会走双亲委派机制\",{\"1\":{\"243\":1}}],[\"否则\",{\"1\":{\"239\":1}}],[\"否则退化为\",{\"1\":{\"171\":1}}],[\"否则底层线程可能被\",{\"1\":{\"79\":1}}],[\"晋升阈值配置得当\",{\"1\":{\"176\":1}}],[\"晋升老年代的对象年龄\",{\"1\":{\"160\":1}}],[\"响应\",{\"1\":{\"176\":1}}],[\"响应时间优先\",{\"0\":{\"161\":1}}],[\"清理新生代所花费的时间会更长\",{\"1\":{\"176\":1}}],[\"清除的过程中\",{\"1\":{\"161\":1}}],[\"清除算法实现\",{\"1\":{\"161\":1}}],[\"清除算法的垃圾回收器\",{\"1\":{\"161\":1}}],[\"清除算法希望系统停顿时间最短\",{\"1\":{\"158\":1}}],[\"清除\",{\"1\":{\"161\":1,\"192\":1}}],[\"朝生夕死\",{\"1\":{\"176\":1}}],[\"死亡对象回收零代价\",{\"1\":{\"176\":1}}],[\"弱\",{\"1\":{\"175\":1}}],[\"弱引用搭配\",{\"1\":{\"147\":1}}],[\"弱引用的使用和软引用类似\",{\"1\":{\"147\":1}}],[\"弱引用\",{\"1\":{\"143\":1,\"147\":1}}],[\"软\",{\"1\":{\"175\":1}}],[\"软引用自己会加入到\",{\"1\":{\"146\":1}}],[\"软引用对象\",{\"1\":{\"146\":2}}],[\"软引用\",{\"1\":{\"142\":1,\"146\":3}}],[\"考虑以下几个问题\",{\"1\":{\"175\":1}}],[\"考虑是否需要将字符串对象入池\",{\"1\":{\"128\":1}}],[\"zero\",{\"1\":{\"226\":1}}],[\"z\",{\"1\":{\"219\":1,\"220\":1}}],[\"zing\",{\"1\":{\"174\":1}}],[\"zgc\",{\"1\":{\"174\":1}}],[\"互相保存了对方的地址\",{\"1\":{\"230\":1}}],[\"互联网注重低延迟\",{\"1\":{\"174\":1}}],[\"互斥锁\",{\"1\":{\"59\":1}}],[\"科学运算注重吞吐量\",{\"1\":{\"174\":1}}],[\"选择合适的gc\",{\"1\":{\"174\":1}}],[\"选项卡\",{\"0\":{\"15\":1}}],[\"高吞吐量\",{\"1\":{\"174\":2}}],[\"高效垃圾回收时必须暂停其他所有的工作线程parallel\",{\"1\":{\"158\":1}}],[\"高效垃圾回收时必须暂停其他所有的工作线程parnewserial\",{\"1\":{\"158\":1}}],[\"高效的并发程序至关重要\",{\"1\":{\"65\":1}}],[\"确定目标\",{\"0\":{\"174\":1}}],[\"确保线程已经进入park状态\",{\"1\":{\"101\":1}}],[\"确保在该屏障之前的所有读\",{\"1\":{\"68\":1}}],[\"确保在不同的线程\",{\"1\":{\"65\":1}}],[\"确保在并发环境中程序的执行结果与按序执行时的结果一致\",{\"1\":{\"65\":1}}],[\"确保对象的引用在构造之后不会改变\",{\"1\":{\"59\":1}}],[\"确保对变量的读写操作直接在主内存中进行\",{\"1\":{\"59\":1}}],[\"占用\",{\"1\":{\"173\":1}}],[\"底层对应着\",{\"1\":{\"254\":1}}],[\"底层是char\",{\"1\":{\"169\":1}}],[\"底层线程\",{\"1\":{\"79\":1}}],[\"略微多占用了\",{\"1\":{\"169\":1}}],[\"节省大量内存\",{\"1\":{\"169\":1}}],[\"节点\",{\"1\":{\"94\":3}}],[\"发现新建的对象是否逃逸\",{\"1\":{\"251\":1}}],[\"发现它最后是使用\",{\"1\":{\"246\":1}}],[\"发现没有\",{\"1\":{\"213\":1}}],[\"发现\",{\"1\":{\"206\":1}}],[\"发现是一个对象\",{\"1\":{\"192\":1}}],[\"发现有强引用引用它\",{\"1\":{\"168\":1}}],[\"发生的时机\",{\"0\":{\"237\":1}}],[\"发生\",{\"1\":{\"178\":1}}],[\"发展历史最悠久的收集器\",{\"1\":{\"159\":2}}],[\"处理中\",{\"1\":{\"168\":1}}],[\"处理器和编译器优化下\",{\"1\":{\"65\":1}}],[\"处理器乱序执行等原因\",{\"1\":{\"65\":1}}],[\"白色\",{\"1\":{\"168\":1}}],[\"灰色\",{\"1\":{\"168\":1}}],[\"已添加清单\",{\"1\":{\"241\":1}}],[\"已被处理\",{\"1\":{\"168\":1}}],[\"已经对该对象加了轻量级锁\",{\"1\":{\"84\":1}}],[\"黑色\",{\"1\":{\"168\":1}}],[\"脏卡\",{\"1\":{\"167\":1}}],[\"卡表\",{\"1\":{\"167\":1}}],[\"跨代引用\",{\"0\":{\"167\":1}}],[\"便会触发full\",{\"1\":{\"166\":1}}],[\"能正确看到对\",{\"1\":{\"262\":1}}],[\"能够配合数组\",{\"1\":{\"222\":1}}],[\"能够得到更多内存\",{\"1\":{\"165\":1}}],[\"能直接到的对象\",{\"1\":{\"161\":1}}],[\"耗时可能过高\",{\"1\":{\"165\":1}}],[\"耗费时间等信息\",{\"1\":{\"127\":1}}],[\"问\",{\"1\":{\"165\":1,\"223\":1}}],[\"问题解析\",{\"0\":{\"256\":1}}],[\"问题\",{\"1\":{\"159\":1,\"161\":2,\"167\":1}}],[\"问题辨析\",{\"1\":{\"108\":1}}],[\"拷贝存活\",{\"1\":{\"165\":1}}],[\"阈值可以根据用户来进行设定\",{\"1\":{\"164\":1}}],[\"伊甸园\",{\"1\":{\"163\":1}}],[\"伊甸园和\",{\"1\":{\"153\":1}}],[\"产生的停顿时间\",{\"1\":{\"163\":1}}],[\"产生垃圾碎片g1一款面向服务器的垃圾收集器\",{\"1\":{\"158\":1}}],[\"方便控制\",{\"1\":{\"163\":1}}],[\"方法源码\",{\"1\":{\"254\":1}}],[\"方法没有内联\",{\"1\":{\"253\":1}}],[\"方法会被优化成下面的样子\",{\"1\":{\"253\":1}}],[\"方法会在类加载的初始化阶段被调用\",{\"1\":{\"197\":1}}],[\"方法内联了\",{\"1\":{\"253\":1}}],[\"方法内联\",{\"0\":{\"252\":1},\"1\":{\"253\":1}}],[\"方法的调用次数\",{\"1\":{\"251\":1}}],[\"方法的返回值是\",{\"1\":{\"227\":1}}],[\"方法中也会调用该方法\",{\"1\":{\"243\":1}}],[\"方法中的线程能够立即看到这个变化\",{\"1\":{\"68\":1}}],[\"方法去找到该类\",{\"1\":{\"242\":1}}],[\"方法时\",{\"1\":{\"242\":1}}],[\"方法所在的类\",{\"1\":{\"237\":1}}],[\"方法不会导致类的解析和初始化\",{\"1\":{\"234\":1}}],[\"方法返回值\",{\"1\":{\"227\":1}}],[\"方法重写时对返回值分两种情况\",{\"1\":{\"227\":1}}],[\"方法重写时的桥接方法\",{\"0\":{\"227\":1}}],[\"方法是否内联会影响\",{\"1\":{\"253\":1}}],[\"方法是继承\",{\"1\":{\"206\":1}}],[\"方法是\",{\"1\":{\"206\":1}}],[\"方法2\",{\"1\":{\"205\":1}}],[\"方法1\",{\"1\":{\"205\":1}}],[\"方法上\",{\"1\":{\"200\":1}}],[\"方法解析\",{\"1\":{\"146\":2}}],[\"方法调用\",{\"0\":{\"198\":1},\"1\":{\"192\":1}}],[\"方法调用结束后会弹出栈\",{\"1\":{\"108\":1}}],[\"方法调\",{\"1\":{\"132\":1}}],[\"方法减少重复入池\",{\"1\":{\"128\":1}}],[\"方法名\",{\"1\":{\"122\":1,\"182\":2}}],[\"方法区中常量引用的对象\",{\"1\":{\"138\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"138\":1}}],[\"方法区内存溢出\",{\"0\":{\"120\":1}}],[\"方法区域的内存不需要是连续的\",{\"1\":{\"118\":1}}],[\"方法区域可以具有固定的大小\",{\"1\":{\"118\":1}}],[\"方法区域类似于用于传统语言的编译代码的存储区域\",{\"1\":{\"118\":1}}],[\"方法区\",{\"0\":{\"117\":1}}],[\"方法呢的局部变量是否线程安全\",{\"1\":{\"108\":1}}],[\"方法唤醒\",{\"1\":{\"101\":1}}],[\"方法唤醒它\",{\"1\":{\"59\":1}}],[\"方法进行等待\",{\"1\":{\"98\":1}}],[\"方法来加载类\",{\"1\":{\"243\":1}}],[\"方法来释放一个许可\",{\"1\":{\"95\":1}}],[\"方法来获取一个许可\",{\"1\":{\"95\":1}}],[\"方法修改\",{\"1\":{\"68\":1}}],[\"方法\",{\"0\":{\"236\":1},\"1\":{\"60\":1,\"95\":1,\"132\":1,\"145\":1,\"146\":1,\"192\":1,\"223\":1,\"227\":1,\"238\":1,\"243\":4,\"246\":1,\"248\":1}}],[\"方法暂停执行并等待其他线程通过\",{\"1\":{\"59\":1}}],[\"方法实现\",{\"1\":{\"59\":1}}],[\"阶段\",{\"1\":{\"162\":1}}],[\"整体上是\",{\"1\":{\"162\":1}}],[\"整理\",{\"1\":{\"161\":1}}],[\"整理算法\",{\"1\":{\"159\":2,\"160\":2,\"161\":1}}],[\"整理算法在注重吞吐量及cpu资源的场合吞吐量高\",{\"1\":{\"158\":1}}],[\"整理算法在\",{\"1\":{\"158\":1}}],[\"整理时需要重新处理引用关系\",{\"1\":{\"150\":1}}],[\"低延迟\",{\"1\":{\"162\":1,\"174\":2}}],[\"低停顿\",{\"1\":{\"161\":1}}],[\"低停顿对\",{\"1\":{\"158\":1}}],[\"找出存活对象且用户线程可并发执行\",{\"1\":{\"161\":1}}],[\"找到对象的实际\",{\"1\":{\"207\":1}}],[\"找到对象实际的class\",{\"1\":{\"199\":1}}],[\"找到常量池\",{\"1\":{\"192\":1}}],[\"找到父类全限定名\",{\"1\":{\"183\":1}}],[\"找到本类全限定名\",{\"1\":{\"183\":1}}],[\"找到它所引用的对象\",{\"1\":{\"145\":1}}],[\"找到被引用对象并调用它的\",{\"1\":{\"145\":1}}],[\"找到了\",{\"1\":{\"139\":1}}],[\"服务提供接口\",{\"0\":{\"246\":1}}],[\"服务\",{\"1\":{\"161\":1}}],[\"尽可能让单次的暂停时间\",{\"1\":{\"161\":1}}],[\"尽管方法区域在逻辑上是堆的一部分\",{\"1\":{\"118\":1}}],[\"尽管\",{\"1\":{\"67\":1}}],[\"控制最大的垃圾收集停顿时间\",{\"1\":{\"160\":1}}],[\"控制线程池中的线程数量等\",{\"1\":{\"96\":1}}],[\"区的比例\",{\"1\":{\"160\":1}}],[\"区别在于new会在堆中创建一个新的对象\",{\"1\":{\"124\":1}}],[\"属于动态绑定\",{\"1\":{\"198\":2}}],[\"属于静态绑定\",{\"1\":{\"198\":2}}],[\"属于新生代收集器也是采用复制算法的收集器\",{\"1\":{\"160\":1}}],[\"属于操作系统\",{\"1\":{\"130\":1}}],[\"故也称为吞吐量优先收集器\",{\"1\":{\"160\":2}}],[\"~\",{\"1\":{\"160\":1,\"161\":3,\"177\":1,\"254\":1,\"275\":2}}],[\"非常多的环境中\",{\"1\":{\"159\":1}}],[\"非公平锁\",{\"1\":{\"88\":1}}],[\"采用标记\",{\"1\":{\"159\":2,\"160\":2}}],[\"采用复制算法\",{\"1\":{\"159\":2,\"160\":1}}],[\"专心做垃圾收集自然可以获得最高的单线程收集效率\",{\"1\":{\"159\":1}}],[\"简单的解决方法\",{\"0\":{\"270\":1}}],[\"简单的说\",{\"1\":{\"254\":1}}],[\"简单高效\",{\"1\":{\"159\":1}}],[\"简单来说线程有两种通信方式\",{\"1\":{\"59\":1}}],[\"且\",{\"1\":{\"213\":1}}],[\"且在该线程执行回收工作时\",{\"1\":{\"159\":1}}],[\"且后台线程还会对虚引用的对象监测\",{\"1\":{\"132\":1}}],[\"适用场景\",{\"1\":{\"162\":1}}],[\"适用于注重服务的响应速度\",{\"1\":{\"161\":1}}],[\"适用于状态标记\",{\"1\":{\"68\":1}}],[\"适合个人电脑\",{\"1\":{\"159\":1}}],[\"单个的\",{\"1\":{\"223\":1}}],[\"单个变量操作\",{\"0\":{\"91\":1}}],[\"单次暂停时间特别长\",{\"1\":{\"178\":1}}],[\"单线程收集器\",{\"1\":{\"159\":2}}],[\"单线程\",{\"1\":{\"159\":2,\"161\":1}}],[\"吞吐量优先\",{\"0\":{\"160\":1}}],[\"吞吐量\",{\"1\":{\"158\":2}}],[\"收集所有\",{\"1\":{\"197\":2}}],[\"收集\",{\"1\":{\"158\":1}}],[\"收集器处理对象的过程中\",{\"1\":{\"168\":1}}],[\"收集器串行的收集\",{\"1\":{\"166\":1}}],[\"收集器使用两个参数控制吞吐量\",{\"1\":{\"160\":1}}],[\"收集器可设置\",{\"1\":{\"160\":1}}],[\"收集器最重要的一个区别\",{\"1\":{\"160\":1}}],[\"收集器类似\",{\"1\":{\"160\":1}}],[\"收集器一样存在\",{\"1\":{\"159\":1}}],[\"收集器默认开启的收集线程数与cpu的数量相同\",{\"1\":{\"159\":1}}],[\"收集器其实就是\",{\"1\":{\"159\":1}}],[\"收集器进行垃圾回收时\",{\"1\":{\"159\":1}}],[\"收集器由于没有线程交互的开销\",{\"1\":{\"159\":1}}],[\"收集器是最基本的\",{\"1\":{\"159\":1}}],[\"收集器\",{\"1\":{\"159\":2,\"160\":2,\"161\":5,\"162\":1}}],[\"收集器搭配使用作为cms收集器的后备方案简单\",{\"1\":{\"158\":1}}],[\"收集器的内存回收过程是与用户线程一起并发执行的\",{\"1\":{\"161\":1}}],[\"收集器的多线程版本\",{\"1\":{\"159\":1}}],[\"收集器的多线程版本新生代采用标记\",{\"1\":{\"158\":1}}],[\"收集器的老年代版本\",{\"1\":{\"160\":2}}],[\"收集器的老年代版本标记\",{\"1\":{\"158\":1}}],[\"收集器的老年代标记\",{\"1\":{\"158\":1}}],[\"基准测试请参考\",{\"1\":{\"253\":1}}],[\"基本类型和字符串\",{\"1\":{\"237\":2}}],[\"基本类型和其包装类型的相互转换过程\",{\"1\":{\"218\":1}}],[\"基本类型那么最终生成的字节码是\",{\"1\":{\"219\":1}}],[\"基本类型赋值给包装类型\",{\"1\":{\"218\":1}}],[\"基本类型转包装类型→装箱\",{\"1\":{\"218\":1}}],[\"基本无空间碎片可能存在空间浪费\",{\"1\":{\"158\":1}}],[\"基于复制算法的垃圾回收器\",{\"1\":{\"161\":1}}],[\"基于标记\",{\"1\":{\"161\":2}}],[\"基于aqs实现\",{\"1\":{\"88\":1}}],[\"默认\",{\"1\":{\"254\":1}}],[\"默认就是应用程序类加载器\",{\"1\":{\"248\":1}}],[\"默认构造器\",{\"0\":{\"217\":1}}],[\"默认启用\",{\"1\":{\"170\":1}}],[\"默认45\",{\"1\":{\"164\":1}}],[\"默认的暂停目标是\",{\"1\":{\"162\":1}}],[\"默认200ms\",{\"1\":{\"160\":1}}],[\"默认收集器在注重吞吐量及cpu资源的场合吞吐量高\",{\"1\":{\"158\":1}}],[\"默认是4g\",{\"1\":{\"115\":1}}],[\"效率高\",{\"1\":{\"158\":1}}],[\"历史最悠久的单线程垃圾收集器\",{\"1\":{\"158\":1}}],[\"垃圾短信\",{\"1\":{\"272\":1}}],[\"垃圾收集器花掉1分钟\",{\"1\":{\"158\":1}}],[\"垃圾收集器特点算法适用场景优点缺点serial最基本\",{\"1\":{\"158\":1}}],[\"垃圾收集时间\",{\"1\":{\"158\":1}}],[\"垃圾回收调优\",{\"0\":{\"172\":1}}],[\"垃圾回收器\",{\"0\":{\"158\":1}}],[\"垃圾回收算法\",{\"0\":{\"148\":1}}],[\"垃圾回收\",{\"0\":{\"127\":1},\"1\":{\"115\":1,\"127\":1,\"162\":1}}],[\"垃圾回收是否涉及栈内存\",{\"1\":{\"108\":1}}],[\"某个线程的内存溢出了而抛异常\",{\"1\":{\"157\":1}}],[\"遇到一个较大的对象时\",{\"1\":{\"156\":1}}],[\"前面例子体现的实际就是可见性\",{\"1\":{\"263\":1}}],[\"前面\",{\"1\":{\"254\":1}}],[\"前追加\",{\"1\":{\"240\":1}}],[\"前后的内存占用\",{\"1\":{\"175\":1}}],[\"前\",{\"1\":{\"155\":1,\"203\":1}}],[\"动态生成的新实现代替本地实现\",{\"1\":{\"254\":1}}],[\"动态性\",{\"1\":{\"243\":1}}],[\"动态设置这些参数以提供最优的停顿时间和最高的吞吐量\",{\"1\":{\"160\":1}}],[\"动态\",{\"1\":{\"155\":1}}],[\"触发\",{\"1\":{\"153\":1}}],[\"幸存区需要能够保存\",{\"1\":{\"176\":1}}],[\"幸存区等进行混合收集\",{\"1\":{\"162\":1}}],[\"幸存区\",{\"1\":{\"162\":1,\"163\":2}}],[\"幸存区比例\",{\"1\":{\"155\":1}}],[\"幸存区from\",{\"1\":{\"152\":1}}],[\"幸存区to\",{\"1\":{\"152\":1}}],[\"复制一份\",{\"1\":{\"215\":1}}],[\"复制一份栈顶\",{\"1\":{\"215\":1}}],[\"复制算法\",{\"1\":{\"161\":1}}],[\"复制算法服务端应用\",{\"1\":{\"158\":1}}],[\"复制算法jdk1\",{\"1\":{\"158\":1}}],[\"复制算法的多线程收集器\",{\"1\":{\"158\":1}}],[\"复制算法运行在\",{\"1\":{\"158\":2}}],[\"复制\",{\"0\":{\"151\":1},\"1\":{\"162\":1}}],[\"复制到\",{\"1\":{\"131\":1,\"153\":1}}],[\"速度较本地实现快\",{\"1\":{\"254\":1}}],[\"速度很快但是仍存在\",{\"1\":{\"161\":1}}],[\"速度慢\",{\"1\":{\"150\":1}}],[\"速度快\",{\"1\":{\"149\":1}}],[\"连续的空间就更多\",{\"1\":{\"150\":1}}],[\"缺点是synchronized是属于重量级操作\",{\"1\":{\"262\":1}}],[\"缺点是数据存储了两份\",{\"1\":{\"131\":1}}],[\"缺点\",{\"1\":{\"149\":1,\"150\":1,\"151\":1,\"169\":1}}],[\"优点\",{\"1\":{\"149\":1,\"150\":1,\"151\":1,\"169\":1}}],[\"给出了\",{\"1\":{\"216\":1}}],[\"给对象分配堆内存\",{\"1\":{\"198\":1}}],[\"给对象上锁\",{\"1\":{\"70\":1}}],[\"给用户带来更好的体验等场景下\",{\"1\":{\"161\":1}}],[\"给\",{\"1\":{\"155\":1}}],[\"给堆内存腾出相应的空间\",{\"1\":{\"149\":1}}],[\"换为了\",{\"1\":{\"147\":1}}],[\"遍历引用队列\",{\"1\":{\"146\":1}}],[\"从数十亿个垃圾邮件列表中判断某邮箱是否是垃圾邮件\",{\"1\":{\"272\":1}}],[\"从jvm规范中可以看到synchonized在jvm里的实现原理\",{\"1\":{\"258\":1}}],[\"从0开始算\",{\"1\":{\"254\":1}}],[\"从字节码分析\",{\"1\":{\"238\":1}}],[\"从字节码角度分析\",{\"1\":{\"193\":1}}],[\"从代码中的赋值语句中就可以看出来\",{\"1\":{\"221\":1}}],[\"从\",{\"1\":{\"205\":1,\"223\":1,\"224\":1,\"258\":1}}],[\"从操作数栈弹掉了😂\",{\"1\":{\"198\":1}}],[\"从队列中获取无用的\",{\"1\":{\"146\":1}}],[\"从而获取类的各种信息\",{\"1\":{\"230\":1}}],[\"从而不会影响其他线程的运行\",{\"1\":{\"157\":1}}],[\"从而提高了效率\",{\"1\":{\"131\":1}}],[\"从而减少了锁操作的开销\",{\"1\":{\"85\":1}}],[\"从而将其消除的优化过程\",{\"1\":{\"85\":1}}],[\"从而防止数据竞争和不一致\",{\"1\":{\"59\":1}}],[\"搭配引用队列\",{\"1\":{\"146\":1}}],[\"入队\",{\"1\":{\"144\":1,\"145\":1}}],[\"仍会执行重复的解释\",{\"1\":{\"251\":1}}],[\"仍是\",{\"1\":{\"222\":1}}],[\"仍然保留了方法参数泛型的信息\",{\"1\":{\"220\":1}}],[\"仍然存在\",{\"1\":{\"161\":1}}],[\"仍处于等待状态\",{\"1\":{\"158\":1}}],[\"仍不足时会再次出发垃圾回收\",{\"1\":{\"142\":1}}],[\"仍需进入\",{\"1\":{\"60\":1}}],[\"仅此一次\",{\"1\":{\"263\":1}}],[\"仅用在一个写线程\",{\"1\":{\"263\":1}}],[\"仅对\",{\"1\":{\"227\":1}}],[\"仅\",{\"1\":{\"224\":1}}],[\"仅有\",{\"1\":{\"142\":1,\"143\":1}}],[\"仅是常量池中的符号\",{\"1\":{\"123\":1}}],[\"强引用\",{\"1\":{\"141\":1}}],[\"五种引用\",{\"0\":{\"140\":1}}],[\"第一次调用\",{\"1\":{\"238\":1}}],[\"第一遍是根据字符串的\",{\"1\":{\"223\":1}}],[\"第一个用来匹配字符串\",{\"1\":{\"223\":1}}],[\"第一步\",{\"1\":{\"139\":1}}],[\"第\",{\"1\":{\"182\":34}}],[\"第三方缓存实现\",{\"1\":{\"175\":1}}],[\"第三步\",{\"1\":{\"139\":1}}],[\"第二遍才是利用\",{\"1\":{\"223\":1}}],[\"第二个用来根据x的值来决定输出语句\",{\"1\":{\"223\":1}}],[\"第二次\",{\"1\":{\"145\":1}}],[\"第二步\",{\"1\":{\"139\":1}}],[\"命令转储文件\",{\"1\":{\"139\":1}}],[\"命令\",{\"1\":{\"139\":1}}],[\"持有的对象\",{\"1\":{\"138\":1}}],[\"引用局部变量的匿名内部类\",{\"1\":{\"228\":1}}],[\"引用了常量池中\",{\"1\":{\"182\":5}}],[\"引用队列会根据它\",{\"1\":{\"145\":1}}],[\"引用队列\",{\"1\":{\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1}}],[\"引用该对象时\",{\"1\":{\"142\":1,\"143\":1}}],[\"引用该对象\",{\"1\":{\"141\":1}}],[\"引用的对象\",{\"1\":{\"138\":1}}],[\"引用计数法\",{\"0\":{\"135\":1}}],[\"扫描堆中的对象\",{\"1\":{\"137\":1}}],[\"循环的\",{\"1\":{\"251\":1}}],[\"循环写法\",{\"1\":{\"222\":1}}],[\"循环\",{\"0\":{\"222\":1},\"1\":{\"195\":3}}],[\"循环控制指令\",{\"0\":{\"195\":1}}],[\"循环结束\",{\"1\":{\"146\":1}}],[\"循环引用时\",{\"0\":{\"136\":1}}],[\"循环栅栏\",{\"1\":{\"98\":1}}],[\"老年代充裕情况下\",{\"1\":{\"178\":1}}],[\"老年代调优\",{\"0\":{\"177\":1}}],[\"老年代被划为一个个卡表\",{\"1\":{\"167\":1}}],[\"老年代引用新生代\",{\"1\":{\"167\":1}}],[\"老年代所占内存超过阈值\",{\"1\":{\"166\":1}}],[\"老年代内存占比有所降低\",{\"1\":{\"176\":1}}],[\"老年代内存不足\",{\"1\":{\"166\":2}}],[\"老年代内存不足发生的垃圾收集\",{\"1\":{\"166\":2}}],[\"老年代内存\",{\"1\":{\"162\":1}}],[\"老年代由于浮动垃圾过多\",{\"1\":{\"161\":1}}],[\"老年代没有幸存区\",{\"1\":{\"160\":1}}],[\"老年代serialold\",{\"1\":{\"159\":1}}],[\"老年代标记整理\",{\"0\":{\"159\":1}}],[\"老年代\",{\"1\":{\"133\":1,\"161\":1,\"162\":1,\"163\":2}}],[\"调优领域\",{\"0\":{\"173\":1}}],[\"调优时\",{\"1\":{\"133\":1}}],[\"调用本地实现\",{\"1\":{\"254\":1}}],[\"调用了线程上下文类加载器完成类加载\",{\"1\":{\"248\":1}}],[\"调用了对象的\",{\"1\":{\"78\":1}}],[\"调用父类的\",{\"1\":{\"243\":1}}],[\"调用父类中的方法\",{\"1\":{\"225\":1}}],[\"调用父类方法\",{\"1\":{\"198\":1}}],[\"调用构造函数\",{\"1\":{\"225\":1}}],[\"调用一个静态方法\",{\"1\":{\"198\":1}}],[\"调用该对象的构造方法\",{\"1\":{\"198\":1}}],[\"调用以后\",{\"1\":{\"145\":1}}],[\"调用run方法\",{\"1\":{\"132\":1}}],[\"调用release\",{\"1\":{\"95\":1}}],[\"调用字符串对象的intern方法\",{\"1\":{\"123\":1,\"125\":1}}],[\"调用后当前线程就会挂起\",{\"1\":{\"101\":1}}],[\"调用对象\",{\"0\":{\"78\":1}}],[\"调用者线程进入\",{\"1\":{\"61\":1}}],[\"调用\",{\"0\":{\"80\":1},\"1\":{\"60\":1,\"198\":1,\"227\":1}}],[\"失效\",{\"1\":{\"133\":1}}],[\"失败\",{\"1\":{\"83\":2,\"84\":1}}],[\"手动\",{\"1\":{\"133\":2}}],[\"开始新增了对需要关闭的资源处理的特殊语法\",{\"1\":{\"226\":1}}],[\"开始\",{\"1\":{\"223\":1,\"224\":1}}],[\"开始引入的语法糖\",{\"1\":{\"222\":1}}],[\"开始加入的新特性\",{\"1\":{\"221\":1}}],[\"开始加入的特性\",{\"1\":{\"219\":1}}],[\"开始加入的\",{\"1\":{\"218\":1}}],[\"开始释放\",{\"1\":{\"133\":2}}],[\"开启串行回收器\",{\"1\":{\"159\":1}}],[\"开车不能玩手机\",{\"1\":{\"64\":1}}],[\"虚方法表\",{\"1\":{\"230\":1}}],[\"虚引用\",{\"1\":{\"132\":1,\"144\":1}}],[\"虚拟机调优\",{\"1\":{\"263\":1}}],[\"虚拟机加载\",{\"1\":{\"239\":1}}],[\"虚拟机中的唯一性\",{\"1\":{\"239\":1}}],[\"虚拟机中执行编译的方法\",{\"1\":{\"121\":1}}],[\"虚拟机会保证这个类的\",{\"1\":{\"236\":1}}],[\"虚拟机会根据系统的运行状况收集性能监控信息\",{\"1\":{\"160\":1}}],[\"虚拟机可见\",{\"1\":{\"227\":1}}],[\"虚拟机共运行100分钟\",{\"1\":{\"158\":1}}],[\"虚拟机指令根据这张常量表找到要执行的类名\",{\"1\":{\"122\":1}}],[\"虚拟机线程之间共享的方法区域\",{\"1\":{\"118\":1}}],[\"虚拟机有一个在所有\",{\"1\":{\"118\":1}}],[\"虚拟机栈\",{\"0\":{\"107\":1},\"1\":{\"138\":1}}],[\"虚拟机\",{\"1\":{\"104\":1,\"119\":1}}],[\"申请内存\",{\"1\":{\"132\":1}}],[\"造成了不必要的复制\",{\"1\":{\"131\":1}}],[\"需要说明的是\",{\"1\":{\"273\":1}}],[\"需要该集合类实现了\",{\"1\":{\"222\":1}}],[\"需要将\",{\"1\":{\"219\":2}}],[\"需要保留的\",{\"1\":{\"168\":1}}],[\"需要切换到内核态\",{\"1\":{\"131\":1}}],[\"需要转换\",{\"1\":{\"110\":1}}],[\"分别是我们要预计插入的数据和我们所期望的误判率\",{\"1\":{\"275\":1}}],[\"分别放入\",{\"1\":{\"212\":1}}],[\"分数越高的更好\",{\"1\":{\"253\":1}}],[\"分层编译\",{\"0\":{\"251\":1}}],[\"分两次压入\",{\"1\":{\"192\":1}}],[\"分区则是将堆空间划分连续几个不同小区间\",{\"1\":{\"163\":1}}],[\"分代是按对象的生命周期划分\",{\"1\":{\"163\":1}}],[\"分代垃圾回收\",{\"0\":{\"152\":1}}],[\"分析对象头\",{\"1\":{\"199\":1,\"207\":1}}],[\"分析过程\",{\"1\":{\"182\":1}}],[\"分析的\",{\"1\":{\"139\":1}}],[\"分析\",{\"0\":{\"139\":1,\"154\":1,\"193\":1},\"1\":{\"193\":1,\"253\":1}}],[\"分配空间在准备阶段完成\",{\"1\":{\"233\":1}}],[\"分配\",{\"1\":{\"192\":1}}],[\"分配栈帧内存\",{\"0\":{\"191\":1}}],[\"分配内存\",{\"1\":{\"155\":1}}],[\"分配完毕\",{\"1\":{\"133\":2}}],[\"分配回收成本较高\",{\"1\":{\"130\":1}}],[\"分类为\",{\"1\":{\"27\":1,\"281\":1}}],[\"常见于\",{\"1\":{\"243\":1}}],[\"常见于nio操作时\",{\"1\":{\"130\":1}}],[\"常用在框架设计\",{\"1\":{\"243\":1}}],[\"常量池也属于方法区\",{\"1\":{\"189\":1}}],[\"常量池载入运行时常量池\",{\"0\":{\"189\":1}}],[\"常量池中的信息\",{\"1\":{\"123\":1}}],[\"常量池中的字符串仅是符号\",{\"1\":{\"123\":1}}],[\"常量池与串池stringtable的关系\",{\"0\":{\"123\":1}}],[\"常量池是\",{\"1\":{\"122\":1}}],[\"常量池\",{\"0\":{\"182\":1},\"1\":{\"121\":1,\"122\":1,\"192\":1}}],[\"直接执行\",{\"1\":{\"251\":1}}],[\"直接设置吞吐量的大小\",{\"1\":{\"160\":1}}],[\"直接内存被\",{\"1\":{\"133\":1}}],[\"直接内存回收原理\",{\"0\":{\"133\":1}}],[\"直接内存的回收机制总结\",{\"1\":{\"132\":1}}],[\"直接内存的回收不是通过jvm的垃圾回收来释放的\",{\"1\":{\"132\":1}}],[\"直接内存释放原理\",{\"1\":{\"132\":1}}],[\"直接内存是操作系统和\",{\"1\":{\"131\":1}}],[\"直接内存\",{\"0\":{\"129\":1},\"1\":{\"133\":1,\"144\":1}}],[\"直到它结束\",{\"1\":{\"159\":1}}],[\"直到它被其他线程通过调用locksupport\",{\"1\":{\"101\":1}}],[\"直到另一个线程唤醒它或者当前时间超过了指定的截止时间\",{\"1\":{\"101\":1}}],[\"直到另一个线程唤醒它或者超过指定的纳秒时间\",{\"1\":{\"101\":1}}],[\"直到另一个线程调用locksupport\",{\"1\":{\"101\":1}}],[\"直到其他线程释放许可\",{\"1\":{\"95\":1}}],[\"直到锁被释放\",{\"1\":{\"87\":1}}],[\"直到\",{\"1\":{\"61\":1}}],[\"位置被共用\",{\"1\":{\"210\":1}}],[\"位置\",{\"0\":{\"126\":1}}],[\"再看\",{\"1\":{\"246\":1}}],[\"再比如\",{\"1\":{\"195\":1}}],[\"再将活跃对象复制到幸存区to中\",{\"1\":{\"153\":1}}],[\"再回收不被gc\",{\"1\":{\"151\":1}}],[\"再由\",{\"1\":{\"145\":1}}],[\"再次比较\",{\"1\":{\"223\":1}}],[\"再次创建对象\",{\"1\":{\"153\":1}}],[\"再次转储\",{\"1\":{\"139\":1}}],[\"再次设置为\",{\"1\":{\"94\":1}}],[\"再放入到串池中\",{\"1\":{\"125\":1}}],[\"答\",{\"1\":{\"124\":1}}],[\"无法对外提供服务\",{\"1\":{\"269\":1}}],[\"无法直接访问\",{\"1\":{\"239\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"158\":1}}],[\"无返回值\",{\"1\":{\"182\":2}}],[\"无需再编译\",{\"1\":{\"251\":1}}],[\"无需手动编码\",{\"1\":{\"145\":1}}],[\"无需将代码从系统内存复制到\",{\"1\":{\"131\":1}}],[\"无论通过哪种方法\",{\"1\":{\"205\":1}}],[\"无论内存是否充足\",{\"1\":{\"143\":1}}],[\"无论放入是否成功\",{\"1\":{\"123\":1,\"125\":1}}],[\"无效\",{\"1\":{\"133\":1}}],[\"无锁\",{\"1\":{\"87\":1}}],[\"存在于e\",{\"1\":{\"167\":1}}],[\"存在于堆内存之中\",{\"1\":{\"123\":1}}],[\"存活的对象年龄加\",{\"1\":{\"153\":1}}],[\"存活的对象使用\",{\"1\":{\"153\":1}}],[\"存入堆中\",{\"1\":{\"115\":1}}],[\"栗子3\",{\"1\":{\"123\":1}}],[\"栗子2\",{\"1\":{\"123\":1}}],[\"栗子1\",{\"1\":{\"123\":1}}],[\"最快的\",{\"0\":{\"175\":1}}],[\"最终标记\",{\"1\":{\"165\":1}}],[\"最终stringtable\",{\"1\":{\"123\":1}}],[\"最短\",{\"1\":{\"160\":1,\"161\":1}}],[\"最大值范围的数会被放到运行时常量池中\",{\"1\":{\"192\":1}}],[\"最大表示2进制1111\",{\"1\":{\"153\":1}}],[\"最大寿命是15\",{\"1\":{\"153\":1}}],[\"最大堆空间的jvm虚拟机参数\",{\"1\":{\"115\":1}}],[\"最后数据库没有查询出该内容\",{\"1\":{\"269\":1}}],[\"最后在把数据返回给我们的页面\",{\"1\":{\"269\":1}}],[\"最后再看看\",{\"1\":{\"195\":1}}],[\"最后就会造成内存溢出问题\",{\"1\":{\"149\":1}}],[\"最后的tostring方法的返回值是一个新的字符串\",{\"1\":{\"123\":1}}],[\"最少设置为\",{\"1\":{\"128\":1}}],[\"还能够进行常量折叠\",{\"1\":{\"252\":1}}],[\"还用到了\",{\"1\":{\"223\":1}}],[\"还要额外做一个类型转换的操作\",{\"1\":{\"219\":1}}],[\"还是会执行finally\",{\"1\":{\"213\":1}}],[\"还是\",{\"1\":{\"193\":1}}],[\"还是并发地进行清理\",{\"1\":{\"166\":1}}],[\"还有一个执行\",{\"1\":{\"198\":1}}],[\"还有一个值得关注的点是\",{\"1\":{\"160\":1}}],[\"还有其他的idea插件可以直接查看\",{\"1\":{\"185\":1}}],[\"还未处理的\",{\"1\":{\"168\":1}}],[\"还会回收幸存区中的垃圾\",{\"1\":{\"153\":1}}],[\"还没有成为java字符串\",{\"1\":{\"123\":1}}],[\"还不会编写\",{\"1\":{\"10\":1}}],[\"利用串池的机制\",{\"1\":{\"123\":1}}],[\"特性\",{\"1\":{\"123\":1}}],[\"特点\",{\"1\":{\"106\":1,\"159\":4,\"160\":4,\"161\":2}}],[\"字段优化\",{\"0\":{\"253\":1}}],[\"字段和方法数据\",{\"1\":{\"118\":1}}],[\"字节就是对象的\",{\"1\":{\"203\":1}}],[\"字节是\",{\"1\":{\"203\":1}}],[\"字节码\",{\"1\":{\"216\":1}}],[\"字节码的过程中\",{\"1\":{\"216\":1}}],[\"字节码是\",{\"1\":{\"195\":1}}],[\"字节码指令\",{\"0\":{\"184\":1},\"1\":{\"184\":1,\"256\":1}}],[\"字节\",{\"1\":{\"180\":1,\"181\":1,\"182\":1,\"194\":1,\"203\":1,\"204\":1}}],[\"字符串的匹配用到了字符串的\",{\"1\":{\"223\":1}}],[\"字符串\",{\"0\":{\"223\":1}}],[\"字符串去重关注的是char\",{\"1\":{\"169\":1}}],[\"字符串对象的创建都是懒惰的\",{\"1\":{\"123\":1}}],[\"字符串对象\",{\"1\":{\"123\":3}}],[\"字符串常量拼接的原理是编译器优化\",{\"1\":{\"123\":1}}],[\"字符串变量拼接的原理是stringbuilder\",{\"1\":{\"123\":1}}],[\"字面量等信息\",{\"1\":{\"122\":1}}],[\"框内的是真正编译执行的内容\",{\"1\":{\"121\":1}}],[\"输入刚才的\",{\"1\":{\"205\":1}}],[\"输入完成后\",{\"1\":{\"121\":1}}],[\"输入\",{\"1\":{\"121\":1,\"202\":1,\"205\":1,\"241\":1}}],[\"输出为0\",{\"1\":{\"258\":1}}],[\"输出为10\",{\"1\":{\"214\":1}}],[\"输出\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"132\":1,\"226\":1,\"241\":2}}],[\"获得该集合的迭代器\",{\"1\":{\"222\":1}}],[\"获得对应类的\",{\"1\":{\"121\":1}}],[\"获取静态变量i的值\",{\"1\":{\"256\":8,\"263\":2}}],[\"获取线程上下文类加载器\",{\"1\":{\"248\":1}}],[\"获取进程\",{\"1\":{\"200\":1}}],[\"获取\",{\"1\":{\"95\":1,\"263\":5}}],[\"之前是无法编译通过的\",{\"1\":{\"218\":1}}],[\"之前执行了\",{\"1\":{\"198\":1}}],[\"之前需要使用\",{\"1\":{\"171\":1}}],[\"之前c未被引用\",{\"1\":{\"168\":1}}],[\"之前会导致永久代内存溢出\",{\"1\":{\"120\":1}}],[\"之后会导致元空间内存溢出\",{\"1\":{\"120\":1}}],[\"之后检查\",{\"1\":{\"76\":1}}],[\"之后\",{\"1\":{\"70\":1,\"240\":1}}],[\"永久代用的堆内存\",{\"1\":{\"119\":1}}],[\"段\",{\"1\":{\"118\":1}}],[\"工程\",{\"1\":{\"253\":1}}],[\"工作内存\",{\"1\":{\"254\":1}}],[\"工作与老年代\",{\"1\":{\"160\":1}}],[\"工作于新生代\",{\"1\":{\"160\":1}}],[\"工作在老年代\",{\"1\":{\"159\":1,\"161\":1}}],[\"工作在新生代\",{\"1\":{\"159\":1,\"161\":1}}],[\"工具查看\",{\"1\":{\"230\":1,\"254\":1}}],[\"工具来反编译\",{\"1\":{\"185\":1}}],[\"工具进行分析\",{\"1\":{\"139\":1}}],[\"工具\",{\"0\":{\"201\":1},\"1\":{\"116\":3,\"205\":1,\"216\":1}}],[\"工厂类\",{\"1\":{\"92\":1}}],[\"结构中有\",{\"1\":{\"207\":1}}],[\"结果永远是旧值\",{\"1\":{\"260\":1}}],[\"结果是\",{\"1\":{\"256\":1}}],[\"结果中第二行\",{\"1\":{\"204\":1}}],[\"结果为\",{\"1\":{\"196\":1}}],[\"结果为false\",{\"1\":{\"123\":1}}],[\"结果在压入操作数栈中\",{\"1\":{\"192\":1}}],[\"结果已在编译期确定为ab\",{\"1\":{\"123\":1}}],[\"结果\",{\"1\":{\"115\":1,\"227\":1}}],[\"结合使用\",{\"1\":{\"59\":1}}],[\"堆中有一份\",{\"1\":{\"131\":1}}],[\"堆中对象都需要考虑线程安全的问题\",{\"1\":{\"114\":1}}],[\"堆内存较大\",{\"1\":{\"160\":1,\"161\":1}}],[\"堆内存小\",{\"1\":{\"159\":1}}],[\"堆内存不足\",{\"1\":{\"146\":1}}],[\"堆内存\",{\"1\":{\"131\":1}}],[\"堆内存中\",{\"1\":{\"131\":1}}],[\"堆内存溢出\",{\"1\":{\"115\":1}}],[\"堆\",{\"0\":{\"112\":1}}],[\"所占的空间多少\",{\"1\":{\"273\":1}}],[\"所占空间越大\",{\"1\":{\"273\":1}}],[\"所谓的内联就是把方法内代码拷贝\",{\"1\":{\"252\":1}}],[\"所谓的双亲委派\",{\"1\":{\"242\":1}}],[\"所谓的\",{\"1\":{\"216\":1}}],[\"所指示行号\",{\"1\":{\"209\":1}}],[\"所属类\",{\"1\":{\"182\":3}}],[\"所用时间远小于\",{\"1\":{\"176\":1}}],[\"所需要参数开启\",{\"1\":{\"162\":1}}],[\"所有的\",{\"1\":{\"176\":1}}],[\"所有对象都经过并发标记后\",{\"1\":{\"170\":1}}],[\"所有被同步锁\",{\"1\":{\"138\":1}}],[\"所有等待获取锁的线程都会被挂起\",{\"1\":{\"87\":1}}],[\"所以x不应该再发生变化了\",{\"1\":{\"228\":1}}],[\"所以调用\",{\"1\":{\"219\":1}}],[\"所以在取值时\",{\"1\":{\"219\":1}}],[\"所以不要在finally中进行返回操作\",{\"1\":{\"213\":1}}],[\"所以局部变量表\",{\"1\":{\"210\":1}}],[\"所以虚拟机需要调用invokevirtual指令\",{\"1\":{\"199\":1}}],[\"所以会将两个数弹出操作数栈来进行运算\",{\"1\":{\"196\":1}}],[\"所以只有一个垃圾回收线程\",{\"1\":{\"159\":1}}],[\"所以\",{\"1\":{\"146\":1,\"192\":1}}],[\"所以我们就通过\",{\"1\":{\"133\":1}}],[\"所以可以适当增加hashtable桶的个数\",{\"1\":{\"128\":1}}],[\"所以需要使用stringbuilder来创建\",{\"1\":{\"123\":1}}],[\"所以需要用到本地方法\",{\"1\":{\"111\":1}}],[\"所以进行的操作和\",{\"1\":{\"123\":1}}],[\"所以s5直接从串池中获取值\",{\"1\":{\"123\":1}}],[\"刚才的\",{\"1\":{\"253\":1}}],[\"刚才通过ps命令看到的tid来对比定位\",{\"1\":{\"110\":1}}],[\"刚才通过top查到的进程号\",{\"1\":{\"110\":1}}],[\"刚开始\",{\"1\":{\"71\":1,\"94\":1}}],[\"案例3\",{\"1\":{\"178\":1}}],[\"案例2\",{\"1\":{\"178\":1}}],[\"案例1\",{\"1\":{\"178\":1}}],[\"案例\",{\"0\":{\"178\":1},\"1\":{\"110\":1,\"115\":1}}],[\"过程说明\",{\"1\":{\"223\":1}}],[\"过多\",{\"1\":{\"109\":1}}],[\"过多导致栈内存溢出\",{\"1\":{\"109\":1}}],[\"过大导致栈内存溢出\",{\"1\":{\"109\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"138\":1}}],[\"栈帧过大\",{\"1\":{\"109\":1}}],[\"栈帧\",{\"1\":{\"109\":2,\"192\":1}}],[\"栈内存溢出\",{\"0\":{\"109\":1},\"1\":{\"109\":1}}],[\"栈内存越大\",{\"1\":{\"108\":1}}],[\"栈内存分配越大越好吗\",{\"1\":{\"108\":1}}],[\"栈内存是方法调用产生的\",{\"1\":{\"108\":1}}],[\"解决办法\",{\"0\":{\"261\":1}}],[\"解决并发问题\",{\"1\":{\"258\":1}}],[\"解决方法\",{\"0\":{\"257\":1}}],[\"解锁隐藏参数\",{\"1\":{\"252\":1}}],[\"解锁时\",{\"1\":{\"83\":2}}],[\"解释器\",{\"1\":{\"251\":1}}],[\"解释器会解释指令为机器码交给\",{\"1\":{\"106\":1}}],[\"解释执行\",{\"1\":{\"251\":1}}],[\"解析的含义\",{\"1\":{\"234\":1}}],[\"解析\",{\"0\":{\"234\":1}}],[\"寄存器\",{\"1\":{\"106\":1,\"254\":1}}],[\"程序结束\",{\"1\":{\"192\":1}}],[\"程序\",{\"1\":{\"161\":1}}],[\"程序运行时的额外执行负载高\",{\"1\":{\"158\":1}}],[\"程序计数器会记录下一条指令的地址行号\",{\"1\":{\"106\":1}}],[\"程序计数器\",{\"0\":{\"105\":1},\"1\":{\"106\":1}}],[\"程序的行为符合预期\",{\"1\":{\"65\":1}}],[\"新增了枚举类\",{\"1\":{\"225\":1}}],[\"新生代内存设置为内容纳\",{\"1\":{\"176\":1}}],[\"新生代内存太大\",{\"1\":{\"176\":1}}],[\"新生代内存太小\",{\"1\":{\"176\":1}}],[\"新生代内存越大越好么\",{\"1\":{\"176\":1}}],[\"新生代内存不足发生的垃圾收集\",{\"1\":{\"166\":4}}],[\"新生代的特点\",{\"1\":{\"176\":1}}],[\"新生代调优\",{\"0\":{\"176\":1}}],[\"新生代回收时间略微增加\",{\"1\":{\"169\":1}}],[\"新生代回收的跨代引用\",{\"1\":{\"167\":1}}],[\"新生代回收+并发标记\",{\"1\":{\"162\":1}}],[\"新生代收集会产生\",{\"1\":{\"163\":1}}],[\"新生代存在\",{\"1\":{\"163\":1}}],[\"新生代垃圾收集同时会执行一些并发的标记\",{\"1\":{\"162\":1}}],[\"新生代伊甸园垃圾回收\",{\"1\":{\"162\":1}}],[\"新生代\",{\"1\":{\"161\":1,\"167\":1}}],[\"新生代放不下去\",{\"1\":{\"161\":1}}],[\"新生代serial\",{\"1\":{\"159\":1}}],[\"新生代复制\",{\"0\":{\"159\":1}}],[\"新生代采用标记\",{\"1\":{\"158\":1}}],[\"新生代和老年代的情况\",{\"1\":{\"155\":1}}],[\"新生代空间不足时\",{\"1\":{\"153\":1}}],[\"新生代有划分为伊甸园\",{\"1\":{\"152\":1}}],[\"新线程启动后会打印一条消息\",{\"1\":{\"101\":1}}],[\"新建的对象也是不可偏向的\",{\"1\":{\"82\":1}}],[\"稍等一下\",{\"1\":{\"101\":1}}],[\"然而\",{\"1\":{\"101\":1}}],[\"然后我们编写代码\",{\"1\":{\"274\":1}}],[\"然后我们输入一个集合\",{\"1\":{\"273\":1}}],[\"然后在用\",{\"1\":{\"275\":1}}],[\"然后在存储到redis中\",{\"1\":{\"269\":1}}],[\"然后在将系统缓冲区数据\",{\"1\":{\"131\":1}}],[\"然后从数据库中查询我们的博客详情后\",{\"1\":{\"269\":1}}],[\"然后通过该key去请求后台\",{\"1\":{\"269\":1}}],[\"然后通过uid获取redis中缓存的文章详情\",{\"1\":{\"269\":1}}],[\"然后通过博客的uid进行获取\",{\"1\":{\"269\":1}}],[\"然后博客详情页中的内容假设是存储在redis中的\",{\"1\":{\"269\":1}}],[\"然后让应用类加载器去找\",{\"1\":{\"242\":1}}],[\"然后压入栈中\",{\"1\":{\"215\":1}}],[\"然后退化成\",{\"1\":{\"166\":1}}],[\"然后收集结束\",{\"1\":{\"162\":1}}],[\"然后交换from和to\",{\"1\":{\"151\":1}}],[\"然后整理剩余的对象\",{\"1\":{\"150\":1}}],[\"然后垃圾收集器根据标识清除相应的内容\",{\"1\":{\"149\":1}}],[\"然后运行\",{\"1\":{\"146\":1}}],[\"然后调用被引用对象的finalize方法\",{\"1\":{\"145\":1}}],[\"然后调用它的clean方法来释放直接内存\",{\"1\":{\"144\":1}}],[\"然后调用park方法进入等待状态\",{\"1\":{\"101\":1}}],[\"然后将放在该队列中的对象重新处理\",{\"1\":{\"168\":1}}],[\"然后将\",{\"1\":{\"139\":1}}],[\"然后使用\",{\"1\":{\"139\":1}}],[\"然后读取磁盘文件\",{\"1\":{\"131\":1}}],[\"然后能在控制台看到反编译以后类的信息了\",{\"1\":{\"121\":1}}],[\"然后\",{\"1\":{\"94\":1}}],[\"然后自己进入\",{\"1\":{\"84\":1}}],[\"然后唤醒\",{\"1\":{\"71\":1}}],[\"组成\",{\"0\":{\"119\":1},\"1\":{\"108\":1}}],[\"组合以及异常处理等\",{\"1\":{\"100\":1}}],[\"组件\",{\"0\":{\"22\":1,\"29\":1,\"283\":1},\"1\":{\"29\":1,\"283\":1}}],[\"包下\",{\"1\":{\"246\":1}}],[\"包的\",{\"1\":{\"246\":1}}],[\"包\",{\"1\":{\"245\":1}}],[\"包拷贝到\",{\"1\":{\"241\":1}}],[\"包装类型赋值给基本类型\",{\"1\":{\"218\":1}}],[\"包装类型转基本类型→拆箱\",{\"1\":{\"218\":1}}],[\"包括特殊方法\",{\"1\":{\"118\":1}}],[\"包括任务的串行执行\",{\"1\":{\"100\":1}}],[\"包中的并发工具\",{\"1\":{\"68\":1}}],[\"包中的原子类\",{\"1\":{\"59\":1}}],[\"人满发车\",{\"1\":{\"98\":1}}],[\"喻为\",{\"1\":{\"98\":1}}],[\"个线程可见\",{\"1\":{\"263\":1}}],[\"个线程来获取资源\",{\"1\":{\"94\":1}}],[\"个层次\",{\"1\":{\"251\":1}}],[\"个方法都是谁呢\",{\"1\":{\"205\":1}}],[\"个虚方法的入口地址\",{\"1\":{\"205\":1}}],[\"个虚方法\",{\"1\":{\"205\":1}}],[\"个数\",{\"1\":{\"196\":1}}],[\"个数为2时才会继续执行\",{\"1\":{\"98\":1}}],[\"个空间\",{\"1\":{\"196\":1}}],[\"个字节\",{\"1\":{\"192\":3}}],[\"使得类被启动类加器加载\",{\"1\":{\"240\":1}}],[\"使得其他线程找不到被移动的对象\",{\"1\":{\"159\":1}}],[\"使内存更加紧凑\",{\"1\":{\"150\":1}}],[\"使一组线程到达某个点后继续执行\",{\"1\":{\"98\":1}}],[\"使用f1\",{\"1\":{\"273\":1}}],[\"使用者调用该类加载器的\",{\"1\":{\"243\":1}}],[\"使用反射可以得到\",{\"1\":{\"220\":1}}],[\"使用invokevirtual指令\",{\"1\":{\"198\":1}}],[\"使用前需要设置\",{\"1\":{\"155\":1}}],[\"使用引用队列\",{\"1\":{\"146\":1}}],[\"使用软引用对象\",{\"1\":{\"146\":2}}],[\"使用memory\",{\"0\":{\"139\":1}}],[\"使用了不同的字符串表\",{\"1\":{\"169\":1}}],[\"使用了\",{\"1\":{\"131\":1,\"132\":2}}],[\"使用本地方法进行操作\",{\"1\":{\"131\":1}}],[\"使用直接内存的好处\",{\"0\":{\"131\":1}}],[\"使用拼接字符串变量的方法来创建新的字符串时\",{\"1\":{\"123\":1}}],[\"使用拼接字符串常量的方法来创建新的字符串时\",{\"1\":{\"123\":1}}],[\"使用拼接字符串常量对象的方法创建字符串\",{\"1\":{\"123\":1}}],[\"使用拼接字符串\",{\"1\":{\"123\":1}}],[\"使用结束\",{\"1\":{\"115\":1}}],[\"使用park和unpark的方法可以在没有使用锁的情况下实现线程间的协作\",{\"1\":{\"101\":1}}],[\"使用场景\",{\"1\":{\"68\":1,\"243\":1}}],[\"使用场景及原理\",{\"0\":{\"68\":1}}],[\"使用\",{\"0\":{\"96\":1,\"247\":1,\"274\":1},\"1\":{\"59\":1,\"65\":1,\"79\":1,\"84\":1,\"109\":1,\"120\":2,\"139\":2,\"144\":2,\"145\":1,\"161\":1,\"223\":2,\"224\":1,\"226\":1,\"230\":1,\"238\":1,\"246\":2,\"251\":4,\"254\":1}}],[\"使用指南\",{\"1\":{\"27\":2,\"281\":2},\"2\":{\"2\":1,\"4\":1,\"23\":1,\"30\":1,\"31\":1,\"57\":1,\"284\":1,\"285\":1}}],[\"允许你指定一个阻塞时间\",{\"1\":{\"101\":1}}],[\"允许在并发线程之间交换数据\",{\"1\":{\"99\":1}}],[\"允许一个或多个线程等待一组操作在其他线程中完成\",{\"1\":{\"97\":1}}],[\"允许线程尝试获取许可而不被阻塞\",{\"1\":{\"95\":1}}],[\"创建\",{\"1\":{\"253\":1}}],[\"创建该类的数组不会触发初始化\",{\"1\":{\"237\":1}}],[\"创建该类对象的数组\",{\"1\":{\"237\":1}}],[\"创建了一个额外的类\",{\"1\":{\"228\":1}}],[\"创建了一个空数组\",{\"1\":{\"221\":1}}],[\"创建资源对象\",{\"1\":{\"226\":1}}],[\"创建与回收\",{\"1\":{\"133\":1}}],[\"创建一个计数为1的semaphore\",{\"1\":{\"96\":1}}],[\"创建锁记录\",{\"1\":{\"83\":1}}],[\"返回操作数栈顶元素\",{\"1\":{\"214\":1}}],[\"返回字符串常量池的引用\",{\"1\":{\"124\":1}}],[\"返回\",{\"1\":{\"120\":1}}],[\"返回true\",{\"1\":{\"95\":1}}],[\"返回顶部按钮\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"尝试获取\",{\"1\":{\"95\":1}}],[\"释放锁\",{\"1\":{\"215\":2}}],[\"释放直接内存中占用的内存\",{\"1\":{\"132\":1}}],[\"释放\",{\"1\":{\"95\":1,\"133\":1}}],[\"释放了\",{\"1\":{\"94\":1}}],[\"计算出数组中的地址\",{\"1\":{\"273\":1}}],[\"计数个数\",{\"1\":{\"98\":2}}],[\"计数器减1\",{\"1\":{\"95\":1}}],[\"计数器\",{\"1\":{\"95\":1}}],[\"计划\",{\"1\":{\"19\":2}}],[\"断开原来的\",{\"1\":{\"94\":1}}],[\"接着看\",{\"1\":{\"248\":1}}],[\"接\",{\"1\":{\"94\":1}}],[\"接下来禁用\",{\"1\":{\"253\":1}}],[\"接下来\",{\"1\":{\"94\":1}}],[\"接口类型\",{\"1\":{\"247\":1}}],[\"接口方法\",{\"1\":{\"230\":1}}],[\"接口的集合类一起使用\",{\"1\":{\"222\":1}}],[\"接口的实现\",{\"1\":{\"59\":1}}],[\"接口\",{\"1\":{\"222\":1,\"226\":1,\"228\":1}}],[\"接口实现\",{\"1\":{\"59\":1}}],[\"队列\",{\"1\":{\"94\":1}}],[\"竞争失败\",{\"1\":{\"94\":1}}],[\"竞争成功\",{\"1\":{\"94\":2}}],[\"竞争的时是非公平的\",{\"1\":{\"71\":1}}],[\"原因分析完语法糖转换后的代码应当自然清楚\",{\"1\":{\"223\":1}}],[\"原始类型\",{\"1\":{\"220\":3}}],[\"原理\",{\"0\":{\"94\":1,\"248\":1,\"273\":1}}],[\"原子性确保了当多个线程尝试同时修改同一变量时\",{\"1\":{\"65\":1}}],[\"原子性是指一个操作或者一系列操作要么全部执行并且在执行过程中不会被任何其他操作中断\",{\"1\":{\"65\":1}}],[\"原子性\",{\"0\":{\"255\":1},\"1\":{\"65\":2,\"254\":1}}],[\"原子操作\",{\"1\":{\"59\":1,\"68\":1}}],[\"用解释器将字节码翻译为机器码\",{\"1\":{\"251\":1}}],[\"用额外创建的类来创建匿名内部类对象\",{\"1\":{\"228\":1}}],[\"用下面反射代码来验证\",{\"1\":{\"227\":1}}],[\"用第二个\",{\"1\":{\"223\":1}}],[\"用到了新生代的幸存区\",{\"1\":{\"160\":1}}],[\"用户进入博客详情页\",{\"1\":{\"269\":1}}],[\"用户程序在继续运行\",{\"1\":{\"158\":1}}],[\"用户线程和垃圾回收线程可以同时进行\",{\"1\":{\"158\":1}}],[\"用户线程才恢复运行\",{\"1\":{\"153\":1}}],[\"用\",{\"1\":{\"132\":1,\"232\":1,\"240\":1,\"258\":1}}],[\"用ps命令进一步定位是哪个线程引起的cpu占用过高\",{\"1\":{\"110\":1}}],[\"用top定位哪个进程对cpu的占用过高\",{\"1\":{\"110\":1}}],[\"用来映射枚举的\",{\"1\":{\"224\":1}}],[\"用来获取集合的迭代器\",{\"1\":{\"222\":1}}],[\"用来进行跳转到指定行号的字节码\",{\"1\":{\"194\":1}}],[\"用来进行线程协作\",{\"1\":{\"98\":1}}],[\"用来进行线程同步协作\",{\"1\":{\"97\":1}}],[\"用来设置初始值\",{\"1\":{\"171\":1}}],[\"用来让计数减一\",{\"1\":{\"97\":1}}],[\"用来等待计数归零\",{\"1\":{\"97\":1}}],[\"用来限制对某些资源的并发访问\",{\"1\":{\"93\":1}}],[\"用于\",{\"1\":{\"224\":1}}],[\"用于比较的数字\",{\"1\":{\"224\":1}}],[\"用于加锁时消耗\",{\"1\":{\"215\":1}}],[\"用于函数消耗\",{\"1\":{\"215\":1}}],[\"用于保存新生代对象对应的脏卡\",{\"1\":{\"167\":1}}],[\"用于指定最长的停顿时间\",{\"1\":{\"165\":1}}],[\"用于移除引用为空的软引用对象\",{\"1\":{\"146\":1}}],[\"用于数据缓冲区\",{\"1\":{\"130\":1}}],[\"用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的\",{\"1\":{\"118\":1}}],[\"用于线程之间的线程阻塞和唤醒操作\",{\"1\":{\"101\":1}}],[\"用于处理异步任务的结果和执行流程\",{\"1\":{\"100\":1}}],[\"用于定时任务的线程池接口\",{\"1\":{\"92\":1}}],[\"用于创建不同类型的线程池\",{\"1\":{\"92\":1}}],[\"用于实现多线程环境下的同步操作\",{\"1\":{\"91\":1}}],[\"用于描述多线程环境下的内存访问行为\",{\"1\":{\"65\":1}}],[\"用于控制多个线程访问共享资源\",{\"1\":{\"59\":1}}],[\"管理任务提交和线程池的接口\",{\"1\":{\"92\":1}}],[\"它保证的是在多个线程之间\",{\"1\":{\"263\":1}}],[\"它可以用来修饰成员变量和静态成员变量\",{\"1\":{\"262\":1}}],[\"它将处于锁定状态\",{\"1\":{\"258\":1}}],[\"它发现门被锁住了\",{\"1\":{\"258\":1}}],[\"它定义了主存\",{\"1\":{\"254\":1}}],[\"它内部又是由\",{\"1\":{\"248\":1}}],[\"它就是大名鼎鼎的\",{\"1\":{\"246\":1}}],[\"它首先也不会自己去尝试加载这个类\",{\"1\":{\"242\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"242\":1}}],[\"它的镜像类就是\",{\"1\":{\"230\":1}}],[\"它的重要\",{\"1\":{\"230\":1}}],[\"它的常量池信息就会放入运行时常量池\",{\"1\":{\"122\":1}}],[\"它在类加载的链接阶段就已经根据方法的重写规则生成好了\",{\"1\":{\"199\":1,\"207\":1}}],[\"它所占据的内存资源会全部被释放掉\",{\"1\":{\"157\":1}}],[\"它是一种\",{\"1\":{\"133\":1}}],[\"它是如何实现回收的呢\",{\"1\":{\"132\":1}}],[\"它是线程共享的\",{\"1\":{\"114\":1}}],[\"它是线程安全的\",{\"1\":{\"108\":1}}],[\"它存储每个类的结构\",{\"1\":{\"118\":1}}],[\"它没有参数\",{\"1\":{\"101\":1}}],[\"它比synchronized关键字和reentrantlock提供了更多的灵活性\",{\"1\":{\"96\":1}}],[\"它按照线程请求资源的顺序来分配许可\",{\"1\":{\"95\":1}}],[\"它提供了一种简洁而强大的方式来处理异步操作\",{\"1\":{\"100\":1}}],[\"它提供了一种更为复杂的方式来控制同时访问某些资源的线程数量\",{\"1\":{\"93\":1}}],[\"它提供了一种队列同步器的实现方式\",{\"1\":{\"92\":1}}],[\"它们的转换可以在编译期自动完成\",{\"1\":{\"218\":1}}],[\"它们也要求开发者更仔细地管理线程的生命周期和状态\",{\"1\":{\"101\":1}}],[\"它们利用底层硬件的原子指令来保证操作的原子性\",{\"1\":{\"65\":1}}],[\"它们是\",{\"1\":{\"65\":1}}],[\"旧的预期值\",{\"1\":{\"91\":1}}],[\"自增\",{\"1\":{\"256\":3,\"263\":1}}],[\"自增后\",{\"1\":{\"196\":1}}],[\"自减\",{\"1\":{\"256\":3,\"263\":1}}],[\"自减需要在主存和线程内存中进行数据交换\",{\"1\":{\"256\":1}}],[\"自减并不是原子操作\",{\"1\":{\"256\":1}}],[\"自定义\",{\"1\":{\"239\":1}}],[\"自定义类加载器\",{\"0\":{\"243\":1},\"1\":{\"239\":1}}],[\"自动拆装箱\",{\"0\":{\"218\":1}}],[\"自动生成和转换的一些代码\",{\"1\":{\"216\":1}}],[\"自旋问题\",{\"0\":{\"91\":1}}],[\"自己确实偏向错了\",{\"1\":{\"82\":1}}],[\"达到次数升级重量级锁\",{\"1\":{\"87\":1}}],[\"证明有多个线程同时使用\",{\"1\":{\"87\":1}}],[\"升级为轻量级锁\",{\"1\":{\"87\":1}}],[\"则将数组下标为2\",{\"1\":{\"273\":1}}],[\"则数组越长\",{\"1\":{\"273\":1}}],[\"则不会进行上面的优化\",{\"1\":{\"253\":1}}],[\"则不会再次加载\",{\"1\":{\"241\":1}}],[\"则还有自动拆箱的操作\",{\"1\":{\"219\":1}}],[\"则通过\",{\"1\":{\"209\":1}}],[\"则卸载它所加载的所有类\",{\"1\":{\"170\":1}}],[\"则该区域被称为脏卡\",{\"1\":{\"167\":1}}],[\"则会报出异常classnotfoundexception\",{\"1\":{\"242\":1}}],[\"则会使用appclassloader来加载\",{\"1\":{\"242\":1}}],[\"则会再次触发\",{\"1\":{\"153\":1}}],[\"则会撤销偏向模式\",{\"1\":{\"87\":1}}],[\"则移除\",{\"1\":{\"146\":1}}],[\"则表示可以回收\",{\"1\":{\"137\":1}}],[\"则放入失败\",{\"1\":{\"123\":1,\"125\":1}}],[\"则放入成功\",{\"1\":{\"123\":1}}],[\"则可以收缩\",{\"1\":{\"118\":1}}],[\"则返回false\",{\"1\":{\"95\":1}}],[\"则线程会被阻塞\",{\"1\":{\"95\":1}}],[\"则解锁成功\",{\"1\":{\"83\":1}}],[\"编译成class后的代码\",{\"1\":{\"217\":1}}],[\"编译后的字节码文件\",{\"0\":{\"188\":1}}],[\"编译为\",{\"1\":{\"179\":1}}],[\"编译器会将\",{\"1\":{\"260\":1}}],[\"编译器会做如下处理\",{\"1\":{\"227\":1}}],[\"编译器会帮助生成关闭资源代码\",{\"1\":{\"226\":1}}],[\"编译器会帮我们转换为\",{\"1\":{\"222\":1}}],[\"编译器会在编译期间将上述代码变换为\",{\"1\":{\"221\":1}}],[\"编译器会按从上至下的顺序\",{\"1\":{\"197\":2}}],[\"编译器真正生成的字节码中\",{\"1\":{\"219\":1}}],[\"编译器转换的结果直接就是\",{\"1\":{\"216\":1}}],[\"编译器给我们的一个额外福利\",{\"1\":{\"216\":1}}],[\"编译器把\",{\"1\":{\"216\":1}}],[\"编译器处理\",{\"0\":{\"216\":1}}],[\"编译器在编译期间会把abc作为常量放在常量池中\",{\"1\":{\"124\":1}}],[\"编译器和jvm会帮助我们将其合并为一次加锁解锁操作\",{\"1\":{\"86\":1}}],[\"编辑此页链接\",{\"1\":{\"3\":1,\"56\":1}}],[\"多个读线程的情况\",{\"1\":{\"263\":1}}],[\"多个\",{\"0\":{\"210\":1}}],[\"多个线程交替使用\",{\"1\":{\"87\":1}}],[\"多个线程只对变量做读取操作\",{\"1\":{\"85\":1}}],[\"多态相关的\",{\"1\":{\"205\":1}}],[\"多态的原理\",{\"0\":{\"199\":1}}],[\"多核cpu\",{\"1\":{\"160\":1,\"161\":1}}],[\"多线程\",{\"1\":{\"159\":1,\"160\":2,\"161\":2}}],[\"多线程的环境下\",{\"1\":{\"106\":1}}],[\"多功能的监测工具\",{\"1\":{\"116\":1}}],[\"多次频繁的加锁解锁操作\",{\"1\":{\"86\":1}}],[\"xbootclasspath\",{\"1\":{\"240\":5}}],[\"xc\",{\"1\":{\"179\":1}}],[\"xms20m\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"xms堆最大大小\",{\"1\":{\"155\":1}}],[\"xmn10m\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"xmn\",{\"1\":{\"155\":1,\"160\":1}}],[\"xmx\",{\"1\":{\"155\":1}}],[\"xmx20m\",{\"1\":{\"146\":2,\"155\":1,\"156\":1,\"157\":1}}],[\"xmx10m\",{\"1\":{\"127\":2}}],[\"xmx8m\",{\"1\":{\"115\":1}}],[\"x3==x4\",{\"1\":{\"125\":1}}],[\"x3=\",{\"1\":{\"125\":1}}],[\"x4\",{\"1\":{\"125\":1}}],[\"x4=new\",{\"1\":{\"125\":1}}],[\"x2\",{\"1\":{\"125\":1}}],[\"x2=new\",{\"1\":{\"125\":1}}],[\"x1==x2\",{\"1\":{\"125\":1}}],[\"x1=\",{\"1\":{\"125\":1}}],[\"xpp\",{\"1\":{\"115\":1,\"120\":1,\"125\":1}}],[\"xss256k\",{\"1\":{\"109\":1}}],[\"x++\",{\"1\":{\"85\":2,\"196\":1}}],[\"x\",{\"1\":{\"85\":1,\"123\":3,\"132\":2,\"196\":5,\"218\":6,\"219\":6,\"222\":2,\"223\":5,\"224\":3,\"228\":8,\"248\":3,\"252\":3,\"253\":4,\"262\":2}}],[\"xxx\",{\"1\":{\"121\":1,\"165\":1}}],[\"xx\",{\"1\":{\"78\":1,\"85\":1,\"120\":3,\"127\":4,\"128\":1,\"133\":2,\"146\":1,\"155\":11,\"156\":3,\"157\":3,\"159\":2,\"160\":11,\"161\":6,\"162\":3,\"164\":1,\"165\":1,\"169\":1,\"170\":1,\"171\":2,\"172\":1,\"176\":2,\"177\":1,\"199\":2,\"251\":1,\"252\":4}}],[\"明显不会发生线程安全问题的代码才会消除锁\",{\"1\":{\"85\":1}}],[\"此方法才是真正重写了父类\",{\"1\":{\"227\":1}}],[\"此对象没有任何属性\",{\"1\":{\"203\":1}}],[\"此规范不强制指定方法区的位置或用于管理已编译代码的策略\",{\"1\":{\"118\":1}}],[\"此时也会破坏双亲委派模式\",{\"1\":{\"243\":1}}],[\"此时操作数栈中有\",{\"1\":{\"196\":1}}],[\"此时计数器加1\",{\"1\":{\"95\":1}}],[\"此时由于stringbuffer对象是线程安全的\",{\"1\":{\"85\":1}}],[\"此文字有脚注^first\",{\"1\":{\"16\":1}}],[\"设置默认值\",{\"1\":{\"233\":1}}],[\"设置虚拟机栈内存大小\",{\"1\":{\"109\":1}}],[\"设置自己为\",{\"1\":{\"94\":1}}],[\"设置\",{\"1\":{\"84\":1,\"146\":1}}],[\"设置到对象的\",{\"1\":{\"76\":1}}],[\"地址找到\",{\"1\":{\"84\":1}}],[\"让我们追踪一下源码\",{\"1\":{\"245\":1}}],[\"让对象可以通过其找到方法区中的instanceklass\",{\"1\":{\"230\":1}}],[\"让长时间存活的对象尽快晋升\",{\"1\":{\"176\":1}}],[\"让单位时间\",{\"1\":{\"160\":1}}],[\"让其他线程都在这个点停下来\",{\"1\":{\"159\":1}}],[\"让\",{\"1\":{\"84\":1}}],[\"让锁记录中\",{\"1\":{\"83\":1}}],[\"加法\",{\"1\":{\"256\":1}}],[\"加锁\",{\"0\":{\"257\":1},\"1\":{\"215\":1}}],[\"加锁线程\",{\"1\":{\"81\":1}}],[\"加载时会使用拓展类加载器加载\",{\"1\":{\"241\":1}}],[\"加载的类\",{\"1\":{\"239\":1}}],[\"加载和链接可能是交替运行的\",{\"1\":{\"230\":1}}],[\"加载\",{\"0\":{\"230\":1}}],[\"加载对象到栈顶\",{\"1\":{\"215\":1}}],[\"加载异常\",{\"1\":{\"214\":1}}],[\"加载局部变量表1号位置的数10到操作数栈\",{\"1\":{\"214\":1}}],[\"加载到操作数栈\",{\"1\":{\"215\":1}}],[\"加载到操作数栈顶\",{\"1\":{\"214\":1}}],[\"加载到局部变量表的1号位置\",{\"1\":{\"214\":1}}],[\"加轻量级锁cas失败\",{\"1\":{\"84\":1}}],[\"表示将当前目录追加至\",{\"1\":{\"240\":1}}],[\"表示设置\",{\"1\":{\"240\":1}}],[\"表示枚举对象的序号\",{\"1\":{\"224\":1}}],[\"表示接口的数量\",{\"1\":{\"183\":1}}],[\"表示根据常量池中\",{\"1\":{\"183\":2}}],[\"表示该\",{\"1\":{\"183\":1}}],[\"表示长度\",{\"1\":{\"182\":23}}],[\"表示它的类加载器是\",{\"1\":{\"245\":1}}],[\"表示它引用了常量池中\",{\"1\":{\"182\":6}}],[\"表示它是否是\",{\"1\":{\"180\":1}}],[\"表示一个字符串常量名称\",{\"1\":{\"182\":1}}],[\"表示一个\",{\"1\":{\"182\":33}}],[\"表示一次只允许一个线程访问资源\",{\"1\":{\"96\":1}}],[\"表示常量池有\",{\"1\":{\"182\":1}}],[\"表示常量池长度\",{\"1\":{\"182\":1}}],[\"表示是\",{\"1\":{\"181\":1}}],[\"表示类的版本\",{\"1\":{\"181\":1}}],[\"表示同时允许访问资源的线程数量\",{\"1\":{\"95\":1}}],[\"表示重入计数减一\",{\"1\":{\"83\":1}}],[\"表示有重入\",{\"1\":{\"83\":1}}],[\"表示由该线程给对象加锁\",{\"1\":{\"83\":1}}],[\"进程依然正常\",{\"1\":{\"157\":1}}],[\"进程的id\",{\"1\":{\"139\":1}}],[\"进程\",{\"1\":{\"116\":1,\"201\":1}}],[\"进程id\",{\"1\":{\"110\":2,\"116\":1}}],[\"进行了扩展\",{\"1\":{\"247\":1}}],[\"进行计算得到\",{\"1\":{\"205\":1}}],[\"进行数据采样并动态调整\",{\"1\":{\"171\":1}}],[\"进行全面的回收\",{\"1\":{\"165\":1}}],[\"进行初始标记\",{\"1\":{\"164\":1}}],[\"进行\",{\"1\":{\"161\":1}}],[\"进行轻量级加锁时\",{\"1\":{\"84\":1}}],[\"进行引用\",{\"1\":{\"28\":1,\"282\":1}}],[\"进入println源码\",{\"1\":{\"262\":1}}],[\"进入了这个房间\",{\"1\":{\"258\":1}}],[\"进入命令行模式\",{\"1\":{\"204\":1,\"205\":1}}],[\"进入图形界面\",{\"1\":{\"201\":1}}],[\"进入\",{\"1\":{\"94\":1,\"201\":1,\"205\":1,\"209\":1}}],[\"进入锁膨胀流程\",{\"1\":{\"84\":1}}],[\"进入锁膨胀过程\",{\"1\":{\"83\":1}}],[\"进入重量级锁解锁流程\",{\"1\":{\"83\":1}}],[\"锁竞争\",{\"1\":{\"173\":1}}],[\"锁粗化\",{\"0\":{\"86\":1}}],[\"锁消除是指jvm在编译过程中通过静态分析技术检测到一些不可能存在竞争条件的锁\",{\"1\":{\"85\":1}}],[\"锁消除\",{\"0\":{\"85\":1}}],[\"锁\",{\"1\":{\"84\":1}}],[\"锁膨胀\",{\"0\":{\"84\":1}}],[\"锁记录的值不为\",{\"1\":{\"83\":1}}],[\"锁记录地址和状态\",{\"1\":{\"83\":1}}],[\"锁重入\",{\"1\":{\"83\":1}}],[\"锁住的是对象实例或类对象\",{\"1\":{\"71\":1}}],[\"替换成功\",{\"1\":{\"83\":1}}],[\"替换\",{\"1\":{\"83\":1}}],[\"并同步至主存\",{\"1\":{\"260\":1}}],[\"并反手锁住了门\",{\"1\":{\"258\":1}}],[\"并优化这些热点代码\",{\"1\":{\"251\":1}}],[\"并存入\",{\"1\":{\"251\":1}}],[\"并先初始化类\",{\"1\":{\"237\":1}}],[\"并给\",{\"1\":{\"223\":1}}],[\"并执行拆箱操作\",{\"1\":{\"219\":1}}],[\"并不是编译器还会转换出中间的\",{\"1\":{\"216\":1}}],[\"并不是默认开启的\",{\"1\":{\"162\":1}}],[\"并将其引用放入操作数栈中\",{\"1\":{\"192\":1}}],[\"并将c变为\",{\"1\":{\"168\":1}}],[\"并发量\",{\"1\":{\"176\":1}}],[\"并发清除\",{\"1\":{\"161\":1}}],[\"并发标记必须在堆空间占满前完成\",{\"1\":{\"171\":1}}],[\"并发标记起始时间的调整\",{\"1\":{\"171\":1}}],[\"并发标记\",{\"1\":{\"161\":1,\"164\":1}}],[\"并发\",{\"1\":{\"161\":1}}],[\"并发收集\",{\"1\":{\"158\":1,\"161\":1}}],[\"并发包\",{\"1\":{\"59\":1}}],[\"并行\",{\"1\":{\"158\":1,\"160\":2}}],[\"并行并发\",{\"1\":{\"158\":1}}],[\"并行执行\",{\"1\":{\"100\":1}}],[\"并让幸存区中的对象寿命加1\",{\"1\":{\"153\":1}}],[\"并移除\",{\"1\":{\"146\":1}}],[\"并且长度不太长时\",{\"1\":{\"252\":1}}],[\"并且与原来的\",{\"1\":{\"227\":1}}],[\"并且回收需要主动调用\",{\"1\":{\"132\":1}}],[\"并且如果不需要更大的方法区域\",{\"1\":{\"118\":1}}],[\"并放入串池中\",{\"1\":{\"123\":3}}],[\"并把里面的符号地址变为真实地址\",{\"1\":{\"122\":1}}],[\"并逃离了方法的范围\",{\"1\":{\"108\":1}}],[\"并尝试用\",{\"1\":{\"83\":1}}],[\"那这两个类就必定不相等\",{\"1\":{\"239\":1}}],[\"那就要考虑线程安全问题\",{\"1\":{\"108\":1}}],[\"那么就去请求数据库\",{\"1\":{\"269\":1}}],[\"那么就会由\",{\"1\":{\"132\":1}}],[\"那么需要访问数据库\",{\"1\":{\"269\":1}}],[\"那么赋值也会在初始化阶段完成\",{\"1\":{\"233\":1}}],[\"那么编译阶段值就确定了\",{\"1\":{\"233\":1}}],[\"那么ualx属性没有机会再跟着一起变化\",{\"1\":{\"228\":1}}],[\"那么这\",{\"1\":{\"205\":1}}],[\"那么它们要比较怎么办\",{\"1\":{\"194\":1}}],[\"那么已经\",{\"1\":{\"177\":1}}],[\"那么吞吐量就是99\",{\"1\":{\"158\":1}}],[\"那么触发\",{\"1\":{\"153\":1}}],[\"那么\",{\"1\":{\"139\":1}}],[\"那么程序计数器会记录线程下一行指令的地址行号\",{\"1\":{\"106\":1}}],[\"那么再添加一条\",{\"1\":{\"83\":1}}],[\"那么可以使用轻量级锁来优化\",{\"1\":{\"83\":1}}],[\"那要先提一下线程间是如何通信的\",{\"1\":{\"59\":1}}],[\"都需要加载\",{\"1\":{\"245\":1}}],[\"都拥有一个独立的类名称空间\",{\"1\":{\"239\":1}}],[\"都必须由加载它的类加载器和这个类本身一起共同确立其在\",{\"1\":{\"239\":1}}],[\"都是继承\",{\"1\":{\"206\":1}}],[\"都是强引用\",{\"1\":{\"146\":1}}],[\"都可以找到\",{\"1\":{\"205\":1}}],[\"都会按\",{\"1\":{\"194\":1}}],[\"都会回收弱引用对象\",{\"1\":{\"143\":1}}],[\"都会返回串池中的字符串对象\",{\"1\":{\"123\":1,\"125\":1}}],[\"都会被加载到运行时常量池中\",{\"1\":{\"123\":1}}],[\"都会变为不可偏向的\",{\"1\":{\"82\":1}}],[\"都有可能造成栈内存溢出\",{\"1\":{\"109\":1}}],[\"都将立即反映到主内存中\",{\"1\":{\"66\":1}}],[\"于是整个类的所有对象\",{\"1\":{\"82\":1}}],[\"于是会在给这些对象加锁时重新偏向至\",{\"1\":{\"81\":1}}],[\"批量撤销\",{\"0\":{\"82\":1}}],[\"批量重偏向\",{\"0\":{\"81\":1}}],[\"其\",{\"1\":{\"222\":1}}],[\"其实布隆过滤器的核心思想其实并不难\",{\"1\":{\"274\":1}}],[\"其实发生在双亲委派模型出现之前\",{\"1\":{\"243\":1}}],[\"其实是一个\",{\"1\":{\"221\":1}}],[\"其实循环控制还是前面介绍的那些指令\",{\"1\":{\"195\":1}}],[\"其实就是指\",{\"1\":{\"216\":1}}],[\"其实就是参数为字符串数组\",{\"1\":{\"182\":1}}],[\"其实就是表示无参\",{\"1\":{\"182\":1}}],[\"其长度会补齐\",{\"1\":{\"192\":2}}],[\"其与string\",{\"1\":{\"169\":1}}],[\"其计数减一\",{\"1\":{\"135\":1}}],[\"其中有两个重要的参数\",{\"1\":{\"275\":1}}],[\"其中\",{\"1\":{\"240\":1}}],[\"其中桥接方法比较特殊\",{\"1\":{\"227\":1}}],[\"其中资源对象需要实现\",{\"1\":{\"226\":1}}],[\"其中thread是当前线程的引用\",{\"1\":{\"101\":1}}],[\"其中构造参数用来初始化等待计数值\",{\"1\":{\"97\":1}}],[\"其它线程使用对象\",{\"0\":{\"79\":1}}],[\"其他线程进入阻塞状态\",{\"1\":{\"159\":1}}],[\"其他线程可能会拿到这个线程的引用\",{\"1\":{\"108\":1}}],[\"其他线程可以立即看到这个变化\",{\"1\":{\"67\":1}}],[\"其他线程能够立即看到这个修改\",{\"1\":{\"65\":1}}],[\"其他线程不会同时修改这个资源\",{\"1\":{\"59\":1}}],[\"后续\",{\"1\":{\"253\":1}}],[\"后追加\",{\"1\":{\"240\":1}}],[\"后的元空间内\",{\"1\":{\"230\":2}}],[\"后\",{\"1\":{\"203\":1}}],[\"后面是数据\",{\"1\":{\"182\":1}}],[\"后面09是constant\",{\"1\":{\"182\":1}}],[\"后面又引用了c\",{\"1\":{\"168\":1}}],[\"后使用偏向锁\",{\"1\":{\"78\":1}}],[\"后unpark\",{\"0\":{\"63\":1},\"1\":{\"62\":1}}],[\"轻量级锁使用cas\",{\"1\":{\"87\":1}}],[\"轻量级锁对使用者是透明的\",{\"1\":{\"83\":1}}],[\"轻量级锁的使用场景\",{\"1\":{\"83\":1}}],[\"轻量级锁\",{\"0\":{\"83\":1},\"1\":{\"87\":1}}],[\"轻量级锁会在锁记录中记录\",{\"1\":{\"78\":1}}],[\"轻量级锁在没有竞争时\",{\"1\":{\"76\":1}}],[\"撤销\",{\"0\":{\"78\":1,\"79\":1,\"80\":1}}],[\"||\",{\"1\":{\"246\":1}}],[\"|\",{\"1\":{\"77\":52,\"98\":2,\"110\":1,\"172\":1,\"197\":4,\"211\":2}}],[\"同理\",{\"1\":{\"272\":1,\"273\":1}}],[\"同\",{\"1\":{\"221\":1}}],[\"同样是单线程收集器\",{\"1\":{\"159\":1}}],[\"同步关键字\",{\"0\":{\"258\":1}}],[\"同步\",{\"1\":{\"98\":1}}],[\"同步块\",{\"1\":{\"76\":3,\"84\":1}}],[\"同时注重吞吐量\",{\"1\":{\"162\":1}}],[\"同时使用一个volatile变量来表示锁的状态\",{\"1\":{\"92\":1}}],[\"同时每个页面包含\",{\"1\":{\"6\":1}}],[\"头\",{\"1\":{\"76\":1}}],[\"操作数栈分配2个空间\",{\"1\":{\"196\":1}}],[\"操作数栈内容\",{\"1\":{\"192\":1}}],[\"操作分配内存都是非常廉价的\",{\"1\":{\"176\":1}}],[\"操作包含三个操作数\",{\"1\":{\"91\":1}}],[\"操作来尝试获取锁\",{\"1\":{\"87\":1}}],[\"操作无法成功\",{\"1\":{\"84\":1}}],[\"操作\",{\"1\":{\"76\":1,\"224\":1}}],[\"每秒吞吐量\",{\"1\":{\"253\":1}}],[\"每一个类加载器\",{\"1\":{\"239\":1}}],[\"每一个小区间独立回收\",{\"1\":{\"163\":1}}],[\"每次只执行其中一个\",{\"1\":{\"237\":1}}],[\"每次重入仍然需要执行\",{\"1\":{\"76\":1}}],[\"每个块中都有finally块\",{\"1\":{\"212\":1}}],[\"每个空间4个字节\",{\"1\":{\"191\":1}}],[\"每个栈由多个栈帧\",{\"1\":{\"108\":1}}],[\"每个线程只能有一个活动栈帧\",{\"1\":{\"108\":1}}],[\"每个线程运行需要的内存空间\",{\"1\":{\"108\":1}}],[\"每个线程执行到某个需要\",{\"1\":{\"98\":1}}],[\"每个线程都的栈帧都会包含一个锁记录的结构\",{\"1\":{\"83\":1}}],[\"每个线程都有一个私有的\",{\"1\":{\"65\":1}}],[\"每个线程都有自己的一个\",{\"1\":{\"62\":1}}],[\"每个\",{\"1\":{\"29\":1,\"70\":1,\"283\":1}}],[\"该收集器的目标是达到一个可控制的吞吐量\",{\"1\":{\"160\":1}}],[\"该对象就可以被垃圾回收了\",{\"1\":{\"145\":1}}],[\"该对象就可以被回收\",{\"1\":{\"135\":1}}],[\"该对象才能被垃圾回收\",{\"1\":{\"141\":1}}],[\"该对象计数加一\",{\"1\":{\"135\":1}}],[\"该对象头的mark\",{\"1\":{\"70\":1}}],[\"该字符串才会被创建并放入串池中\",{\"1\":{\"123\":1}}],[\"该数据在32位和64位jvm中长度都是32bit\",{\"1\":{\"75\":1}}],[\"该指针在32位jvm中的长度是32bit\",{\"1\":{\"74\":1}}],[\"只要加载它们的类加载器不同\",{\"1\":{\"239\":1}}],[\"只触发父类初始化\",{\"1\":{\"237\":1}}],[\"只会触发父类的初始化\",{\"1\":{\"237\":1}}],[\"只是为了便于阅读\",{\"1\":{\"216\":1}}],[\"只是将\",{\"1\":{\"147\":1}}],[\"只不过这里单独提出来了\",{\"1\":{\"189\":1}}],[\"只能保证看到最新值\",{\"1\":{\"263\":1}}],[\"只能在门外等待\",{\"1\":{\"258\":1}}],[\"只能在运行期确定它的值\",{\"1\":{\"123\":1}}],[\"只能进入\",{\"1\":{\"210\":1}}],[\"只能随机唤醒一个等待线程\",{\"1\":{\"65\":1}}],[\"只有在这两个类是由同一个类加载器加载的前提下才有意义\",{\"1\":{\"239\":1}}],[\"只有在运行期间才能确定\",{\"1\":{\"198\":1}}],[\"只有在被用到时才会转化为对象\",{\"1\":{\"123\":1}}],[\"只有所有\",{\"1\":{\"141\":1}}],[\"只有当运行到那一行字符串且在串池中不存在的时候\",{\"1\":{\"123\":1}}],[\"只有第一次使用\",{\"1\":{\"76\":1}}],[\"只有数组对象保存了这部分数据\",{\"1\":{\"75\":1}}],[\"只有数组对象才有\",{\"1\":{\"72\":1}}],[\"数组\",{\"1\":{\"254\":1}}],[\"数组大小即为枚举元素个数\",{\"1\":{\"224\":1}}],[\"数组赋初值的简化写法也是语法糖哦\",{\"1\":{\"222\":1}}],[\"数组的循环\",{\"1\":{\"222\":1}}],[\"数组长度\",{\"1\":{\"72\":1}}],[\"数据表示是否太臃肿\",{\"1\":{\"175\":1}}],[\"数据是不是太多\",{\"1\":{\"175\":1}}],[\"数据共享\",{\"1\":{\"59\":1}}],[\"数据库等\",{\"1\":{\"59\":1}}],[\"driverslist\",{\"1\":{\"246\":3}}],[\"driversiterator\",{\"1\":{\"246\":3}}],[\"drivers\",{\"1\":{\"246\":11}}],[\"drivermanager\",{\"1\":{\"245\":5,\"246\":3}}],[\"driver\",{\"1\":{\"245\":4,\"246\":1}}],[\"dirty\",{\"1\":{\"167\":1}}],[\"directmemorytest\",{\"1\":{\"133\":1}}],[\"directbytebuffer类\",{\"1\":{\"132\":1}}],[\"directbytebuffer\",{\"1\":{\"132\":4}}],[\"directbuffer\",{\"1\":{\"131\":1}}],[\"direct\",{\"1\":{\"132\":1}}],[\"dubbo\",{\"1\":{\"247\":1}}],[\"dump\",{\"1\":{\"139\":2}}],[\"dup\",{\"1\":{\"71\":1,\"123\":2,\"198\":2,\"215\":2,\"219\":1,\"220\":1}}],[\"dont\",{\"1\":{\"253\":1}}],[\"dosum\",{\"1\":{\"253\":10}}],[\"doescapeanalysis\",{\"1\":{\"251\":1}}],[\"do\",{\"1\":{\"195\":2,\"246\":1}}],[\"docs\",{\"1\":{\"194\":1}}],[\"double\",{\"1\":{\"182\":1,\"194\":1,\"237\":1,\"274\":1}}],[\"doprivileged\",{\"1\":{\"132\":1,\"246\":2}}],[\"dog\",{\"1\":{\"79\":2,\"80\":2,\"81\":3,\"82\":5,\"199\":2,\"202\":1,\"205\":3,\"206\":2}}],[\"day01\",{\"1\":{\"121\":2}}],[\"date\",{\"1\":{\"98\":4}}],[\"details\",{\"1\":{\"263\":2}}],[\"delegatingmethodaccessorimpl\",{\"1\":{\"254\":2}}],[\"delta\",{\"1\":{\"71\":2}}],[\"dependencies>\",{\"1\":{\"274\":1}}],[\"dependency>\",{\"1\":{\"253\":2,\"274\":1}}],[\"deployment\",{\"1\":{\"243\":1}}],[\"deﬁneclass\",{\"1\":{\"243\":1}}],[\"default\",{\"1\":{\"223\":4,\"224\":2}}],[\"defineclass1\",{\"1\":{\"120\":1}}],[\"defineclass\",{\"1\":{\"120\":3}}],[\"descriptor\",{\"1\":{\"188\":2,\"193\":1,\"210\":1,\"211\":1,\"220\":2}}],[\"demo8$1\",{\"1\":{\"228\":1}}],[\"demo3\",{\"1\":{\"187\":1,\"193\":1,\"194\":1,\"195\":3,\"199\":1,\"210\":1,\"211\":2,\"254\":1}}],[\"demo1\",{\"1\":{\"146\":1,\"256\":1,\"258\":1,\"262\":1}}],[\"declared\",{\"1\":{\"182\":6}}],[\"deallocator\",{\"1\":{\"132\":1}}],[\"deadline\",{\"1\":{\"101\":1}}],[\"debug\",{\"1\":{\"79\":4,\"80\":4,\"81\":5,\"82\":10,\"97\":8,\"254\":1}}],[\"d\",{\"1\":{\"79\":7,\"80\":8,\"81\":9,\"82\":14,\"85\":1,\"125\":1,\"172\":1,\"179\":1,\"197\":3,\"198\":1,\"202\":2,\"220\":1,\"226\":2,\"233\":4,\"234\":4,\"251\":2,\"252\":3}}],[\"847\",{\"1\":{\"253\":1}}],[\"83890\",{\"1\":{\"253\":1}}],[\"8后为元空间\",{\"1\":{\"230\":1}}],[\"8行的字节码指令\",{\"1\":{\"209\":1}}],[\"8项\",{\"1\":{\"182\":1}}],[\"8的串用2个字节来表示长度\",{\"1\":{\"182\":1}}],[\"8~9\",{\"1\":{\"182\":1}}],[\"8u60\",{\"0\":{\"171\":1}}],[\"8默认使用的垃圾回收器\",{\"1\":{\"160\":1}}],[\"8mb\",{\"1\":{\"155\":1,\"156\":2,\"157\":3}}],[\"8以后会导致元空间内存溢出java\",{\"1\":{\"120\":1}}],[\"8以前会导致永久代内存溢出java\",{\"1\":{\"120\":1}}],[\"8引入的一个异步编程工具类\",{\"1\":{\"100\":1}}],[\"8\",{\"0\":{\"127\":1,\"198\":1,\"207\":1,\"224\":1},\"1\":{\"71\":1,\"81\":4,\"119\":1,\"120\":3,\"123\":7,\"125\":1,\"126\":1,\"155\":1,\"156\":1,\"157\":1,\"158\":1,\"172\":1,\"181\":1,\"182\":2,\"188\":4,\"192\":1,\"193\":1,\"194\":1,\"195\":3,\"198\":1,\"203\":2,\"209\":2,\"210\":2,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"220\":5,\"230\":2,\"239\":1,\"252\":1,\"256\":2}}],[\"9712477\",{\"1\":{\"276\":1}}],[\"976\",{\"1\":{\"85\":1}}],[\"999\",{\"1\":{\"253\":1}}],[\"99162322\",{\"1\":{\"223\":1}}],[\"984\",{\"1\":{\"253\":1}}],[\"91304\",{\"1\":{\"253\":1}}],[\"9项\",{\"1\":{\"182\":1}}],[\"9以后默认使用\",{\"1\":{\"162\":1}}],[\"9\",{\"0\":{\"128\":1,\"199\":1,\"225\":1},\"1\":{\"71\":2,\"81\":4,\"106\":1,\"123\":3,\"147\":1,\"171\":3,\"182\":1,\"188\":1,\"193\":1,\"194\":1,\"198\":1,\"209\":1,\"210\":2,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"220\":2,\"252\":4}}],[\"将所有可能的数据缓存放到布隆过滤器中\",{\"1\":{\"272\":1}}],[\"将所有新分配的字符串\",{\"1\":{\"169\":1}}],[\"将会尝试获取对象所对应的monitor的所有权\",{\"1\":{\"258\":1}}],[\"将修改后的值存入静态变量i\",{\"1\":{\"256\":8,\"263\":2}}],[\"将一些字节码编译为机器码\",{\"1\":{\"251\":1}}],[\"将一个\",{\"1\":{\"192\":4}}],[\"将字节码解释为机器码\",{\"1\":{\"251\":1}}],[\"将字符串的转换为相应\",{\"1\":{\"223\":1}}],[\"将执行状态分成了\",{\"1\":{\"251\":1}}],[\"将常量池中的符号引用解析为直接引用\",{\"1\":{\"234\":1}}],[\"将常数\",{\"1\":{\"196\":2}}],[\"将类的字节码载入方法区\",{\"1\":{\"230\":1}}],[\"将x的值赋值给了candy11$1对象的vala属性\",{\"1\":{\"228\":1}}],[\"将对应位置枚举元素的值赋给\",{\"1\":{\"224\":1}}],[\"将object转换成了integer\",{\"1\":{\"219\":1}}],[\"将栈顶的对象地址方法\",{\"1\":{\"215\":1}}],[\"将局部变量\",{\"1\":{\"196\":2}}],[\"将局部变量表\",{\"1\":{\"196\":1}}],[\"将局部变量表中\",{\"1\":{\"192\":2}}],[\"将数字\",{\"1\":{\"196\":1}}],[\"将数据读到系统缓冲区\",{\"1\":{\"131\":1}}],[\"将操作数栈顶元素弹出\",{\"1\":{\"215\":1}}],[\"将操作数栈中的数放入到局部变量表的\",{\"1\":{\"196\":1}}],[\"将操作数栈中的两个元素弹出栈并相加\",{\"1\":{\"192\":1}}],[\"将操作数栈中的元素弹出\",{\"1\":{\"192\":2}}],[\"将操作数栈栈顶元素弹出\",{\"1\":{\"192\":1}}],[\"将其加载到操作数栈中\",{\"1\":{\"192\":1}}],[\"将老年代内存预设调大\",{\"1\":{\"177\":1}}],[\"将老年代垃圾进行标记\",{\"1\":{\"161\":1}}],[\"将c放入一个队列当中\",{\"1\":{\"168\":1}}],[\"将堆内存分为新生代和老年代\",{\"1\":{\"152\":1}}],[\"将被gc\",{\"1\":{\"151\":1}}],[\"将内存分为等大小的两个区域\",{\"1\":{\"151\":1}}],[\"将可用的对象移动到一起\",{\"1\":{\"150\":1}}],[\"将软引用的对象回收\",{\"1\":{\"146\":1}}],[\"将这个字符串对象尝试放入串池\",{\"1\":{\"123\":3}}],[\"将轻量级锁变为重量级锁\",{\"1\":{\"84\":1}}],[\"将线程\",{\"1\":{\"76\":1}}],[\"将\",{\"1\":{\"71\":3,\"83\":2,\"84\":1,\"221\":1,\"228\":1,\"241\":1}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"0\":1}}],[\">新生代伊甸园垃圾回收\",{\"1\":{\"162\":1}}],[\">混合收集\",{\"1\":{\"162\":1}}],[\">内存不足\",{\"1\":{\"162\":1}}],[\">>\",{\"1\":{\"146\":3,\"147\":2}}],[\">\",{\"1\":{\"71\":3,\"79\":2,\"80\":2,\"81\":2,\"82\":3,\"97\":3,\"98\":2,\"101\":1,\"146\":8,\"147\":7,\"155\":1,\"156\":1,\"157\":2,\"197\":6,\"202\":1,\"204\":1,\"205\":2,\"206\":1,\"220\":1,\"233\":1,\"234\":1,\"240\":1,\"242\":2,\"248\":1,\"253\":1,\"254\":1,\"256\":2,\"258\":2,\"260\":1,\"262\":1}}],[\"<version>22\",{\"1\":{\"274\":1}}],[\"<version>$\",{\"1\":{\"253\":2}}],[\"<artifactid>guava<\",{\"1\":{\"274\":1}}],[\"<artifactid>jmh\",{\"1\":{\"253\":2}}],[\"<groupid>com\",{\"1\":{\"274\":1}}],[\"<groupid>org\",{\"1\":{\"253\":2}}],[\"<dependencies>\",{\"1\":{\"274\":1}}],[\"<dependency>\",{\"1\":{\"253\":2,\"274\":1}}],[\"<scope>provided<\",{\"1\":{\"253\":1}}],[\"<s>\",{\"1\":{\"248\":1}}],[\"<追加路径>\",{\"1\":{\"240\":2}}],[\"<new\",{\"1\":{\"240\":1}}],[\"<cinit>\",{\"0\":{\"236\":1},\"1\":{\"236\":1}}],[\"<init>\",{\"1\":{\"123\":2,\"132\":1,\"182\":1,\"188\":4,\"197\":1,\"198\":2,\"215\":1,\"217\":1,\"219\":1,\"220\":2}}],[\"<\",{\"1\":{\"71\":5,\"81\":2,\"82\":3,\"120\":1,\"127\":1,\"146\":3,\"147\":2,\"194\":1,\"195\":3,\"196\":1,\"197\":6,\"220\":1,\"222\":1,\"251\":4,\"252\":2,\"253\":10,\"256\":2,\"258\":2,\"274\":4}}],[\"guava<\",{\"1\":{\"274\":1}}],[\"generatemethod\",{\"1\":{\"254\":1}}],[\"generatedmethodaccessor1\",{\"1\":{\"254\":1}}],[\"generatedmethodaccessor\",{\"1\":{\"254\":2}}],[\"generator\",{\"1\":{\"253\":1}}],[\"getmodifiers\",{\"1\":{\"254\":1}}],[\"getmethod\",{\"1\":{\"211\":1,\"220\":1,\"254\":1}}],[\"getexceptiontypes\",{\"1\":{\"254\":1}}],[\"getreturntype\",{\"1\":{\"254\":1}}],[\"getrawtype\",{\"1\":{\"220\":1}}],[\"getname\",{\"1\":{\"254\":1}}],[\"getdeclaringclass\",{\"1\":{\"254\":2}}],[\"getdeclaredmethods\",{\"1\":{\"227\":1}}],[\"getdeclaredfield\",{\"1\":{\"133\":1}}],[\"getparametertypes\",{\"1\":{\"254\":1}}],[\"getparentdelegationtime\",{\"1\":{\"242\":1}}],[\"getproperty\",{\"1\":{\"246\":1}}],[\"getfindclasses\",{\"1\":{\"242\":1}}],[\"getfindclasstime\",{\"1\":{\"242\":1}}],[\"getinstance\",{\"1\":{\"238\":2}}],[\"getactualtypearguments\",{\"1\":{\"220\":1}}],[\"getgenericparametertypes\",{\"1\":{\"220\":1}}],[\"getsystemclassloader\",{\"1\":{\"246\":2}}],[\"getsimplename\",{\"1\":{\"199\":1,\"253\":1}}],[\"getstatic\",{\"1\":{\"71\":2,\"106\":1,\"188\":1,\"192\":1,\"193\":2,\"196\":1,\"215\":1,\"256\":8,\"263\":7}}],[\"getcontextclassloader\",{\"1\":{\"237\":2,\"248\":1}}],[\"getcount\",{\"1\":{\"97\":3}}],[\"getclassloadinglock\",{\"1\":{\"242\":1}}],[\"getclassloader\",{\"1\":{\"233\":1,\"234\":1,\"240\":1,\"245\":1}}],[\"getclass\",{\"1\":{\"199\":1}}],[\"get\",{\"1\":{\"81\":1,\"82\":2,\"133\":1,\"146\":4,\"147\":3,\"219\":8,\"220\":1}}],[\"groupid>\",{\"1\":{\"253\":2,\"274\":1}}],[\"grep\",{\"1\":{\"110\":1}}],[\"g\",{\"1\":{\"241\":8}}],[\"git\",{\"1\":{\"240\":1,\"241\":1}}],[\"g1会跟踪老年代所有incoming引用\",{\"1\":{\"171\":1}}],[\"g1不会对巨型对象进行拷贝\",{\"1\":{\"171\":1}}],[\"g1并发检查是否有重复的字符串\",{\"1\":{\"169\":1}}],[\"g1\",{\"1\":{\"166\":1,\"174\":1}}],[\"g1heapregionsize=size\",{\"1\":{\"162\":1}}],[\"garbage\",{\"0\":{\"162\":1}}],[\"gc是不发生gc\",{\"0\":{\"175\":1}}],[\"gc自适应调节策略\",{\"1\":{\"160\":2}}],[\"gctimeratio=rario\",{\"1\":{\"160\":1}}],[\"gctimeratio=ratio\",{\"1\":{\"160\":1}}],[\"gctest\",{\"1\":{\"155\":1}}],[\"gcfullgc\",{\"1\":{\"155\":1}}],[\"gc\",{\"0\":{\"154\":1},\"1\":{\"77\":1,\"127\":3,\"133\":8,\"139\":1,\"141\":1,\"145\":1,\"146\":2,\"153\":2,\"155\":3,\"156\":1,\"157\":1,\"160\":1,\"161\":2,\"163\":1,\"164\":2,\"166\":8,\"172\":1,\"173\":1,\"175\":1,\"176\":5,\"177\":2,\"178\":4}}],[\"google\",{\"1\":{\"274\":1}}],[\"goto\",{\"1\":{\"71\":1,\"194\":2,\"195\":2,\"196\":1,\"209\":1,\"210\":3,\"211\":1,\"212\":2,\"215\":1}}],[\"golang里面的协程\",{\"1\":{\"59\":1}}],[\"必须到主存中获取它的值\",{\"1\":{\"262\":1}}],[\"必须改写下面这样\",{\"1\":{\"218\":1}}],[\"必须暂停其他所有的工作线程\",{\"1\":{\"159\":1}}],[\"必须打开下面的注释\",{\"1\":{\"79\":1}}],[\"必须是进入同一个对象的\",{\"1\":{\"71\":1}}],[\"必须配合\",{\"1\":{\"65\":1,\"144\":1}}],[\"图解方法执行流程\",{\"0\":{\"186\":1}}],[\"图形界面的\",{\"1\":{\"116\":1}}],[\"图中\",{\"1\":{\"71\":1}}],[\"图片等\",{\"1\":{\"180\":1}}],[\"图片引入\",{\"1\":{\"28\":1,\"282\":1}}],[\"图片增强\",{\"0\":{\"20\":1}}],[\"45966440\",{\"1\":{\"263\":1}}],[\"450570\",{\"1\":{\"253\":1}}],[\"4层\",{\"1\":{\"251\":1}}],[\"478\",{\"1\":{\"253\":1}}],[\"47\",{\"1\":{\"245\":1}}],[\"4反射获取泛型信息\",{\"0\":{\"220\":1}}],[\"419\",{\"1\":{\"188\":1}}],[\"4项\",{\"1\":{\"182\":1}}],[\"4~7\",{\"1\":{\"181\":1}}],[\"4f\",{\"1\":{\"179\":1,\"182\":2}}],[\"467\",{\"1\":{\"253\":1}}],[\"46\",{\"1\":{\"179\":1,\"182\":2}}],[\"4d\",{\"1\":{\"179\":1,\"182\":2}}],[\"481\",{\"1\":{\"241\":1}}],[\"48\",{\"1\":{\"179\":3,\"182\":4}}],[\"4865\",{\"1\":{\"120\":1}}],[\"4e\",{\"1\":{\"179\":1,\"182\":4}}],[\"4c\",{\"1\":{\"179\":7,\"182\":15}}],[\"43\",{\"1\":{\"179\":1,\"182\":4}}],[\"4bit\",{\"1\":{\"153\":1}}],[\"4mb\",{\"1\":{\"146\":4,\"147\":3}}],[\"4m\",{\"1\":{\"146\":2}}],[\"4堆内存诊断\",{\"0\":{\"116\":1}}],[\"448\",{\"1\":{\"115\":1}}],[\"404\",{\"1\":{\"326\":1}}],[\"40\",{\"1\":{\"82\":1,\"210\":2}}],[\"4\",{\"0\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"121\":1,\"158\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":2,\"176\":1,\"183\":1,\"190\":1,\"194\":1,\"203\":1,\"212\":1,\"229\":1,\"230\":1,\"231\":1,\"235\":1,\"238\":1,\"243\":1,\"301\":1,\"321\":1},\"1\":{\"71\":3,\"77\":2,\"81\":4,\"94\":2,\"106\":3,\"123\":7,\"146\":2,\"147\":1,\"175\":1,\"177\":1,\"182\":1,\"188\":3,\"192\":4,\"193\":1,\"194\":1,\"195\":1,\"196\":2,\"197\":4,\"198\":2,\"209\":1,\"210\":1,\"211\":3,\"212\":1,\"213\":1,\"214\":1,\"215\":2,\"219\":2,\"220\":4,\"222\":4,\"237\":2}}],[\"置为null\",{\"1\":{\"139\":1}}],[\"置为\",{\"1\":{\"71\":2}}],[\"就抛出异常\",{\"1\":{\"242\":1}}],[\"就得到了下图\",{\"1\":{\"273\":1}}],[\"就得到了\",{\"1\":{\"205\":1}}],[\"就是能够迅速判断一个元素是否存在一个集合中\",{\"1\":{\"272\":1}}],[\"就是应用程序类加载器\",{\"1\":{\"246\":1}}],[\"就是指调用类加载器的\",{\"1\":{\"242\":1}}],[\"就是\",{\"1\":{\"205\":1}}],[\"就是一张表\",{\"1\":{\"122\":1}}],[\"就跳转到\",{\"1\":{\"196\":1}}],[\"就称为巨型对象\",{\"1\":{\"171\":1}}],[\"就能知道哪些类不再被使用\",{\"1\":{\"170\":1}}],[\"就让他们引用同一个字符串对象\",{\"1\":{\"169\":1}}],[\"就算新生代的伊甸园为空\",{\"1\":{\"156\":1}}],[\"就像是获得了停车位\",{\"1\":{\"94\":1}}],[\"就好像停车位数量\",{\"1\":{\"94\":1}}],[\"就可以安全地消除对该锁的获取和释放操作\",{\"1\":{\"85\":1}}],[\"就自己这个线程\",{\"1\":{\"76\":1}}],[\"就会处理它\",{\"1\":{\"168\":1}}],[\"就会给c加一个写屏障\",{\"1\":{\"168\":1}}],[\"就会导致停顿的时候长\",{\"1\":{\"166\":1}}],[\"就会退化为\",{\"1\":{\"161\":1}}],[\"就会调用cleaner的clean方法\",{\"1\":{\"132\":1}}],[\"就会进入entrylist\",{\"1\":{\"71\":1}}],[\"就会将\",{\"1\":{\"71\":1}}],[\"就不那么\",{\"1\":{\"65\":1}}],[\"当黑客访问不存在的缓存时\",{\"1\":{\"272\":1}}],[\"当且一个monitor被持有后\",{\"1\":{\"258\":1}}],[\"当且仅当预期值\",{\"1\":{\"91\":1}}],[\"当线程\",{\"1\":{\"258\":1}}],[\"当线程获得了\",{\"1\":{\"94\":1}}],[\"当调用到第\",{\"1\":{\"254\":1}}],[\"当extclassloader加载一个class时\",{\"1\":{\"242\":1}}],[\"当appclassloader加载一个class时\",{\"1\":{\"242\":1}}],[\"当应用程序类加载器发现拓展类加载器已将该同名类加载过了\",{\"1\":{\"241\":1}}],[\"当执行\",{\"1\":{\"207\":1}}],[\"当执行到\",{\"1\":{\"123\":3}}],[\"当前活跃对象+需要晋升的对象\",{\"1\":{\"176\":1}}],[\"当一个类加载器的所有类都不再使用\",{\"1\":{\"170\":1}}],[\"当一个对象引用没有被其他变量引用时\",{\"1\":{\"135\":1}}],[\"当一个对象被其他变量引用\",{\"1\":{\"135\":1}}],[\"当新生代回收时\",{\"1\":{\"169\":1}}],[\"当然这也是很耗费时间的\",{\"1\":{\"161\":1}}],[\"当开关打开时不需要手动指定新生代的大小\",{\"1\":{\"160\":1}}],[\"当老年代空间不足\",{\"1\":{\"153\":1}}],[\"当对象寿命超过阈值时\",{\"1\":{\"153\":1}}],[\"当软引用所关联的\",{\"1\":{\"146\":1}}],[\"当软引用引用的对象被回收了\",{\"1\":{\"146\":1}}],[\"当内存不足时\",{\"1\":{\"146\":1}}],[\"当某个变量不在引用该对象\",{\"1\":{\"135\":1}}],[\"当该类被加载\",{\"1\":{\"122\":1}}],[\"当个数不足时\",{\"1\":{\"98\":1}}],[\"当等待的线程数满足\",{\"1\":{\"98\":1}}],[\"当锁处于这个状态时\",{\"1\":{\"87\":1}}],[\"当jvm确定某个锁对象不会发生竞争时\",{\"1\":{\"85\":1}}],[\"当退出\",{\"1\":{\"83\":2}}],[\"当撤销偏向锁阈值超过\",{\"1\":{\"81\":1,\"82\":1}}],[\"当有其它线程使用偏向锁对象时\",{\"1\":{\"79\":1}}],[\"当\",{\"1\":{\"71\":1,\"84\":2,\"258\":1}}],[\"n3在集合\",{\"1\":{\"273\":1}}],[\"n2的值\",{\"1\":{\"273\":1}}],[\"n2\",{\"1\":{\"273\":6}}],[\"n1\",{\"1\":{\"273\":6}}],[\"net\",{\"1\":{\"253\":1,\"263\":2}}],[\"nextint\",{\"1\":{\"253\":1}}],[\"nextname\",{\"1\":{\"248\":2}}],[\"nextservice\",{\"1\":{\"248\":1}}],[\"next\",{\"1\":{\"222\":1,\"246\":1,\"247\":1}}],[\"newline\",{\"1\":{\"262\":1}}],[\"newinstance\",{\"1\":{\"248\":1}}],[\"newsize=size\",{\"1\":{\"155\":1}}],[\"newstringbuilder\",{\"1\":{\"125\":1}}],[\"new\",{\"1\":{\"71\":1,\"76\":1,\"79\":3,\"80\":3,\"81\":4,\"82\":6,\"84\":1,\"85\":2,\"96\":1,\"97\":4,\"98\":3,\"101\":1,\"108\":2,\"115\":2,\"120\":2,\"123\":8,\"125\":1,\"132\":5,\"139\":1,\"146\":12,\"147\":7,\"155\":6,\"156\":1,\"157\":4,\"169\":2,\"176\":1,\"197\":1,\"198\":3,\"199\":2,\"215\":2,\"219\":2,\"220\":1,\"221\":2,\"222\":1,\"224\":1,\"225\":3,\"226\":4,\"228\":4,\"233\":2,\"234\":2,\"237\":2,\"238\":1,\"245\":1,\"246\":2,\"248\":2,\"251\":1,\"253\":3,\"254\":1,\"256\":2,\"258\":3,\"260\":1,\"262\":1}}],[\"n\",{\"1\":{\"175\":1,\"220\":1,\"251\":1,\"252\":1}}],[\"nio\",{\"1\":{\"132\":3}}],[\"nyima\",{\"1\":{\"121\":2}}],[\"ns\",{\"1\":{\"85\":4}}],[\"nanotime\",{\"1\":{\"242\":2,\"251\":2,\"252\":2}}],[\"nanos\",{\"1\":{\"101\":1}}],[\"nanoseconds\",{\"1\":{\"85\":1}}],[\"nativemethodaccessorimpl\",{\"1\":{\"254\":3}}],[\"native\",{\"1\":{\"120\":1,\"206\":2,\"254\":1}}],[\"nameandtype\",{\"1\":{\"182\":1,\"188\":3}}],[\"name\",{\"1\":{\"71\":1,\"182\":1,\"193\":1,\"210\":1,\"211\":1,\"220\":3,\"225\":4,\"242\":6}}],[\"non\",{\"1\":{\"242\":1}}],[\"nosuchelementexception\",{\"1\":{\"248\":1}}],[\"nosuchmethodexception\",{\"1\":{\"211\":2,\"220\":1,\"254\":1}}],[\"nosuchfieldexception\",{\"1\":{\"133\":2}}],[\"nothing\",{\"1\":{\"246\":1}}],[\"not\",{\"1\":{\"182\":3,\"242\":1,\"248\":3,\"326\":1}}],[\"notify相比\",{\"0\":{\"65\":1}}],[\"notify原理\",{\"0\":{\"60\":1}}],[\"notifyall\",{\"1\":{\"59\":2,\"60\":1,\"65\":2}}],[\"notify\",{\"0\":{\"80\":1},\"1\":{\"59\":2,\"60\":1,\"65\":4,\"79\":2,\"80\":3,\"81\":1}}],[\"no\",{\"1\":{\"182\":1}}],[\"now\",{\"1\":{\"101\":2}}],[\"normal\",{\"1\":{\"77\":1}}],[\"numinvocations\",{\"1\":{\"254\":2}}],[\"number\",{\"1\":{\"71\":1,\"227\":5,\"246\":1}}],[\"nullpointerexception\",{\"1\":{\"210\":3}}],[\"null\",{\"1\":{\"71\":1,\"83\":2,\"84\":1,\"120\":2,\"132\":3,\"133\":2,\"139\":1,\"146\":1,\"147\":1,\"211\":2,\"220\":1,\"221\":1,\"226\":3,\"240\":1,\"242\":4,\"245\":1,\"246\":3,\"248\":2,\"254\":1}}],[\"重写\",{\"1\":{\"243\":1}}],[\"重新执行\",{\"1\":{\"241\":1}}],[\"重新开始\",{\"1\":{\"162\":1}}],[\"重新标记阶段会stw\",{\"1\":{\"168\":1}}],[\"重新标记阶段\",{\"1\":{\"168\":1}}],[\"重新标记\",{\"1\":{\"161\":1}}],[\"重新竞争\",{\"1\":{\"60\":1}}],[\"重偏向会重置对象\",{\"1\":{\"81\":1}}],[\"重用作为\",{\"1\":{\"79\":1}}],[\"重置\",{\"1\":{\"71\":2}}],[\"重量级锁是\",{\"1\":{\"87\":1}}],[\"重量级锁\",{\"1\":{\"87\":1}}],[\"重量级锁会在\",{\"1\":{\"78\":1}}],[\"重量级\",{\"1\":{\"70\":1}}],[\"更新\",{\"1\":{\"167\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"6\":1}}],[\"更新时间\",{\"1\":{\"3\":1,\"56\":1}}],[\"更轻量级的同步机制\",{\"1\":{\"68\":1}}],[\"会直接返回null\",{\"1\":{\"270\":1}}],[\"会直接覆盖这段内存\",{\"1\":{\"149\":1}}],[\"会发现即使不加\",{\"1\":{\"262\":1}}],[\"会发生垃圾回收\",{\"1\":{\"127\":1}}],[\"会采用运行时生成的类代替掉最初的实现\",{\"1\":{\"254\":1}}],[\"会进行内联\",{\"1\":{\"252\":1}}],[\"会到\",{\"1\":{\"245\":1}}],[\"会初始化类\",{\"1\":{\"237\":1}}],[\"会导致\",{\"1\":{\"238\":1}}],[\"会导致初始化\",{\"1\":{\"237\":1}}],[\"会导致偏向锁被撤销\",{\"1\":{\"78\":1}}],[\"会被转换为\",{\"1\":{\"226\":1}}],[\"会被编译器转换为\",{\"1\":{\"223\":2}}],[\"会吞掉异常\",{\"1\":{\"213\":2}}],[\"会返回操作数栈顶的整型值\",{\"1\":{\"213\":1}}],[\"会抛出其他异常\",{\"1\":{\"212\":1}}],[\"会抛异常\",{\"1\":{\"146\":1}}],[\"会执行finally\",{\"1\":{\"212\":2}}],[\"会消耗掉栈顶一个引用\",{\"1\":{\"198\":1}}],[\"会更频繁地触发\",{\"1\":{\"176\":1}}],[\"会使得吞吐量下降\",{\"1\":{\"176\":1}}],[\"会使用extclassloader来尝试加载\",{\"1\":{\"242\":1}}],[\"会使用\",{\"1\":{\"12\":1}}],[\"会回收最有价值的老年代\",{\"1\":{\"165\":1}}],[\"会回收新生代\",{\"1\":{\"133\":1}}],[\"会stw\",{\"1\":{\"165\":2}}],[\"会对e\",{\"1\":{\"165\":1}}],[\"会对新生代\",{\"1\":{\"162\":1}}],[\"会重新进入新生代收集\",{\"1\":{\"162\":1}}],[\"会先尝试触发minorgc\",{\"1\":{\"153\":1}}],[\"会晋升至老年代\",{\"1\":{\"153\":1}}],[\"会引发\",{\"1\":{\"153\":1,\"237\":2}}],[\"会占用双倍的内存空间\",{\"1\":{\"151\":1}}],[\"会触发\",{\"1\":{\"146\":1}}],[\"会造成程序执行的时间比较长\",{\"1\":{\"133\":1}}],[\"会加上下面的参数\",{\"1\":{\"133\":1}}],[\"会在系统内存中创建一个缓冲区\",{\"1\":{\"131\":1}}],[\"会把符号\",{\"1\":{\"123\":3}}],[\"会把串池中的对象返回\",{\"1\":{\"123\":2}}],[\"会\",{\"1\":{\"108\":2,\"176\":1}}],[\"会将堆划分为多个大小相等的\",{\"1\":{\"162\":1}}],[\"会将该对象直接晋升为老年代\",{\"1\":{\"156\":1}}],[\"会将该字符串对象复制一份\",{\"1\":{\"125\":1}}],[\"会将该字符串对象尝试放入到串池中\",{\"1\":{\"123\":1,\"125\":1}}],[\"会将\",{\"1\":{\"144\":1}}],[\"会将内存位置\",{\"1\":{\"91\":1}}],[\"会将偏向锁升级为轻量级锁\",{\"1\":{\"79\":1}}],[\"会这样觉得\",{\"1\":{\"81\":1,\"82\":1}}],[\"会插入一个内存屏障来防止指令重排序\",{\"1\":{\"68\":1}}],[\"屏障\",{\"1\":{\"68\":1}}],[\"示例\",{\"1\":{\"68\":1,\"179\":1}}],[\"7以后就存储在\",{\"1\":{\"233\":1}}],[\"7以前是存储与instanceklass末尾\",{\"1\":{\"233\":1}}],[\"7项\",{\"1\":{\"182\":1}}],[\"70\",{\"1\":{\"179\":1,\"182\":2}}],[\"79\",{\"1\":{\"179\":1,\"182\":2}}],[\"77\",{\"1\":{\"179\":1,\"182\":2}}],[\"76\",{\"1\":{\"179\":10,\"182\":17}}],[\"763\",{\"1\":{\"120\":1}}],[\"73\",{\"1\":{\"179\":6,\"182\":13}}],[\"72\",{\"1\":{\"179\":18,\"182\":35}}],[\"75\",{\"1\":{\"179\":3,\"182\":7}}],[\"74\",{\"1\":{\"179\":21,\"182\":38}}],[\"7mb\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"7\",{\"0\":{\"126\":1,\"197\":1,\"206\":1,\"223\":1},\"1\":{\"67\":1,\"81\":4,\"119\":1,\"123\":4,\"155\":1,\"156\":1,\"157\":1,\"178\":1,\"182\":2,\"188\":2,\"193\":1,\"196\":1,\"197\":2,\"198\":2,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"219\":2,\"220\":2,\"223\":1,\"225\":1,\"226\":2}}],[\"60163\",{\"1\":{\"253\":1}}],[\"6000\",{\"1\":{\"80\":1}}],[\"6项\",{\"1\":{\"182\":1}}],[\"67\",{\"1\":{\"179\":9,\"182\":16}}],[\"6a\",{\"1\":{\"179\":11,\"182\":20}}],[\"68\",{\"1\":{\"179\":3,\"182\":8}}],[\"63649\",{\"1\":{\"253\":1}}],[\"63\",{\"1\":{\"179\":7,\"182\":15}}],[\"6c\",{\"1\":{\"179\":23,\"182\":44}}],[\"61\",{\"1\":{\"179\":34,\"182\":66}}],[\"6d\",{\"1\":{\"179\":8,\"182\":15}}],[\"65是\",{\"1\":{\"182\":2}}],[\"65\",{\"1\":{\"179\":19,\"182\":41}}],[\"6f\",{\"1\":{\"179\":15,\"182\":32}}],[\"6e\",{\"1\":{\"179\":17,\"182\":36}}],[\"697\",{\"1\":{\"253\":1}}],[\"69\",{\"1\":{\"179\":17,\"182\":42}}],[\"694\",{\"1\":{\"132\":1}}],[\"6mb\",{\"1\":{\"155\":4,\"156\":1,\"157\":1}}],[\"62\",{\"1\":{\"77\":2,\"179\":5,\"182\":14}}],[\"647\",{\"1\":{\"253\":1}}],[\"642\",{\"1\":{\"120\":1}}],[\"64\",{\"1\":{\"77\":1,\"179\":6,\"182\":15}}],[\"6\",{\"0\":{\"123\":1,\"129\":1,\"130\":1,\"131\":1,\"133\":1,\"178\":1,\"196\":1,\"205\":1,\"214\":1,\"222\":1,\"249\":1,\"250\":1,\"254\":1},\"1\":{\"67\":1,\"71\":3,\"76\":1,\"81\":4,\"106\":1,\"119\":1,\"123\":6,\"125\":1,\"126\":1,\"155\":1,\"156\":1,\"157\":1,\"182\":3,\"183\":1,\"188\":2,\"194\":3,\"195\":2,\"198\":1,\"205\":5,\"211\":1,\"219\":1,\"220\":2,\"226\":1,\"273\":1}}],[\"5502\",{\"1\":{\"263\":1}}],[\"594\",{\"1\":{\"253\":1}}],[\"5项\",{\"1\":{\"182\":1}}],[\"52\",{\"1\":{\"181\":2,\"188\":1}}],[\"50280576\",{\"1\":{\"263\":1}}],[\"50000\",{\"1\":{\"256\":2,\"258\":2}}],[\"5000\",{\"1\":{\"256\":1}}],[\"500\",{\"1\":{\"252\":1}}],[\"50\",{\"1\":{\"179\":3,\"182\":5,\"210\":2}}],[\"507\",{\"1\":{\"85\":1}}],[\"539\",{\"1\":{\"253\":1}}],[\"53\",{\"1\":{\"179\":7,\"182\":10}}],[\"5b\",{\"1\":{\"179\":2,\"182\":2}}],[\"57\",{\"1\":{\"179\":3,\"182\":7}}],[\"572\",{\"1\":{\"85\":1}}],[\"56\",{\"1\":{\"179\":4,\"182\":11,\"183\":4}}],[\"5与\",{\"1\":{\"158\":1}}],[\"512\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"512kb\",{\"1\":{\"155\":3,\"156\":1,\"157\":1}}],[\"518\",{\"1\":{\"85\":1}}],[\"542\",{\"1\":{\"85\":1}}],[\"54\",{\"1\":{\"77\":1,\"179\":2,\"182\":6}}],[\"5\",{\"0\":{\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":2,\"123\":1,\"126\":1,\"127\":1,\"128\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":2,\"178\":1,\"191\":1,\"195\":1,\"204\":1,\"213\":1,\"221\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2},\"1\":{\"67\":1,\"71\":2,\"81\":4,\"85\":4,\"94\":1,\"97\":1,\"106\":3,\"123\":6,\"146\":3,\"182\":1,\"183\":1,\"188\":2,\"192\":2,\"194\":1,\"195\":4,\"196\":1,\"197\":3,\"198\":1,\"209\":2,\"210\":4,\"211\":2,\"212\":3,\"213\":2,\"214\":2,\"215\":1,\"218\":3,\"219\":2,\"220\":3,\"221\":1,\"222\":5,\"237\":2,\"245\":1,\"251\":1,\"253\":7,\"273\":1}}],[\"也\",{\"1\":{\"262\":1}}],[\"也同时保证代码块内变量的可见性\",{\"1\":{\"262\":1}}],[\"也运行到了\",{\"1\":{\"258\":1}}],[\"也是类似\",{\"1\":{\"256\":1}}],[\"也是可以让\",{\"1\":{\"245\":1}}],[\"也是java并发包中的核心组件之一\",{\"1\":{\"92\":1}}],[\"也没有值\",{\"1\":{\"182\":1}}],[\"也就是如果在\",{\"1\":{\"213\":1}}],[\"也就是检测2~4行\",{\"1\":{\"209\":1}}],[\"也就是\",{\"1\":{\"158\":1}}],[\"也就是没有竞争\",{\"1\":{\"83\":1}}],[\"也无法容纳该对象时\",{\"1\":{\"156\":1}}],[\"也可以追加\",{\"1\":{\"240\":1}}],[\"也可以在idea控制台输入\",{\"1\":{\"121\":1}}],[\"也可以先unpark后park\",{\"1\":{\"62\":1}}],[\"也来执行\",{\"1\":{\"71\":1}}],[\"也不能保证线程安全\",{\"1\":{\"67\":1}}],[\"被破坏\",{\"1\":{\"243\":3}}],[\"被同一个\",{\"1\":{\"239\":1}}],[\"被分为了两个\",{\"1\":{\"223\":1}}],[\"被插入了所有可能的流程\",{\"1\":{\"213\":1}}],[\"被final修饰的方法\",{\"1\":{\"198\":1}}],[\"被回收时\",{\"1\":{\"146\":1}}],[\"被回收以后\",{\"1\":{\"132\":1}}],[\"被引用对象暂时没有被回收\",{\"1\":{\"145\":1}}],[\"被引用对象回收时\",{\"1\":{\"144\":1}}],[\"被jc\",{\"1\":{\"115\":1}}],[\"被翻译为监视器或管程\",{\"0\":{\"70\":1}}],[\"被声明为\",{\"1\":{\"67\":1}}],[\"被定义出来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"65\":1}}],[\"即尝试获得对象的锁\",{\"1\":{\"258\":1}}],[\"即时编译器\",{\"1\":{\"251\":2}}],[\"即时编译器编译执行\",{\"1\":{\"251\":4}}],[\"即时编译\",{\"0\":{\"250\":1}}],[\"即jdk1\",{\"1\":{\"243\":1}}],[\"即类加载器\",{\"1\":{\"230\":1}}],[\"即常量池\",{\"1\":{\"230\":1}}],[\"即方法\",{\"1\":{\"230\":1}}],[\"即成员变量\",{\"1\":{\"230\":1}}],[\"即父类\",{\"1\":{\"230\":1}}],[\"即枚举元素对应所在的位置\",{\"1\":{\"224\":1}}],[\"即未传递参数时\",{\"1\":{\"221\":1}}],[\"即泛型信息在编译为字节码之后就丢失了\",{\"1\":{\"219\":1}}],[\"即调用\",{\"1\":{\"217\":1}}],[\"即调用父类\",{\"1\":{\"217\":1}}],[\"即支持多态\",{\"1\":{\"198\":2}}],[\"即cpu用于运行用户代码的时间与cpu总消耗时间的比值\",{\"1\":{\"158\":1}}],[\"即一般说的native方法\",{\"1\":{\"138\":1}}],[\"即计数变为0时\",{\"1\":{\"135\":1}}],[\"即没有可用的许可\",{\"1\":{\"95\":1}}],[\"即发生竞争\",{\"1\":{\"87\":1}}],[\"即按照\",{\"1\":{\"84\":1}}],[\"即为\",{\"1\":{\"84\":1,\"204\":1}}],[\"即语法仍然是\",{\"1\":{\"83\":1}}],[\"即使这两个类来源于同一个\",{\"1\":{\"239\":1}}],[\"即使\",{\"1\":{\"67\":1}}],[\"即\",{\"1\":{\"67\":1,\"192\":1,\"204\":1,\"224\":1,\"230\":1,\"246\":1,\"254\":1}}],[\"即可进入\",{\"1\":{\"60\":1}}],[\"递增操作\",{\"1\":{\"67\":1}}],[\"例如在$java\",{\"1\":{\"242\":1}}],[\"例如对于\",{\"1\":{\"256\":1}}],[\"例如对\",{\"1\":{\"230\":1}}],[\"例如运行时常量池\",{\"1\":{\"118\":1}}],[\"例如\",{\"1\":{\"67\":1,\"68\":1,\"85\":1,\"158\":1,\"169\":1,\"195\":1,\"221\":1,\"223\":2,\"226\":2,\"251\":1}}],[\"变量都是直接操作主存\",{\"1\":{\"262\":1}}],[\"变量的修改对另一\",{\"1\":{\"263\":1}}],[\"变量的修改对于\",{\"1\":{\"260\":1}}],[\"变量的修改了\",{\"1\":{\"262\":1}}],[\"变量的写操作在执行时不能被编译器或处理器重排序到之前的任何时刻\",{\"1\":{\"67\":1}}],[\"变量是\",{\"1\":{\"233\":2}}],[\"变量分配空间\",{\"1\":{\"233\":1}}],[\"变量不能为null\",{\"1\":{\"223\":1}}],[\"变量类型修改为\",{\"1\":{\"219\":1}}],[\"变量对象创建字符串的过程\",{\"1\":{\"123\":1}}],[\"变量只涉及局部变量\",{\"1\":{\"85\":1}}],[\"变量时\",{\"1\":{\"68\":1}}],[\"变量被声明为\",{\"1\":{\"68\":1}}],[\"变量写操作之前的所有操作都将在写操作之前完成\",{\"1\":{\"67\":1}}],[\"变为\",{\"1\":{\"60\":1,\"123\":3}}],[\"禁止某个方法\",{\"1\":{\"252\":1}}],[\"禁止指令重排序\",{\"1\":{\"67\":1}}],[\"禁用指针压缩\",{\"1\":{\"199\":1}}],[\"禁用\",{\"2\":{\"5\":1,\"58\":1}}],[\"禁用了如下功能\",{\"1\":{\"3\":1,\"56\":1}}],[\"作为被压制异常添加\",{\"1\":{\"226\":1}}],[\"作为重入的计数\",{\"1\":{\"83\":1}}],[\"作用是把\",{\"1\":{\"230\":1}}],[\"作用是生产类的二进制字节码\",{\"1\":{\"120\":1}}],[\"作用\",{\"0\":{\"67\":1},\"1\":{\"106\":1}}],[\"作者设置为\",{\"1\":{\"27\":1,\"281\":1}}],[\"任何对象都有一个monitor与之关联\",{\"1\":{\"258\":1}}],[\"任何线程对volatile变量的修改\",{\"1\":{\"66\":1}}],[\"任务列表\",{\"0\":{\"19\":1}}],[\"告诉jvm编译器和处理器\",{\"1\":{\"66\":1}}],[\"含义参数堆初始大小\",{\"1\":{\"155\":1}}],[\"含义\",{\"0\":{\"66\":1},\"1\":{\"194\":1}}],[\"理解并正确使用这些概念对于编写正确\",{\"1\":{\"65\":1}}],[\"理解成泊车\",{\"1\":{\"62\":1}}],[\"理解成停车场\",{\"1\":{\"62\":1}}],[\"理解成订单\",{\"1\":{\"62\":1}}],[\"指的是一些非常\",{\"1\":{\"243\":1}}],[\"指用户线程与垃圾收集线程同时工作\",{\"1\":{\"158\":1}}],[\"指多条垃圾收集线程并行工作\",{\"1\":{\"158\":1}}],[\"指定堆内存大小\",{\"1\":{\"127\":1}}],[\"指定元空间大小\",{\"1\":{\"120\":1}}],[\"指定永久代内存大小\",{\"1\":{\"120\":1}}],[\"指定栈内存大小\",{\"1\":{\"109\":1}}],[\"指令并行优化的影响\",{\"1\":{\"254\":1}}],[\"指令优化等\",{\"1\":{\"254\":1}}],[\"指令时\",{\"1\":{\"207\":1,\"258\":1}}],[\"指令来调用\",{\"1\":{\"198\":1}}],[\"指令\",{\"1\":{\"194\":1,\"198\":1}}],[\"指令是直接在局部变量\",{\"1\":{\"193\":1}}],[\"指令的执行地址行号\",{\"1\":{\"106\":1}}],[\"指令可能会以不同于编写代码时的顺序执行\",{\"1\":{\"65\":1}}],[\"指向重量级锁地址\",{\"1\":{\"84\":1}}],[\"指向锁对象\",{\"1\":{\"83\":1}}],[\"指向类的指针\",{\"1\":{\"72\":1}}],[\"指针\",{\"1\":{\"71\":1,\"203\":1}}],[\"指南\",{\"2\":{\"7\":1}}],[\"由下面的\",{\"1\":{\"164\":1}}],[\"由于\",{\"1\":{\"213\":1}}],[\"由于内存不连续\",{\"1\":{\"149\":1}}],[\"由于编译器优化\",{\"1\":{\"65\":1}}],[\"由\",{\"1\":{\"144\":1}}],[\"由三部分组成\",{\"1\":{\"62\":1}}],[\"因为在创建candy11$1对象时\",{\"1\":{\"228\":1}}],[\"因为在创建\",{\"1\":{\"228\":1}}],[\"因为字符串的\",{\"1\":{\"223\":1}}],[\"因为集合的遍历需要用到迭代器\",{\"1\":{\"222\":1}}],[\"因为异常出现时\",{\"1\":{\"210\":1}}],[\"因为普通成员方法需要在运行时才能确定具体的内容\",{\"1\":{\"199\":1}}],[\"因为编译期间无法确定该方法的内容\",{\"1\":{\"198\":1}}],[\"因为涉及运算操作\",{\"1\":{\"196\":1}}],[\"因为操作数栈都是\",{\"1\":{\"194\":1}}],[\"因为只能在操作数栈中执行运算操作\",{\"1\":{\"192\":1}}],[\"因为指定了最大停顿时间\",{\"1\":{\"165\":1}}],[\"因为是串行的\",{\"1\":{\"159\":1}}],[\"因为java对象头只用4个bit来表示\",{\"1\":{\"153\":1}}],[\"因为java有时候没法直接和操作系统底层交互\",{\"1\":{\"111\":1}}],[\"因为stringtable是由hashtable实现的\",{\"1\":{\"128\":1}}],[\"因为s3是存在于串池之中\",{\"1\":{\"123\":1}}],[\"因为内容是变量\",{\"1\":{\"123\":1}}],[\"因为内容是常量\",{\"1\":{\"123\":1}}],[\"因为物理内存是一定的\",{\"1\":{\"108\":1}}],[\"因为它们避免了使用重量级的锁机制\",{\"1\":{\"101\":1}}],[\"因为\",{\"1\":{\"79\":1,\"131\":1,\"146\":1,\"192\":1,\"238\":1,\"256\":1,\"260\":1}}],[\"因为变量的值可能被缓存在寄存器或者线程私有内存中\",{\"1\":{\"65\":1}}],[\"因此次他有如下几个使用场景\",{\"1\":{\"272\":1}}],[\"因此返回结果肯定以\",{\"1\":{\"213\":1}}],[\"因此只有对象头的\",{\"1\":{\"203\":1}}],[\"因此编译器就会帮我们省去这些锁\",{\"1\":{\"85\":1}}],[\"因此可以借助于\",{\"1\":{\"12\":1}}],[\"因此\",{\"1\":{\"9\":1,\"94\":1,\"246\":1}}],[\"内部类中保存单例\",{\"1\":{\"238\":1}}],[\"内部采用\",{\"1\":{\"230\":1}}],[\"内部可以存储锁定对象的mark\",{\"1\":{\"83\":1}}],[\"内暂停时间\",{\"1\":{\"160\":1}}],[\"内存结构\",{\"1\":{\"254\":1}}],[\"内存结构图\",{\"1\":{\"119\":1}}],[\"内存地址\",{\"1\":{\"205\":1}}],[\"内存位置\",{\"1\":{\"91\":1}}],[\"内存\",{\"1\":{\"68\":1,\"119\":1,\"142\":1,\"173\":1}}],[\"内存模型\",{\"1\":{\"65\":1,\"254\":2}}],[\"内容\",{\"1\":{\"12\":1}}],[\"可通过在控制台输入指令\",{\"1\":{\"240\":1}}],[\"可变参数也是\",{\"1\":{\"221\":1}}],[\"可变参数\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"可参考\",{\"1\":{\"184\":1}}],[\"可防止多个线程创建对象时的干扰\",{\"1\":{\"176\":1}}],[\"可预测的停顿时间标记\",{\"1\":{\"158\":1}}],[\"可达性分析算法\",{\"0\":{\"137\":1}}],[\"可能任然会有新的垃圾产生\",{\"1\":{\"161\":1}}],[\"可能导致cpu的占用过高\",{\"1\":{\"110\":1}}],[\"可能会导致数据库直接宕机\",{\"1\":{\"269\":1}}],[\"可能会有其他线程使用这个对象\",{\"1\":{\"108\":1}}],[\"可能会唤醒等待的线程\",{\"1\":{\"95\":1}}],[\"可扩展的线程池类\",{\"1\":{\"92\":1}}],[\"可重入性\",{\"1\":{\"88\":1}}],[\"可见性是指当一个线程修改了共享变量的值\",{\"1\":{\"65\":1}}],[\"可见性是并发编程中非常重要的基础概念\",{\"1\":{\"65\":1}}],[\"可见性\",{\"0\":{\"259\":1,\"263\":1},\"1\":{\"65\":1,\"88\":1,\"254\":1}}],[\"可以把\",{\"1\":{\"258\":1}}],[\"可以节省\",{\"1\":{\"253\":1}}],[\"可以顺利完成类加载\",{\"1\":{\"246\":1}}],[\"可以\",{\"1\":{\"227\":1}}],[\"可以不用写\",{\"1\":{\"226\":1}}],[\"可以作用于字符串和枚举类\",{\"1\":{\"223\":1}}],[\"可以作为\",{\"0\":{\"138\":1}}],[\"可以得到相同的结果\",{\"1\":{\"205\":1}}],[\"可以看改类的静态代码块是否被执行\",{\"1\":{\"237\":1}}],[\"可以看出加了synchronized\",{\"1\":{\"262\":1}}],[\"可以看出\",{\"1\":{\"221\":1}}],[\"可以看到\",{\"1\":{\"212\":1,\"220\":1}}],[\"可以看到多出来一个\",{\"1\":{\"209\":1}}],[\"可以看到在调用invokestatic\",{\"1\":{\"198\":1}}],[\"可以看下go语言的垃圾三色标记机制\",{\"1\":{\"153\":1}}],[\"可以根据参数去查询具体的信息\",{\"1\":{\"172\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"9\":1}}],[\"可以动态调整\",{\"1\":{\"171\":1}}],[\"可以控制一次回收多少个小区间\",{\"1\":{\"163\":1}}],[\"可以搭配\",{\"1\":{\"161\":1}}],[\"可以配合\",{\"1\":{\"142\":1,\"143\":1}}],[\"可以通过前面介绍的\",{\"1\":{\"230\":1}}],[\"可以通过hsdb工具查看\",{\"1\":{\"230\":1}}],[\"可以通过\",{\"1\":{\"128\":1,\"204\":1,\"254\":1}}],[\"可以通过管道进行消息传递来实现协程间的通信\",{\"1\":{\"59\":1}}],[\"可以使用阿里的\",{\"1\":{\"254\":1}}],[\"可以使用\",{\"1\":{\"159\":1,\"251\":1}}],[\"可以使用如下命令将堆内存信息转储成一个文件\",{\"1\":{\"139\":1}}],[\"可以使用intern方法\",{\"1\":{\"123\":1}}],[\"可以使用锁粗化方式来优化\",{\"1\":{\"86\":1}}],[\"可以用这个办法替换核心类\",{\"1\":{\"240\":1}}],[\"可以用来加载类的二进制字节码\",{\"1\":{\"120\":1}}],[\"可以用于构建各种同步器\",{\"1\":{\"92\":1}}],[\"可以连续监测\",{\"1\":{\"116\":1}}],[\"可以支持更多的递归调用\",{\"1\":{\"108\":1}}],[\"可以被比\",{\"1\":{\"98\":1}}],[\"可以创建一个公平的semaphore\",{\"1\":{\"95\":1}}],[\"可以禁止某些重排序\",{\"1\":{\"65\":1}}],[\"可以先park\",{\"1\":{\"62\":1}}],[\"有\",{\"1\":{\"230\":1}}],[\"有可能相等\",{\"1\":{\"223\":1}}],[\"有可能黑色a被处理了以后未引用c\",{\"1\":{\"168\":1}}],[\"有一个类型转换的操作\",{\"1\":{\"219\":1}}],[\"有两个参数\",{\"1\":{\"204\":1}}],[\"有两种情况\",{\"1\":{\"83\":1}}],[\"有的没拷贝\",{\"1\":{\"165\":1}}],[\"有垃圾回收机制\",{\"1\":{\"114\":1}}],[\"有点像一个停车场\",{\"1\":{\"94\":1}}],[\"有竞争\",{\"1\":{\"84\":1}}],[\"有序性是指程序执行的顺序按照代码的先后顺序进行\",{\"1\":{\"65\":1}}],[\"有序性\",{\"1\":{\"65\":2,\"88\":1,\"254\":2}}],[\"有atomic子包\",{\"1\":{\"59\":1}}],[\"写屏障的指令会被执行\",{\"1\":{\"168\":1}}],[\"写操作之前执行\",{\"1\":{\"68\":1}}],[\"写操作在该屏障之后的所有读\",{\"1\":{\"68\":1}}],[\"写共享变量的副本\",{\"1\":{\"65\":1}}],[\"写作日期为\",{\"1\":{\"27\":1,\"281\":1}}],[\"本例即为\",{\"1\":{\"198\":1}}],[\"本类为\",{\"1\":{\"183\":1}}],[\"本地方法栈中jni\",{\"1\":{\"138\":1}}],[\"本地方法栈\",{\"0\":{\"111\":1}}],[\"本地内存中存储了该线程以读\",{\"1\":{\"65\":1}}],[\"本地内存\",{\"1\":{\"65\":1}}],[\"本页面就是一个示例\",{\"1\":{\"3\":1,\"56\":1}}],[\"但不能保证原子性\",{\"1\":{\"262\":1}}],[\"但不做任何处理\",{\"1\":{\"242\":1}}],[\"但两者的实现细节不一样\",{\"1\":{\"258\":1}}],[\"但多线程下这\",{\"1\":{\"256\":1}}],[\"但如果\",{\"1\":{\"253\":1}}],[\"但会加载\",{\"1\":{\"237\":2}}],[\"但属于引用类型\",{\"1\":{\"233\":1}}],[\"但在jdk\",{\"1\":{\"233\":1}}],[\"但\",{\"1\":{\"219\":1,\"230\":2,\"245\":1,\"262\":1}}],[\"但未被exception捕获\",{\"1\":{\"212\":1}}],[\"但目前看不到它的实际地址\",{\"1\":{\"203\":1}}],[\"但原始构造方法内的代码总是在后\",{\"1\":{\"197\":1}}],[\"但此时用户线程\",{\"1\":{\"158\":1}}],[\"但其内部配合\",{\"1\":{\"145\":1}}],[\"但jvm并不能回收直接内存中的内容\",{\"1\":{\"132\":1}}],[\"但读写性能高\",{\"1\":{\"130\":1}}],[\"但字符串的值和拼接的字符串一致\",{\"1\":{\"123\":1}}],[\"但这是a\",{\"1\":{\"123\":1}}],[\"但简单的实现可能不会选择垃圾收集或压缩它\",{\"1\":{\"118\":1}}],[\"但由于\",{\"1\":{\"94\":1}}],[\"但是可能存在一些非法用户\",{\"1\":{\"269\":1}}],[\"但是可执行的线程数就会越少\",{\"1\":{\"108\":1}}],[\"但是finally块中的代码只会被执行一次\",{\"1\":{\"212\":1}}],[\"但是在并发标记过程中\",{\"1\":{\"168\":1}}],[\"但是在单线程运行环境下\",{\"1\":{\"85\":1}}],[\"但是会产生内存碎片\",{\"1\":{\"161\":1}}],[\"但是会占用双倍的内存空间\",{\"1\":{\"151\":1}}],[\"但是软引用还存在\",{\"1\":{\"146\":1}}],[\"但是直接内存中的内存还未被回收\",{\"1\":{\"144\":1}}],[\"但是两个不同的字符串\",{\"1\":{\"123\":1}}],[\"但是不保证原子性\",{\"1\":{\"65\":1}}],[\"但加锁的时间是错开的\",{\"1\":{\"83\":1}}],[\"但没有竞争\",{\"1\":{\"81\":1}}],[\"但偏向锁的对象\",{\"1\":{\"78\":1}}],[\"但条件不满足进入\",{\"1\":{\"71\":1}}],[\"但它显示为null\",{\"1\":{\"242\":1}}],[\"但它在java程序中起到的作用却远超类加载阶段\",{\"1\":{\"239\":1}}],[\"但它的使用场景有限\",{\"1\":{\"68\":1}}],[\"但它并不保证复合操作的原子性\",{\"1\":{\"67\":1}}],[\"但它们的关注点不同\",{\"1\":{\"65\":1}}],[\"但唤醒后并不意味者立刻获得锁\",{\"1\":{\"60\":1}}],[\"精确\",{\"1\":{\"65\":1}}],[\"唤醒线程\",{\"1\":{\"101\":1}}],[\"唤醒\",{\"1\":{\"65\":1,\"71\":2,\"84\":1}}],[\"阻塞当前线程\",{\"1\":{\"101\":2}}],[\"阻塞\",{\"1\":{\"65\":1,\"94\":1,\"159\":1}}],[\"阻塞等待订单\",{\"1\":{\"63\":1}}],[\"而monitorexit是插入到方法结束处和异常处\",{\"1\":{\"258\":1}}],[\"而对应\",{\"1\":{\"256\":1}}],[\"而言\",{\"1\":{\"256\":1}}],[\"而不是直接传递的\",{\"1\":{\"221\":1}}],[\"而不是在各个线程的缓存中\",{\"1\":{\"59\":1}}],[\"而且触发\",{\"1\":{\"176\":1}}],[\"而且替代了cms\",{\"1\":{\"162\":1}}],[\"而且其他线程可以从主内存中读取最新的值\",{\"1\":{\"66\":1}}],[\"而垃圾收集程序运行在另一个cpu上\",{\"1\":{\"158\":1}}],[\"而是采取解释执行的方式运行\",{\"1\":{\"251\":1}}],[\"而是把类加载请求委派给bootstrapclassloader去完成\",{\"1\":{\"242\":1}}],[\"而是把类加载请求委派给父类加载器extclassloader去完成\",{\"1\":{\"242\":1}}],[\"而是记录这段内存的起始地址\",{\"1\":{\"149\":1}}],[\"而是通过unsafe\",{\"1\":{\"132\":1}}],[\"而softreference和byte数组则是软引用\",{\"1\":{\"146\":2}}],[\"而创建ab的时候已经在串池中放入了\",{\"1\":{\"123\":1}}],[\"而非公平的semaphore则可能允许线程饥饿\",{\"1\":{\"95\":1}}],[\"而线程通信关注的是线程之间如何协作完成任务\",{\"1\":{\"65\":1}}],[\"而\",{\"1\":{\"65\":3,\"94\":1,\"223\":1,\"256\":1,\"260\":1}}],[\"不带\",{\"1\":{\"251\":1}}],[\"不写\",{\"1\":{\"245\":1}}],[\"不知道你注意到没有\",{\"1\":{\"245\":1}}],[\"不冲突\",{\"1\":{\"243\":1}}],[\"不同应用的同名类都可以加载\",{\"1\":{\"243\":1}}],[\"不同方法在调用时\",{\"1\":{\"198\":1}}],[\"不同的东西有不同的魔数\",{\"1\":{\"180\":1}}],[\"不一定是并行的可能会交替执行\",{\"1\":{\"158\":1}}],[\"不能解\",{\"1\":{\"263\":1}}],[\"不能保证原子性\",{\"1\":{\"263\":1}}],[\"不能直接操作文件管理\",{\"1\":{\"131\":1}}],[\"不能先\",{\"1\":{\"65\":1}}],[\"不受jvm内存回收管理\",{\"1\":{\"130\":1}}],[\"不可扩容\",{\"1\":{\"123\":1}}],[\"不断地向list\",{\"1\":{\"115\":1}}],[\"不是重写\",{\"1\":{\"243\":1}}],[\"不是\",{\"1\":{\"108\":1,\"176\":1}}],[\"不是一个原子操作\",{\"1\":{\"67\":1}}],[\"不会交错\",{\"1\":{\"256\":1}}],[\"不会初始化类\",{\"1\":{\"237\":2}}],[\"不会触发初始化\",{\"1\":{\"237\":3}}],[\"不会触发full\",{\"1\":{\"166\":1}}],[\"不会抛出异常\",{\"1\":{\"213\":1}}],[\"不会列入\",{\"1\":{\"205\":1}}],[\"不会stw\",{\"1\":{\"164\":1}}],[\"不会让其他的线程结束运行\",{\"1\":{\"157\":1}}],[\"不会有内存碎片\",{\"1\":{\"150\":1,\"151\":1}}],[\"不会\",{\"1\":{\"108\":2}}],[\"不会存在内存溢出\",{\"1\":{\"106\":1}}],[\"不涉及修改操作\",{\"1\":{\"85\":1}}],[\"不用重新\",{\"1\":{\"76\":1}}],[\"不用阻塞等待\",{\"1\":{\"64\":1}}],[\"不遵从以上规则\",{\"1\":{\"71\":1}}],[\"不加\",{\"1\":{\"71\":1}}],[\"不占用\",{\"1\":{\"60\":1}}],[\"立马处理\",{\"1\":{\"64\":1}}],[\"先来看一个现象\",{\"1\":{\"260\":1}}],[\"先看\",{\"1\":{\"246\":1}}],[\"先不看别的\",{\"1\":{\"245\":1}}],[\"先让拓展类加载器调用\",{\"1\":{\"242\":1}}],[\"先加载父类\",{\"1\":{\"230\":1}}],[\"先通过栈帧中的对象引用找到对象\",{\"1\":{\"207\":1}}],[\"先通过栈帧中对象的引用找到对象\",{\"1\":{\"199\":1}}],[\"先执行\",{\"1\":{\"193\":1}}],[\"先尝试不做调优\",{\"1\":{\"177\":1}}],[\"先采用标记算法确定可回收对象\",{\"1\":{\"149\":1,\"150\":1}}],[\"先下个单\",{\"1\":{\"64\":1}}],[\"先unpark后park\",{\"0\":{\"64\":1}}],[\"先park\",{\"0\":{\"63\":1}}],[\"司机停车的时候发现有个订单\",{\"1\":{\"64\":1}}],[\"司机那边收到就开始工作\",{\"1\":{\"63\":1}}],[\"司机在停车场停车休息\",{\"1\":{\"63\":1}}],[\"下次遇到相同的代码\",{\"1\":{\"251\":1}}],[\"下次即使遇到相同的字节码\",{\"1\":{\"251\":1}}],[\"下次分配内存的时候\",{\"1\":{\"149\":1}}],[\"下显然没有\",{\"1\":{\"245\":1}}],[\"下搜索类\",{\"1\":{\"245\":1}}],[\"下找该类\",{\"1\":{\"242\":1}}],[\"下有同名类\",{\"1\":{\"241\":1}}],[\"下面的字节码省略了不重要的部分\",{\"1\":{\"209\":1}}],[\"下面各个方法会不会造成线程安全问题\",{\"1\":{\"108\":1}}],[\"下面是一个使用park和unpark的简单示例\",{\"1\":{\"101\":1}}],[\"下来的\",{\"1\":{\"94\":1}}],[\"下了个订单\",{\"1\":{\"63\":1}}],[\"下一篇\",{\"1\":{\"3\":1,\"56\":1}}],[\"执行它的\",{\"1\":{\"258\":1}}],[\"执行到\",{\"1\":{\"258\":1}}],[\"执行效率上简单比较一下\",{\"1\":{\"251\":1}}],[\"执行进行比较\",{\"1\":{\"223\":1}}],[\"执行了两遍\",{\"1\":{\"223\":1}}],[\"执行方法的字节码\",{\"1\":{\"199\":1,\"207\":1}}],[\"执行方法前是否需要\",{\"1\":{\"198\":1}}],[\"执行成功会将\",{\"1\":{\"198\":1}}],[\"执行完\",{\"1\":{\"258\":1}}],[\"执行完毕\",{\"1\":{\"192\":1}}],[\"执行完同步代码块的内容\",{\"1\":{\"71\":1}}],[\"执行新栈帧中的字节码\",{\"1\":{\"192\":1}}],[\"执行类的加载\",{\"1\":{\"120\":1}}],[\"执行线程的顶级接口\",{\"1\":{\"92\":1}}],[\"执行\",{\"1\":{\"71\":1,\"106\":1,\"179\":1,\"201\":1,\"202\":1,\"204\":1,\"205\":1}}],[\"执行任务\",{\"1\":{\"68\":1}}],[\"执行unpark\",{\"1\":{\"63\":1,\"64\":1}}],[\"执行park\",{\"1\":{\"63\":1,\"64\":1}}],[\"把\",{\"1\":{\"198\":1}}],[\"把unpark理解成出车\",{\"1\":{\"62\":1}}],[\"把park\",{\"1\":{\"62\":1}}],[\"打开\",{\"1\":{\"139\":1,\"202\":1}}],[\"打印编译信息\",{\"1\":{\"252\":1}}],[\"打印\",{\"1\":{\"127\":1,\"245\":1,\"252\":1}}],[\"打印字符串常量池信息\",{\"1\":{\"127\":1}}],[\"打印按钮\",{\"1\":{\"6\":1}}],[\"打个比喻\",{\"1\":{\"62\":1}}],[\"恢复某个线程的运行\",{\"1\":{\"62\":1}}],[\"ue\",{\"1\":{\"232\":1}}],[\"usecompressedclasspointers\",{\"1\":{\"199\":1}}],[\"usecompressedoops\",{\"1\":{\"199\":1}}],[\"users\",{\"1\":{\"188\":2}}],[\"usebiasedlocking\",{\"1\":{\"78\":1}}],[\"utf8\",{\"1\":{\"182\":24,\"188\":17}}],[\"util\",{\"1\":{\"59\":4,\"68\":1,\"101\":1,\"115\":1,\"219\":4,\"220\":8,\"253\":2}}],[\"u2\",{\"1\":{\"179\":11,\"181\":2}}],[\"u4\",{\"1\":{\"179\":1,\"180\":1}}],[\"up\",{\"1\":{\"132\":1}}],[\"unreservememory\",{\"1\":{\"132\":2}}],[\"unsafe\",{\"1\":{\"132\":4,\"133\":10}}],[\"units\",{\"1\":{\"85\":2,\"253\":2}}],[\"unused\",{\"1\":{\"77\":3}}],[\"unparked\",{\"1\":{\"101\":1}}],[\"unpark可以先\",{\"1\":{\"65\":1}}],[\"unpark是以线程为单位来\",{\"1\":{\"65\":1}}],[\"unpark不必\",{\"1\":{\"65\":1}}],[\"unpark\",{\"1\":{\"62\":1,\"65\":1,\"82\":2,\"94\":1,\"101\":3}}],[\"unpark原理\",{\"0\":{\"62\":1}}],[\"保证了每次run变量都会从主存中获取\",{\"1\":{\"262\":1}}],[\"保证了共享变量的可见性\",{\"1\":{\"262\":1}}],[\"保证了可见性和禁止指令重排序\",{\"1\":{\"67\":1}}],[\"保证指令不会受\",{\"1\":{\"254\":2}}],[\"保证指令不会受到线程上下文切换的影响\",{\"1\":{\"254\":1}}],[\"保证可见性\",{\"1\":{\"67\":1}}],[\"保证可见性和有序性\",{\"1\":{\"65\":1}}],[\"保证操作的有序性\",{\"1\":{\"65\":1}}],[\"保证对象初始化的安全性\",{\"1\":{\"59\":1}}],[\"保护性暂停\",{\"1\":{\"61\":1}}],[\"注册驱动的集合\",{\"1\":{\"245\":1}}],[\"注重服务的响应速度的场景并发收集\",{\"1\":{\"158\":1}}],[\"注意加上下面的\",{\"1\":{\"199\":1}}],[\"注意jstack查找出的线程id是16进制的\",{\"1\":{\"110\":1}}],[\"注意join\",{\"1\":{\"61\":1}}],[\"注意\",{\"1\":{\"71\":1,\"85\":1,\"98\":1,\"123\":1,\"149\":1,\"169\":1,\"182\":1,\"192\":1,\"193\":1,\"195\":1,\"212\":1,\"216\":1,\"221\":1,\"222\":1,\"223\":1,\"228\":1,\"230\":1,\"262\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"25\":1,\"268\":1,\"279\":1}}],[\"0<\",{\"1\":{\"274\":1}}],[\"0层\",{\"1\":{\"251\":1}}],[\"0x1b8\",{\"1\":{\"205\":1}}],[\"0x1000\",{\"1\":{\"182\":1}}],[\"0x9b\",{\"1\":{\"194\":1}}],[\"0x9a\",{\"1\":{\"194\":1}}],[\"0x99\",{\"1\":{\"194\":1}}],[\"0x4000\",{\"1\":{\"182\":1}}],[\"0x2000\",{\"1\":{\"182\":1}}],[\"0x0400\",{\"1\":{\"182\":1}}],[\"0x0200\",{\"1\":{\"182\":1}}],[\"0x000000001b7d3fa8\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x000000001b7d35e8\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x000000001b7d4208\",{\"1\":{\"205\":1}}],[\"0x000000001b7d4200\",{\"1\":{\"205\":1}}],[\"0x000000001b7d41f8\",{\"1\":{\"205\":1}}],[\"0x000000001b7d41f0\",{\"1\":{\"205\":1}}],[\"0x000000001b7d41e8\",{\"1\":{\"205\":1}}],[\"0x000000001b7d41e0\",{\"1\":{\"205\":3}}],[\"0x000000001b7d4028\",{\"1\":{\"204\":1,\"205\":1}}],[\"0x000000001b3d1678\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x000000001b3d1540\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x000000001b3d15e8\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x000000001b3d1b10\",{\"1\":{\"205\":1,\"206\":1}}],[\"0x00000001299b4978\",{\"1\":{\"204\":1}}],[\"0x0009\",{\"1\":{\"193\":1}}],[\"0x0001\",{\"1\":{\"182\":1}}],[\"0x0020\",{\"1\":{\"182\":1}}],[\"0x0010\",{\"1\":{\"182\":1}}],[\"0~3\",{\"1\":{\"180\":1}}],[\"0e\",{\"1\":{\"179\":1}}],[\"0d\",{\"1\":{\"179\":1}}],[\"02\",{\"1\":{\"179\":8,\"182\":1,\"183\":4}}],[\"0b\",{\"1\":{\"179\":3,\"182\":2}}],[\"0c\",{\"1\":{\"179\":6,\"182\":14}}],[\"0f\",{\"1\":{\"179\":3,\"182\":8}}],[\"04\",{\"1\":{\"179\":6,\"182\":15}}],[\"03\",{\"1\":{\"179\":3,\"182\":7}}],[\"07\",{\"1\":{\"179\":8,\"182\":29}}],[\"0a\",{\"1\":{\"179\":6,\"180\":1,\"181\":2,\"182\":13}}],[\"09\",{\"1\":{\"147\":1,\"179\":6,\"180\":1,\"181\":2,\"182\":4}}],[\"091\",{\"1\":{\"85\":1}}],[\"08\",{\"1\":{\"146\":1,\"179\":4,\"182\":11}}],[\"06\",{\"1\":{\"133\":1,\"179\":5,\"180\":1,\"181\":2,\"182\":10,\"183\":5}}],[\"05\",{\"1\":{\"127\":1,\"179\":4,\"182\":1,\"183\":5}}],[\"056\",{\"1\":{\"85\":1}}],[\"00100000\",{\"1\":{\"81\":19}}],[\"000\",{\"1\":{\"253\":1}}],[\"0000760\",{\"1\":{\"179\":1}}],[\"0000740\",{\"1\":{\"179\":1}}],[\"0000720\",{\"1\":{\"179\":1}}],[\"0000700\",{\"1\":{\"179\":1}}],[\"0000660\",{\"1\":{\"179\":1,\"182\":1,\"183\":4}}],[\"0000640\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000620\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000600\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000560\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000540\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000520\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000500\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000460\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000440\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000420\",{\"1\":{\"179\":1,\"182\":3}}],[\"0000400\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000360\",{\"1\":{\"179\":1,\"182\":4}}],[\"0000340\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000320\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000300\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000260\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000240\",{\"1\":{\"179\":1,\"182\":3}}],[\"0000220\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000200\",{\"1\":{\"179\":1,\"182\":3}}],[\"0000160\",{\"1\":{\"179\":1,\"182\":1}}],[\"0000140\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000120\",{\"1\":{\"179\":1,\"182\":2}}],[\"0000100\",{\"1\":{\"179\":1,\"182\":2}}],[\"00001101\",{\"1\":{\"80\":1}}],[\"0000060\",{\"1\":{\"179\":1,\"182\":3}}],[\"0000040\",{\"1\":{\"179\":1,\"182\":3}}],[\"0000020\",{\"1\":{\"179\":1,\"182\":5}}],[\"0000000\",{\"1\":{\"179\":1,\"180\":1,\"181\":2,\"182\":3}}],[\"00000001\",{\"1\":{\"79\":1,\"81\":19}}],[\"00000000\",{\"1\":{\"79\":19,\"80\":15,\"81\":556}}],[\"00000101\",{\"1\":{\"79\":2,\"80\":2,\"81\":82}}],[\"0001120\",{\"1\":{\"179\":1}}],[\"0001100\",{\"1\":{\"179\":1}}],[\"00011100\",{\"1\":{\"80\":1}}],[\"00011111\",{\"1\":{\"79\":3,\"80\":1,\"81\":82}}],[\"0001060\",{\"1\":{\"179\":1}}],[\"0001040\",{\"1\":{\"179\":1}}],[\"0001020\",{\"1\":{\"179\":1}}],[\"0001000\",{\"1\":{\"179\":1}}],[\"00010000\",{\"1\":{\"79\":2}}],[\"00\",{\"1\":{\"77\":1,\"83\":1,\"179\":142,\"180\":6,\"181\":16,\"182\":187,\"183\":36}}],[\"01相差无几\",{\"1\":{\"275\":1}}],[\"010314\",{\"1\":{\"275\":1}}],[\"01011000\",{\"1\":{\"81\":19}}],[\"01000000\",{\"1\":{\"79\":1}}],[\"01000001\",{\"1\":{\"79\":2}}],[\"01\",{\"1\":{\"77\":2,\"179\":34,\"182\":79,\"183\":4,\"274\":1}}],[\"0\",{\"1\":{\"61\":1,\"67\":1,\"71\":6,\"77\":1,\"81\":6,\"82\":3,\"84\":2,\"85\":4,\"94\":4,\"106\":1,\"115\":1,\"120\":4,\"121\":1,\"123\":3,\"127\":2,\"132\":8,\"133\":1,\"146\":3,\"147\":2,\"182\":1,\"183\":1,\"188\":6,\"193\":4,\"194\":7,\"195\":9,\"196\":14,\"197\":9,\"198\":1,\"209\":3,\"210\":5,\"211\":8,\"212\":3,\"213\":9,\"214\":5,\"215\":1,\"219\":7,\"220\":13,\"222\":1,\"223\":4,\"224\":2,\"225\":1,\"226\":1,\"237\":3,\"251\":2,\"252\":3,\"253\":5,\"254\":2,\"256\":5,\"258\":3,\"274\":3,\"275\":2}}],[\"时就好比\",{\"1\":{\"258\":1}}],[\"时代\",{\"1\":{\"243\":1}}],[\"时老年代内存占用\",{\"1\":{\"177\":1}}],[\"时间\",{\"1\":{\"169\":1}}],[\"时间片\",{\"1\":{\"60\":1}}],[\"时会对\",{\"1\":{\"164\":1}}],[\"时才能回收被引用对象\",{\"1\":{\"145\":1}}],[\"时\",{\"1\":{\"68\":1,\"98\":1,\"123\":4,\"126\":1,\"176\":1,\"245\":1,\"254\":2,\"258\":1}}],[\"时唤醒\",{\"1\":{\"60\":1}}],[\"bv1ye411z7ap\",{\"1\":{\"263\":1}}],[\"bloomfilter\",{\"1\":{\"274\":4}}],[\"bloomfilter<integer>\",{\"1\":{\"274\":1}}],[\"blog\",{\"1\":{\"263\":2}}],[\"blocked\",{\"1\":{\"60\":2,\"71\":1,\"84\":2}}],[\"build\",{\"1\":{\"253\":1}}],[\"buffer\",{\"1\":{\"132\":1,\"176\":1}}],[\"bm\",{\"1\":{\"223\":4}}],[\"bridge\",{\"1\":{\"227\":1}}],[\"break\",{\"1\":{\"223\":12,\"224\":6}}],[\"browser\",{\"1\":{\"205\":1,\"206\":1}}],[\"brokenbarrierexception\",{\"1\":{\"98\":2}}],[\"by\",{\"1\":{\"182\":1,\"202\":1,\"226\":1}}],[\"bytecodetest\",{\"1\":{\"196\":1}}],[\"bytecode\",{\"1\":{\"193\":1,\"199\":1,\"202\":1}}],[\"bytes\",{\"1\":{\"188\":1}}],[\"bytebuffer就会被回收\",{\"1\":{\"144\":1}}],[\"bytebuffer\",{\"1\":{\"132\":12,\"133\":8,\"144\":1}}],[\"byte\",{\"1\":{\"120\":2,\"132\":1,\"133\":1,\"146\":6,\"147\":3,\"155\":5,\"156\":1,\"157\":2,\"192\":1,\"194\":1,\"223\":3}}],[\"b6\",{\"1\":{\"179\":1}}],[\"b2\",{\"1\":{\"179\":1}}],[\"b1\",{\"1\":{\"179\":2}}],[\"b7\",{\"1\":{\"179\":1}}],[\"banana\",{\"0\":{\"329\":1}}],[\"ba\",{\"1\":{\"179\":1,\"180\":2,\"181\":2,\"182\":3}}],[\"barried\",{\"1\":{\"167\":1}}],[\"base\",{\"1\":{\"132\":8,\"133\":3}}],[\"b对象不再引用a4对象\",{\"1\":{\"145\":1}}],[\"b对象不再引用bytebuffer对象\",{\"1\":{\"144\":1}}],[\"boot\",{\"1\":{\"254\":1}}],[\"bootclasspath>\",{\"1\":{\"240\":1}}],[\"bootclasspath\",{\"1\":{\"240\":2}}],[\"bootstrap\",{\"1\":{\"239\":1,\"240\":3,\"245\":1}}],[\"boolean\",{\"1\":{\"68\":1,\"132\":1,\"206\":1,\"237\":1,\"242\":1,\"260\":1,\"262\":1}}],[\"boundary\",{\"1\":{\"132\":1}}],[\"bilibili\",{\"1\":{\"263\":1}}],[\"bipush\",{\"1\":{\"193\":1,\"194\":2,\"195\":3,\"196\":1,\"197\":5,\"209\":2,\"210\":4,\"212\":5,\"213\":3,\"214\":3,\"219\":1,\"220\":1}}],[\"bin\",{\"1\":{\"139\":2,\"172\":1}}],[\"bin>javac\",{\"1\":{\"121\":1}}],[\"biased\",{\"1\":{\"77\":3}}],[\"bits\",{\"1\":{\"77\":1,\"132\":6}}],[\"b\",{\"1\":{\"76\":1,\"85\":4,\"91\":1,\"108\":2,\"123\":14,\"125\":3,\"139\":1,\"161\":1,\"187\":2,\"193\":3,\"197\":10,\"227\":5,\"237\":17,\"238\":3}}],[\"begin\",{\"1\":{\"97\":3}}],[\"benchmark1\",{\"1\":{\"253\":8}}],[\"benchmarks\",{\"1\":{\"85\":2}}],[\"benchmark\",{\"1\":{\"85\":4,\"253\":7}}],[\"benchmarkmode\",{\"1\":{\"85\":1}}],[\"before\",{\"1\":{\"65\":1}}],[\"be\",{\"1\":{\"26\":1,\"179\":1,\"180\":2,\"181\":2,\"182\":5,\"248\":1,\"280\":1}}],[\"状态如下\",{\"1\":{\"94\":1}}],[\"状态的线程\",{\"1\":{\"71\":1}}],[\"状态\",{\"1\":{\"60\":1,\"61\":1,\"94\":1,\"168\":1}}],[\"与解释器的区别\",{\"1\":{\"251\":1}}],[\"与数组元素的关系\",{\"1\":{\"224\":1}}],[\"与吞吐量关系密切\",{\"1\":{\"160\":2}}],[\"与其他收集器的单线程相比\",{\"1\":{\"159\":1}}],[\"与\",{\"0\":{\"65\":1},\"1\":{\"59\":1,\"98\":1,\"160\":3,\"161\":1,\"254\":1}}],[\"或者\",{\"1\":{\"205\":1}}],[\"或者可以根据计算的需要进行扩展\",{\"1\":{\"118\":1}}],[\"或者类似于操作系统进程中的\",{\"1\":{\"118\":1}}],[\"或者第三方类库操作\",{\"1\":{\"109\":1}}],[\"或\",{\"1\":{\"59\":1,\"60\":1,\"68\":1,\"155\":2}}],[\"一种以获取最短回收停顿时间为目标的老年代收集器特点\",{\"1\":{\"161\":1}}],[\"一种是基于消息传递的\",{\"1\":{\"59\":1}}],[\"一种是基于共享内存的\",{\"1\":{\"59\":1}}],[\"一般软引用需要搭配一个引用队列一起使用\",{\"1\":{\"146\":1}}],[\"一般用\",{\"1\":{\"133\":1}}],[\"一旦这个范围内的字节码执行出现异常\",{\"1\":{\"209\":1}}],[\"一旦分配较大内存的对象\",{\"1\":{\"149\":1}}],[\"一旦\",{\"1\":{\"132\":1}}],[\"一旦某个线程修改了volatile变量\",{\"1\":{\"67\":1}}],[\"一致\",{\"1\":{\"123\":1}}],[\"一个被数字\",{\"1\":{\"311\":1}}],[\"一个被星标了的苹果文章\",{\"1\":{\"291\":1}}],[\"一个\",{\"1\":{\"263\":1}}],[\"一个做自减\",{\"1\":{\"256\":1}}],[\"一个是要配合\",{\"1\":{\"198\":1}}],[\"一个简单的\",{\"1\":{\"179\":1}}],[\"一个对象大于region的一半时\",{\"1\":{\"171\":1}}],[\"一个区域512k\",{\"1\":{\"167\":1}}],[\"一个存在于堆内存之中\",{\"1\":{\"123\":1}}],[\"一个存在于串池之中\",{\"1\":{\"123\":1}}],[\"一个list\",{\"1\":{\"115\":1}}],[\"一个线程对\",{\"1\":{\"263\":1}}],[\"一个线程对共享变量的修改可能对其他线程不可见\",{\"1\":{\"65\":1}}],[\"一个线程需要知道另一个线程是否已经初始化了某些资源或者是否正在执行特定的任务\",{\"1\":{\"68\":1}}],[\"一个线程可以调用\",{\"1\":{\"59\":1}}],[\"一些带有native关键字的方法就是需要java去调用本地的c或者c++方法\",{\"1\":{\"111\":1}}],[\"一起使用\",{\"1\":{\"65\":1}}],[\"www\",{\"1\":{\"263\":1,\"276\":3}}],[\"woman\",{\"1\":{\"224\":2}}],[\"world的时间更长\",{\"1\":{\"153\":1}}],[\"world\",{\"1\":{\"153\":1,\"159\":2,\"161\":2,\"179\":1,\"182\":1,\"188\":3,\"221\":1,\"223\":3}}],[\"word\",{\"1\":{\"70\":1,\"72\":1,\"76\":1,\"77\":1,\"83\":4,\"84\":1}}],[\"w\",{\"1\":{\"192\":1,\"223\":4}}],[\"when\",{\"1\":{\"182\":1}}],[\"while\",{\"1\":{\"61\":1,\"68\":1,\"115\":1,\"132\":1,\"146\":1,\"147\":1,\"195\":5,\"196\":1,\"222\":1,\"246\":1,\"247\":1,\"260\":1,\"262\":1}}],[\"write\",{\"1\":{\"167\":1}}],[\"weixin\",{\"1\":{\"263\":1}}],[\"web\",{\"1\":{\"161\":1}}],[\"weakreference<>\",{\"1\":{\"147\":2}}],[\"weakreference<byte\",{\"1\":{\"147\":5}}],[\"weakreferencetest\",{\"1\":{\"147\":1}}],[\"weakreference\",{\"1\":{\"147\":5}}],[\"windows\",{\"1\":{\"204\":1,\"205\":1}}],[\"with\",{\"0\":{\"226\":1},\"1\":{\"120\":1,\"226\":3}}],[\"will\",{\"1\":{\"26\":1,\"101\":1,\"280\":1}}],[\"wake\",{\"1\":{\"147\":6}}],[\"was\",{\"1\":{\"101\":1}}],[\"warmup\",{\"1\":{\"85\":1,\"253\":1}}],[\"waiting\",{\"1\":{\"60\":3,\"71\":1,\"97\":1}}],[\"waitset\",{\"1\":{\"60\":1,\"61\":1,\"71\":1}}],[\"wait\",{\"0\":{\"60\":1,\"65\":1,\"80\":1},\"1\":{\"59\":2,\"60\":1,\"61\":1,\"65\":2,\"79\":2,\"80\":1,\"81\":1,\"97\":1}}],[\"类初始化\",{\"1\":{\"238\":1}}],[\"类加载器加载类\",{\"1\":{\"240\":1}}],[\"类加载器虽然只用于实现类的加载动作\",{\"1\":{\"239\":1}}],[\"类加载器\",{\"0\":{\"239\":1}}],[\"类加载器的\",{\"1\":{\"237\":1}}],[\"类加载阶段\",{\"0\":{\"229\":1}}],[\"类对象\",{\"1\":{\"237\":2}}],[\"类型\",{\"1\":{\"223\":1}}],[\"类型的变量\",{\"1\":{\"219\":1}}],[\"类型的文件\",{\"1\":{\"180\":1}}],[\"类型来处理\",{\"1\":{\"219\":1}}],[\"类自己的\",{\"1\":{\"206\":1}}],[\"类有\",{\"1\":{\"205\":1}}],[\"类似的指令还有\",{\"1\":{\"192\":1}}],[\"类似于操作系统的线程\",{\"1\":{\"59\":1}}],[\"类文件结构如下\",{\"1\":{\"179\":1}}],[\"类文件结构\",{\"0\":{\"179\":1}}],[\"类名为\",{\"1\":{\"254\":1}}],[\"类名\",{\"1\":{\"120\":1,\"185\":1}}],[\"类\",{\"0\":{\"98\":1},\"1\":{\"230\":1}}],[\"类的初始化的懒惰的\",{\"1\":{\"237\":1}}],[\"类的对象在对象头中保存了\",{\"1\":{\"230\":1}}],[\"类的基本信息\",{\"1\":{\"121\":1}}],[\"类的绝对路径\",{\"1\":{\"121\":1}}],[\"类的\",{\"1\":{\"59\":1,\"206\":2}}],[\"ok\",{\"1\":{\"211\":1,\"215\":2,\"228\":2}}],[\"override\",{\"1\":{\"199\":3,\"227\":1,\"228\":3}}],[\"org\",{\"1\":{\"253\":5}}],[\"ordinal\",{\"1\":{\"224\":8,\"225\":3}}],[\"ordering\",{\"1\":{\"65\":1}}],[\"oracle\",{\"1\":{\"185\":1,\"194\":1}}],[\"od\",{\"1\":{\"179\":1}}],[\"o被划分为多个区域\",{\"1\":{\"167\":1}}],[\"old\",{\"1\":{\"160\":1,\"161\":2,\"166\":1}}],[\"old是serial收集器的老年代版本\",{\"1\":{\"159\":1}}],[\"old收集器\",{\"1\":{\"159\":1}}],[\"oldparallel\",{\"1\":{\"158\":1}}],[\"oldserial\",{\"1\":{\"158\":1}}],[\"outputstream\",{\"1\":{\"226\":1}}],[\"outputtimeunit\",{\"1\":{\"85\":1}}],[\"outside\",{\"1\":{\"182\":1}}],[\"outofmemoryerror\",{\"1\":{\"115\":3,\"120\":4,\"132\":2}}],[\"out\",{\"1\":{\"98\":4,\"101\":2,\"106\":7,\"108\":2,\"115\":1,\"120\":1,\"123\":4,\"125\":5,\"127\":1,\"132\":1,\"133\":4,\"139\":3,\"146\":8,\"147\":6,\"157\":2,\"179\":1,\"182\":1,\"187\":1,\"188\":4,\"193\":4,\"196\":2,\"197\":3,\"199\":3,\"211\":1,\"213\":2,\"214\":1,\"215\":2,\"220\":2,\"221\":2,\"222\":4,\"223\":8,\"224\":4,\"226\":2,\"227\":1,\"228\":4,\"237\":9,\"238\":4,\"240\":3,\"241\":3,\"245\":1,\"251\":1,\"252\":4,\"254\":1,\"256\":1,\"258\":1,\"262\":1,\"274\":2}}],[\"ops\",{\"1\":{\"253\":6}}],[\"opt\",{\"1\":{\"253\":2}}],[\"optionsbuilder\",{\"1\":{\"253\":2}}],[\"options\",{\"1\":{\"253\":4}}],[\"openjdk\",{\"1\":{\"253\":8}}],[\"opcodes\",{\"1\":{\"120\":2}}],[\"op\",{\"1\":{\"85\":4}}],[\"o\",{\"1\":{\"85\":2,\"163\":2,\"165\":1,\"169\":2,\"219\":2}}],[\"offset\",{\"1\":{\"71\":2}}],[\"of\",{\"1\":{\"71\":1,\"157\":1,\"246\":1}}],[\"objcet\",{\"1\":{\"219\":1}}],[\"obj\",{\"1\":{\"71\":2,\"76\":4,\"84\":2,\"219\":1,\"258\":9}}],[\"object>\",{\"1\":{\"220\":1}}],[\"object\",{\"0\":{\"65\":1},\"1\":{\"59\":1,\"65\":1,\"71\":3,\"76\":2,\"83\":3,\"84\":4,\"85\":2,\"120\":1,\"182\":1,\"188\":4,\"202\":1,\"206\":7,\"215\":4,\"217\":2,\"219\":8,\"220\":4,\"251\":1,\"254\":6,\"258\":2}}],[\"owner\",{\"1\":{\"60\":3,\"71\":3,\"84\":1}}],[\"omega^i\",{\"1\":{\"18\":1}}],[\"omega^r\",{\"1\":{\"18\":1}}],[\"omega\",{\"1\":{\"18\":4}}],[\"通常需要使用其他同步机制\",{\"1\":{\"68\":1}}],[\"通知机制\",{\"1\":{\"59\":1}}],[\"通过接口来使用实现\",{\"1\":{\"243\":1}}],[\"通过字符串的\",{\"1\":{\"223\":1}}],[\"通过分析字节码指令即可知晓\",{\"1\":{\"196\":1}}],[\"通过上面的代码\",{\"1\":{\"155\":1}}],[\"通过虚引用\",{\"1\":{\"132\":1}}],[\"通过bytebuffer申请1m的直接内存bytebuffer\",{\"1\":{\"132\":1}}],[\"通过申请直接内存\",{\"1\":{\"132\":1}}],[\"通过拼接的方式来创建字符串的过程是\",{\"1\":{\"123\":1}}],[\"通过反编译来查看类的信息\",{\"0\":{\"121\":1}}],[\"通过new关键字创建的对象都会使用堆内存\",{\"1\":{\"113\":1}}],[\"通过查看进程中的线程的nid\",{\"1\":{\"110\":1}}],[\"通过\",{\"1\":{\"11\":1,\"14\":1,\"59\":3,\"65\":1,\"205\":1,\"206\":1}}],[\"协调任务执行\",{\"1\":{\"59\":1}}],[\"协程是在线程的基础上再细分出来的一个调度的最小单位\",{\"1\":{\"59\":1}}],[\"vd\",{\"1\":{\"263\":1}}],[\"video\",{\"1\":{\"263\":1}}],[\"visit\",{\"1\":{\"120\":1}}],[\"visibility\",{\"1\":{\"65\":1}}],[\"vtable\",{\"0\":{\"205\":1},\"1\":{\"205\":2,\"207\":1,\"230\":1}}],[\"val$x\",{\"1\":{\"228\":3}}],[\"values\",{\"1\":{\"225\":1,\"253\":3}}],[\"value\",{\"1\":{\"182\":2,\"187\":1,\"192\":2,\"223\":1}}],[\"valueof\",{\"1\":{\"127\":1,\"218\":2,\"219\":1,\"220\":1,\"225\":2}}],[\"var0\",{\"1\":{\"223\":4}}],[\"var2\",{\"1\":{\"132\":2,\"223\":4}}],[\"vm\",{\"1\":{\"132\":1}}],[\"version>\",{\"1\":{\"253\":2,\"274\":1}}],[\"version\",{\"1\":{\"172\":1,\"179\":2,\"181\":2,\"188\":2,\"253\":2}}],[\"verbose\",{\"1\":{\"127\":2,\"146\":1,\"155\":2,\"156\":1,\"157\":1}}],[\"vector<>\",{\"1\":{\"81\":1,\"82\":1}}],[\"vector<dog>\",{\"1\":{\"81\":1,\"82\":1}}],[\"v1\",{\"1\":{\"120\":1}}],[\"v\",{\"0\":{\"236\":1},\"1\":{\"91\":3,\"121\":2,\"123\":2,\"182\":3,\"185\":1,\"188\":12,\"192\":1,\"193\":3,\"196\":1,\"197\":5,\"198\":6,\"210\":1,\"211\":2,\"215\":2,\"217\":1,\"219\":1,\"220\":4,\"236\":1}}],[\"void\",{\"1\":{\"67\":1,\"68\":2,\"71\":1,\"76\":3,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"84\":1,\"85\":2,\"97\":1,\"101\":1,\"108\":5,\"115\":1,\"120\":1,\"123\":4,\"125\":1,\"127\":1,\"132\":4,\"133\":4,\"139\":1,\"146\":5,\"147\":3,\"155\":1,\"156\":1,\"157\":1,\"179\":1,\"187\":1,\"188\":1,\"193\":2,\"194\":1,\"195\":3,\"196\":1,\"197\":2,\"198\":5,\"199\":5,\"206\":2,\"209\":1,\"210\":2,\"211\":3,\"212\":1,\"213\":2,\"214\":1,\"215\":1,\"218\":3,\"219\":1,\"220\":2,\"221\":4,\"222\":4,\"223\":4,\"224\":2,\"226\":4,\"227\":1,\"228\":8,\"233\":1,\"234\":1,\"237\":1,\"238\":1,\"240\":1,\"246\":2,\"251\":1,\"252\":1,\"253\":7,\"254\":3,\"256\":1,\"258\":1,\"260\":1,\"262\":2,\"274\":1}}],[\"volatilecounter\",{\"1\":{\"67\":1}}],[\"volatile变量的写操作会强制将数据写入主内存\",{\"1\":{\"67\":1}}],[\"volatile关键字用来修饰变量\",{\"1\":{\"66\":1}}],[\"volatile关键字有两个作用\",{\"1\":{\"65\":1}}],[\"volatile\",{\"0\":{\"262\":1},\"1\":{\"59\":1,\"65\":2,\"67\":4,\"68\":5,\"253\":1,\"262\":3,\"263\":1}}],[\"vue\",{\"1\":{\"29\":2,\"283\":2}}],[\"vuepress\",{\"0\":{\"13\":1},\"1\":{\"9\":2,\"11\":2,\"12\":1,\"13\":2,\"14\":1,\"28\":1,\"282\":1}}],[\"等支持二进制的编辑器修改\",{\"1\":{\"232\":1}}],[\"等接口都实现了\",{\"1\":{\"226\":1}}],[\"等价代码为\",{\"1\":{\"221\":1}}],[\"等价于下面的代码\",{\"1\":{\"61\":1}}],[\"等工具\",{\"1\":{\"216\":1}}],[\"等情况\",{\"1\":{\"155\":1}}],[\"等垃圾回收结束\",{\"1\":{\"153\":1}}],[\"等司机来接\",{\"1\":{\"64\":1}}],[\"等同步器\",{\"1\":{\"59\":1}}],[\"等待线程满足某个计数\",{\"1\":{\"98\":1}}],[\"等待所有线程完成倒计时\",{\"1\":{\"97\":1}}],[\"等待\",{\"1\":{\"59\":1,\"61\":1,\"98\":1}}],[\"等\",{\"1\":{\"59\":1,\"65\":1,\"160\":1,\"243\":1,\"251\":1}}],[\"adriver\",{\"1\":{\"246\":3}}],[\"addelapsedtimefrom\",{\"1\":{\"242\":1}}],[\"addtime\",{\"1\":{\"242\":1}}],[\"addsuppressed\",{\"1\":{\"226\":2}}],[\"address\",{\"1\":{\"132\":5}}],[\"add\",{\"1\":{\"81\":1,\"82\":1,\"115\":1,\"132\":1,\"139\":3,\"146\":3,\"147\":2,\"155\":5,\"156\":1,\"157\":2,\"219\":3,\"220\":1}}],[\"apple\",{\"0\":{\"328\":1}}],[\"application\",{\"1\":{\"239\":1}}],[\"append\",{\"1\":{\"85\":4,\"108\":9,\"115\":2,\"123\":9,\"125\":1}}],[\"autocloseable\",{\"1\":{\"226\":3}}],[\"a++\",{\"1\":{\"193\":3,\"195\":2}}],[\"a|ppend\",{\"1\":{\"123\":1,\"125\":1}}],[\"aclass\",{\"1\":{\"240\":2}}],[\"aconst\",{\"1\":{\"211\":1}}],[\"accessed\",{\"1\":{\"182\":1}}],[\"access\",{\"1\":{\"179\":1}}],[\"accesscontroller\",{\"1\":{\"132\":1,\"246\":2}}],[\"acc\",{\"1\":{\"120\":1,\"182\":8,\"188\":5,\"193\":2,\"210\":2,\"211\":2,\"220\":3}}],[\"acquire\",{\"1\":{\"95\":2,\"96\":1}}],[\"article\",{\"1\":{\"263\":2}}],[\"artifactid>\",{\"1\":{\"253\":2,\"274\":1}}],[\"arthas\",{\"1\":{\"254\":2}}],[\"arr\",{\"1\":{\"221\":5}}],[\"array\",{\"1\":{\"222\":5}}],[\"arraylist\",{\"1\":{\"139\":1,\"219\":2,\"220\":2}}],[\"arraylist<softreference<byte\",{\"1\":{\"146\":2}}],[\"arraylist<string>\",{\"1\":{\"115\":1}}],[\"arraylist<byte\",{\"1\":{\"146\":1,\"156\":1,\"157\":1}}],[\"arraylist<object>\",{\"1\":{\"139\":1}}],[\"arraylist<>\",{\"1\":{\"115\":1,\"132\":1,\"139\":1,\"146\":4,\"147\":2,\"155\":1,\"156\":1,\"157\":1,\"219\":1}}],[\"arrays\",{\"1\":{\"115\":2,\"222\":2}}],[\"arguments\",{\"1\":{\"220\":3}}],[\"args\",{\"1\":{\"71\":3,\"80\":1,\"97\":1,\"101\":1,\"108\":2,\"115\":1,\"120\":1,\"123\":6,\"125\":1,\"127\":1,\"132\":1,\"133\":1,\"139\":1,\"146\":2,\"147\":1,\"155\":1,\"156\":1,\"157\":1,\"179\":1,\"182\":1,\"187\":1,\"188\":2,\"193\":3,\"194\":1,\"195\":3,\"196\":2,\"197\":4,\"198\":2,\"199\":1,\"209\":2,\"210\":3,\"211\":3,\"212\":2,\"213\":3,\"214\":2,\"215\":2,\"218\":3,\"219\":2,\"220\":4,\"221\":9,\"222\":4,\"223\":2,\"224\":2,\"226\":3,\"227\":1,\"228\":2,\"233\":1,\"234\":1,\"237\":1,\"238\":1,\"240\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":4,\"256\":1,\"258\":1,\"260\":1,\"262\":1,\"274\":1}}],[\"arithmeticexception\",{\"1\":{\"210\":3,\"226\":1}}],[\"again\",{\"1\":{\"101\":1}}],[\"age\",{\"1\":{\"77\":2}}],[\"await\",{\"1\":{\"97\":2,\"98\":3}}],[\"abnormally\",{\"1\":{\"132\":1}}],[\"abc\",{\"1\":{\"124\":2}}],[\"ab3初始化时直接从串池中获取字符串\",{\"1\":{\"123\":1}}],[\"ab\",{\"1\":{\"123\":17,\"125\":3}}],[\"abstract\",{\"1\":{\"182\":2,\"199\":2}}],[\"abstractstringbuilder\",{\"1\":{\"115\":4}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"92\":1}}],[\"aba问题\",{\"0\":{\"91\":1}}],[\"aqs是java并发编程中的重要概念\",{\"1\":{\"92\":1}}],[\"aqs的实现方式是通过继承来扩展\",{\"1\":{\"92\":1}}],[\"aqs的核心思想是使用一个fifo的等待队列来管理线程的获取和释放锁的顺序\",{\"1\":{\"92\":1}}],[\"aqs\",{\"0\":{\"92\":1},\"1\":{\"92\":1,\"94\":1}}],[\"annprocess<\",{\"1\":{\"253\":1}}],[\"annotations\",{\"1\":{\"253\":1}}],[\"annotation\",{\"1\":{\"182\":2}}],[\"analysistest\",{\"1\":{\"233\":2}}],[\"analyzer\",{\"0\":{\"139\":1},\"1\":{\"139\":2}}],[\"anewarray\",{\"1\":{\"211\":2}}],[\"animal\",{\"1\":{\"199\":7,\"206\":1}}],[\"an\",{\"1\":{\"182\":3}}],[\"and\",{\"1\":{\"87\":1,\"91\":1,\"101\":2}}],[\"any\",{\"1\":{\"71\":2,\"212\":2,\"213\":1,\"214\":1,\"215\":2}}],[\"avgt\",{\"1\":{\"85\":4}}],[\"averagetime\",{\"1\":{\"85\":1}}],[\"a\",{\"1\":{\"76\":1,\"85\":4,\"91\":2,\"108\":2,\"115\":6,\"123\":15,\"125\":4,\"139\":1,\"182\":1,\"187\":2,\"192\":1,\"193\":4,\"194\":4,\"195\":4,\"197\":10,\"227\":3,\"237\":10,\"238\":3,\"240\":3,\"248\":1}}],[\"attach\",{\"1\":{\"201\":1}}],[\"attribute\",{\"1\":{\"179\":1}}],[\"attributes\",{\"1\":{\"179\":3}}],[\"att\",{\"1\":{\"132\":1}}],[\"at\",{\"1\":{\"115\":5,\"120\":4,\"132\":4,\"226\":3}}],[\"athrow\",{\"1\":{\"71\":1,\"212\":1,\"213\":2,\"214\":1,\"215\":1}}],[\"atomiclong\",{\"1\":{\"65\":1}}],[\"atomicity\",{\"1\":{\"65\":1}}],[\"atomicinteger\",{\"1\":{\"59\":1,\"65\":1}}],[\"atomicreference\",{\"1\":{\"59\":1}}],[\"atomic\",{\"1\":{\"59\":1}}],[\"allimpls\",{\"1\":{\"247\":2}}],[\"allowed\",{\"1\":{\"182\":1}}],[\"allocation\",{\"1\":{\"176\":1}}],[\"allocatememory\",{\"1\":{\"132\":1,\"133\":1}}],[\"allocatedirect的实现\",{\"1\":{\"132\":1}}],[\"allocatedirect\",{\"1\":{\"132\":4,\"133\":2}}],[\"ali\",{\"1\":{\"227\":2,\"233\":1}}],[\"alive\",{\"1\":{\"61\":1}}],[\"alt+r\",{\"1\":{\"205\":1}}],[\"aload\",{\"1\":{\"71\":3,\"106\":5,\"123\":4,\"188\":1,\"197\":8,\"198\":3,\"211\":2,\"212\":1,\"214\":1,\"215\":4,\"219\":2,\"220\":3}}],[\"asm\",{\"1\":{\"254\":1}}],[\"aslist\",{\"1\":{\"222\":2}}],[\"astore\",{\"1\":{\"71\":2,\"106\":1,\"123\":12,\"198\":2,\"209\":2,\"210\":3,\"211\":2,\"212\":2,\"213\":1,\"214\":1,\"215\":3,\"219\":2,\"220\":2}}],[\"as\",{\"1\":{\"26\":1,\"182\":2,\"280\":1}}],[\"来帮助我们实现布隆过滤器\",{\"1\":{\"274\":1}}],[\"来\",{\"1\":{\"251\":1}}],[\"来得到实现类\",{\"1\":{\"247\":1}}],[\"来说\",{\"1\":{\"230\":1}}],[\"来判断是否匹配\",{\"1\":{\"223\":1}}],[\"来观察\",{\"1\":{\"155\":1}}],[\"来释放弱引用自身\",{\"1\":{\"143\":1}}],[\"来释放软引用自身\",{\"1\":{\"142\":1}}],[\"来释放直接内存\",{\"1\":{\"132\":1}}],[\"来监测\",{\"1\":{\"132\":1}}],[\"来清除直接内存中占用的内存\",{\"1\":{\"132\":1}}],[\"来实现直接内存的释放\",{\"1\":{\"132\":1}}],[\"来减少字符串放入串池所需要的时间\",{\"1\":{\"128\":1}}],[\"来避免重复创建字符串对象\",{\"1\":{\"123\":1}}],[\"来唤醒它\",{\"1\":{\"101\":1}}],[\"来分析如下代码\",{\"1\":{\"85\":1}}],[\"来执行不可中断的操作\",{\"1\":{\"59\":1}}],[\"来保证同一时间只有一个线程可以访问特定的代码块或资源\",{\"1\":{\"59\":1}}],[\"来解析\",{\"1\":{\"12\":1}}],[\"关闭逃逸分析\",{\"1\":{\"251\":1}}],[\"关注吞吐量新生代采用标记\",{\"1\":{\"158\":1}}],[\"关联的是应用程序类加载器\",{\"1\":{\"246\":1}}],[\"关联了引用队列\",{\"1\":{\"146\":1}}],[\"关联流程\",{\"0\":{\"71\":1}}],[\"关系\",{\"1\":{\"65\":1}}],[\"关键字\",{\"1\":{\"59\":2,\"65\":1}}],[\"关键字或\",{\"1\":{\"59\":1}}],[\"关于这些扩展\",{\"1\":{\"13\":1}}],[\"在数据库没有查询该条数据的时候\",{\"1\":{\"270\":1}}],[\"在门内执行\",{\"1\":{\"258\":1}}],[\"在内联情况下将\",{\"1\":{\"253\":1}}],[\"在刚才的示例中\",{\"1\":{\"253\":1}}],[\"在下面一些框架中都运用了此思想\",{\"1\":{\"247\":1}}],[\"在类加载器中的loadclass\",{\"1\":{\"243\":1}}],[\"在控制台运行\",{\"1\":{\"232\":1}}],[\"在控制台输入\",{\"1\":{\"121\":1}}],[\"在本地内存中\",{\"1\":{\"230\":1}}],[\"在编译期间\",{\"1\":{\"223\":1}}],[\"在编译泛型代码后会执行泛型擦除\",{\"1\":{\"219\":1}}],[\"在进行输出判断\",{\"1\":{\"223\":1}}],[\"在执行invokevirtual指令时\",{\"1\":{\"199\":1}}],[\"在堆内存中找到该对象\",{\"1\":{\"192\":1}}],[\"在运行时常量池中找到\",{\"1\":{\"192\":1}}],[\"在并发标记阶段结束以后\",{\"1\":{\"168\":1}}],[\"在并发编程中\",{\"1\":{\"65\":1}}],[\"在引用变更时通过post\",{\"1\":{\"167\":1}}],[\"在老年代占用堆内存的比例达到阈值时\",{\"1\":{\"164\":1}}],[\"在虚拟机执行垃圾回收的过程中\",{\"1\":{\"149\":1,\"150\":1}}],[\"在垃圾回收时\",{\"1\":{\"143\":1,\"145\":1,\"168\":1}}],[\"在垃圾回收后\",{\"1\":{\"142\":1}}],[\"在系统内存中有一份\",{\"1\":{\"131\":1}}],[\"在jvm内部\",{\"1\":{\"169\":1}}],[\"在jdk对应的bin目录下运行cmd\",{\"1\":{\"121\":1}}],[\"在java中使用布隆过滤器\",{\"1\":{\"274\":1}}],[\"在java中\",{\"1\":{\"93\":1,\"101\":1}}],[\"在尝试不成功后再次进入\",{\"1\":{\"94\":1}}],[\"在调用时都使用invokespecial指令\",{\"1\":{\"198\":1}}],[\"在调用\",{\"1\":{\"78\":1}}],[\"在64位jvm中长度是64bit\",{\"1\":{\"74\":1}}],[\"在需要更复杂的同步操作时\",{\"1\":{\"68\":1}}],[\"在读取\",{\"1\":{\"68\":1}}],[\"在这个例子中\",{\"1\":{\"68\":1,\"101\":1}}],[\"在没有同步机制的情况下\",{\"1\":{\"65\":1}}],[\"在多线程环境中\",{\"1\":{\"65\":2}}],[\"在\",{\"1\":{\"59\":2,\"71\":1,\"146\":1,\"159\":1,\"164\":1,\"218\":1,\"245\":1,\"246\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"3\":1,\"56\":1}}],[\"以达到理想的运行速度\",{\"1\":{\"251\":1}}],[\"以接口全限定名名为文件\",{\"1\":{\"246\":1}}],[\"以前面的性别枚举为例\",{\"1\":{\"225\":1}}],[\"以看到\",{\"1\":{\"223\":1}}],[\"以下情况不会初始化\",{\"1\":{\"237\":1}}],[\"以下情况会初始化\",{\"1\":{\"237\":1}}],[\"以下代码的分析\",{\"1\":{\"216\":1}}],[\"以下是park方法的一个基本示例\",{\"1\":{\"101\":1}}],[\"以\",{\"1\":{\"177\":1,\"239\":1}}],[\"以免垃圾回收时移动对象地址\",{\"1\":{\"159\":1}}],[\"以上的结果可能是正数\",{\"1\":{\"256\":1}}],[\"以上的实现特点是\",{\"1\":{\"238\":1}}],[\"以上比较指令中没有\",{\"1\":{\"194\":1}}],[\"以上\",{\"1\":{\"128\":1}}],[\"以后\",{\"1\":{\"126\":1,\"218\":1}}],[\"以后只要不发生竞争\",{\"1\":{\"76\":1}}],[\"以及2个hash函数\",{\"1\":{\"273\":1}}],[\"以及字符串常量\",{\"1\":{\"233\":1}}],[\"以及所有实现了\",{\"1\":{\"222\":1}}],[\"以及方法和构造函数的代码\",{\"1\":{\"118\":1}}],[\"以及那些需要更细粒度控制线程阻塞和唤醒的高级并发应用程序\",{\"1\":{\"101\":1}}],[\"以避免常见的并发问题\",{\"1\":{\"101\":1}}],[\"以避免数据不一致或竞态条件的问题\",{\"1\":{\"59\":1}}],[\"以确保当调用\",{\"1\":{\"68\":1}}],[\"以此保证变量的一致性\",{\"1\":{\"59\":1}}],[\"以便于接着往下执行\",{\"1\":{\"106\":1}}],[\"以便\",{\"1\":{\"9\":1}}],[\"如下图所示\",{\"1\":{\"273\":1}}],[\"如下代码\",{\"1\":{\"218\":1}}],[\"如下\",{\"1\":{\"146\":1}}],[\"如上图\",{\"1\":{\"144\":1,\"145\":1}}],[\"如何判断对象可以回收\",{\"0\":{\"134\":1}}],[\"如死锁\",{\"1\":{\"101\":1}}],[\"如reentrantlock\",{\"1\":{\"92\":1}}],[\"如果发现\",{\"1\":{\"252\":1}}],[\"如果还是没找到\",{\"1\":{\"242\":1}}],[\"如果还是没有找到\",{\"1\":{\"242\":1}}],[\"如果appclassloader也加载失败\",{\"1\":{\"242\":1}}],[\"如果bootstrapclassloader加载失败\",{\"1\":{\"242\":1}}],[\"如果父类还没初始化\",{\"1\":{\"237\":2}}],[\"如果这个类还有父类没有加载\",{\"1\":{\"230\":1}}],[\"如果变化\",{\"1\":{\"228\":1}}],[\"如果不存在内容\",{\"1\":{\"269\":1}}],[\"如果不是\",{\"1\":{\"228\":1}}],[\"如果不用\",{\"1\":{\"79\":1}}],[\"如果我们代码没有异常\",{\"1\":{\"226\":1}}],[\"如果我们代码有异常\",{\"1\":{\"226\":1}}],[\"如果要将返回结果赋值给一个\",{\"1\":{\"219\":1}}],[\"如果前面的\",{\"1\":{\"219\":1}}],[\"如果出现异常\",{\"1\":{\"213\":1}}],[\"如果一致\",{\"1\":{\"209\":1}}],[\"如果一个对象虽然有多线程要加锁\",{\"1\":{\"83\":1}}],[\"如果下面的数大于上面的数\",{\"1\":{\"196\":1}}],[\"如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉\",{\"1\":{\"171\":1}}],[\"如果老年代内存到达一定的阈值了\",{\"1\":{\"162\":1}}],[\"如果字符串的值一样\",{\"1\":{\"169\":1}}],[\"如果该区域引用了新生代对象\",{\"1\":{\"167\":1}}],[\"如果垃圾产生速度快于垃圾回收速度\",{\"1\":{\"166\":1}}],[\"如果垃圾产生速度慢于垃圾回收速度\",{\"1\":{\"166\":1}}],[\"如果对所有老年代都进行回收\",{\"1\":{\"165\":1}}],[\"如果对象虽然被多个线程访问\",{\"1\":{\"81\":1}}],[\"如果当用户需要存入一个很大的对象时\",{\"1\":{\"161\":1}}],[\"如果之后空间仍不足\",{\"1\":{\"153\":1}}],[\"如果找不到\",{\"1\":{\"137\":1}}],[\"如果虚引用的实际对象\",{\"1\":{\"132\":1}}],[\"如果操作的是对象和变量是不会放入常量池中的\",{\"1\":{\"125\":1}}],[\"如果串池中没有该字符串对象\",{\"1\":{\"123\":1,\"125\":1}}],[\"如果没有被加载过\",{\"1\":{\"242\":1}}],[\"如果没有\",{\"1\":{\"177\":1}}],[\"如果没有会把此对象复制一份\",{\"1\":{\"123\":1}}],[\"如果没有则放入串池\",{\"1\":{\"123\":2}}],[\"如果方法内部的变量没有逃离方法的作用范围\",{\"1\":{\"108\":1}}],[\"如果两个线程发生了上下文切换\",{\"1\":{\"106\":1}}],[\"如果获取成功\",{\"1\":{\"95\":1}}],[\"如果计数器为0\",{\"1\":{\"95\":1}}],[\"如果计数器大于0\",{\"1\":{\"95\":1}}],[\"如果失败\",{\"1\":{\"87\":1,\"95\":1}}],[\"如果cas操作成功\",{\"1\":{\"87\":1}}],[\"如果有内容就直接访问\",{\"1\":{\"269\":1}}],[\"如果有基础类型又要调用回用户的代码\",{\"1\":{\"243\":1}}],[\"如果有如下代码\",{\"1\":{\"223\":1}}],[\"如果有元素\",{\"1\":{\"146\":1}}],[\"如果有该字符串对象\",{\"1\":{\"123\":1,\"125\":1}}],[\"如果有则并不会放入\",{\"1\":{\"123\":3}}],[\"如果有其他线程尝试获取偏向锁\",{\"1\":{\"87\":1}}],[\"如果有取值为\",{\"1\":{\"83\":1}}],[\"如果在前面示例的死循环中加入\",{\"1\":{\"262\":1}}],[\"如果在\",{\"1\":{\"213\":1}}],[\"如果在同一段代码逻辑中\",{\"1\":{\"86\":1}}],[\"如果在尝试加轻量级锁的过程中\",{\"1\":{\"84\":1}}],[\"如果是单线程以上\",{\"1\":{\"256\":1}}],[\"如果是集合使用\",{\"1\":{\"222\":1}}],[\"如果是局部变量引用了对象\",{\"1\":{\"108\":1}}],[\"如果是自己执行了\",{\"1\":{\"83\":1}}],[\"如果是其它线程已经持有了该\",{\"1\":{\"83\":1}}],[\"如果调用的是\",{\"1\":{\"221\":1}}],[\"如果调用\",{\"1\":{\"78\":1}}],[\"如果\",{\"1\":{\"71\":1,\"83\":2,\"226\":1,\"233\":2,\"241\":1,\"253\":1}}],[\"如果使用\",{\"1\":{\"70\":1}}],[\"如果你是一个新手\",{\"1\":{\"10\":1}}],[\"如\",{\"1\":{\"59\":2,\"65\":1,\"68\":1,\"123\":1,\"161\":1,\"223\":1}}],[\"如内存\",{\"1\":{\"59\":1}}],[\"线程t如预想的停下来\",{\"1\":{\"262\":1}}],[\"线程t不会如预想的停下来\",{\"1\":{\"260\":1}}],[\"线程操作\",{\"1\":{\"262\":1}}],[\"线程修改了\",{\"1\":{\"260\":1}}],[\"线程要频繁从主内存中读取\",{\"1\":{\"260\":1}}],[\"线程刚开始从主内存读取了\",{\"1\":{\"260\":1}}],[\"线程无法停止\",{\"1\":{\"260\":1}}],[\"线程不可见\",{\"1\":{\"260\":1}}],[\"线程不能结束\",{\"1\":{\"79\":1}}],[\"线程对\",{\"1\":{\"260\":1}}],[\"线程执行到monitorenter\",{\"1\":{\"258\":1}}],[\"线程这时才可以进入\",{\"1\":{\"258\":1}}],[\"线程内i=\",{\"1\":{\"256\":2,\"263\":1}}],[\"线程内i=1\",{\"1\":{\"256\":4,\"263\":1}}],[\"线程内i=0\",{\"1\":{\"256\":6,\"263\":2}}],[\"线程私有\",{\"1\":{\"254\":1}}],[\"线程上下文类加载器是当前线程使用的类加载器\",{\"1\":{\"248\":1}}],[\"线程上下文类加载器\",{\"0\":{\"244\":1}}],[\"线程开始运行\",{\"0\":{\"191\":1}}],[\"线程通过\",{\"1\":{\"132\":1,\"145\":1}}],[\"线程通信通常通过以下几种方式实现\",{\"1\":{\"59\":1}}],[\"线程通信通常用于以下场景\",{\"1\":{\"59\":1}}],[\"线程通信是指线程之间相互发送信号和交换数据的过程\",{\"1\":{\"59\":1}}],[\"线程运行诊断\",{\"0\":{\"110\":1}}],[\"线程被唤醒后继续执行并打印另一条消息\",{\"1\":{\"101\":1}}],[\"线程2\",{\"1\":{\"256\":8,\"263\":4}}],[\"线程2继续向下运行\",{\"1\":{\"98\":1}}],[\"线程2开始\",{\"1\":{\"98\":1}}],[\"线程个数够2\",{\"1\":{\"98\":1}}],[\"线程1\",{\"1\":{\"256\":16,\"263\":4}}],[\"线程1继续向下运行\",{\"1\":{\"98\":1}}],[\"线程1开始\",{\"1\":{\"98\":1}}],[\"线程使用完资源后释放许可\",{\"1\":{\"96\":1}}],[\"线程使用资源\",{\"1\":{\"96\":1}}],[\"线程尝试获取许可\",{\"1\":{\"96\":1}}],[\"线程完成资源使用后\",{\"1\":{\"95\":1}}],[\"线程成功获取许可\",{\"1\":{\"95\":1}}],[\"线程就获得了锁\",{\"1\":{\"87\":1}}],[\"线程之间的共享变量存储在主内存\",{\"1\":{\"65\":1}}],[\"线程\",{\"1\":{\"65\":1,\"79\":1,\"84\":1,\"258\":1,\"262\":1,\"263\":6}}],[\"线程调用虚引用相关方法释放\",{\"1\":{\"144\":1}}],[\"线程调用semaphore的acquire\",{\"1\":{\"95\":1}}],[\"线程调用\",{\"1\":{\"60\":1}}],[\"线程释放锁时唤醒\",{\"1\":{\"60\":1}}],[\"线程会在\",{\"1\":{\"60\":2}}],[\"线程发现条件不满足\",{\"1\":{\"60\":1}}],[\"线程可能需要向其他线程提供数据或者从其他线程接收数据\",{\"1\":{\"59\":1}}],[\"线程可能需要等待其他线程完成某些操作后才能继续执行\",{\"1\":{\"59\":1}}],[\"线程同步关注的是如何避免并发导致的问题\",{\"1\":{\"65\":1}}],[\"线程同步和线程通信虽然密切相关\",{\"1\":{\"65\":1}}],[\"线程同步的目的是确保当一个线程正在使用某个资源时\",{\"1\":{\"59\":1}}],[\"线程同步通常通过以下几种方式实现\",{\"1\":{\"59\":1}}],[\"线程同步是一种机制\",{\"1\":{\"59\":1}}],[\"线程是cpu调度的最小单位\",{\"1\":{\"59\":1}}],[\"讲到并发\",{\"1\":{\"59\":1}}],[\"e2\",{\"1\":{\"226\":2}}],[\"e1\",{\"1\":{\"226\":3}}],[\"equals\",{\"1\":{\"206\":2,\"223\":9,\"246\":1}}],[\"eat\",{\"1\":{\"199\":4,\"206\":2}}],[\"eda2e7897356a975438fe5899c0b4a6c\",{\"1\":{\"188\":1}}],[\"eden\",{\"1\":{\"160\":1,\"163\":1}}],[\"evacuation\",{\"1\":{\"165\":1}}],[\"eclipse\",{\"1\":{\"139\":2}}],[\"erro\",{\"1\":{\"212\":1}}],[\"error\",{\"1\":{\"85\":2,\"132\":1,\"212\":1,\"248\":1,\"253\":2}}],[\"err\",{\"1\":{\"132\":1}}],[\"element\",{\"1\":{\"253\":2}}],[\"elements\",{\"1\":{\"253\":10}}],[\"else\",{\"1\":{\"132\":1,\"194\":1,\"223\":1,\"226\":1,\"242\":1}}],[\"eliminatelocks\",{\"1\":{\"85\":1}}],[\"ef\",{\"1\":{\"125\":1}}],[\"eo\",{\"1\":{\"110\":1}}],[\"epoch\",{\"1\":{\"77\":1}}],[\"e\",{\"1\":{\"71\":3,\"79\":4,\"80\":4,\"81\":2,\"98\":5,\"101\":2,\"115\":2,\"125\":1,\"127\":2,\"163\":2,\"169\":2,\"209\":1,\"210\":6,\"211\":4,\"212\":1,\"219\":1,\"222\":4,\"226\":8,\"238\":7,\"240\":1,\"241\":1,\"242\":1}}],[\"ex\",{\"1\":{\"246\":3}}],[\"ext\",{\"1\":{\"239\":1,\"241\":4}}],[\"extension\",{\"1\":{\"239\":1,\"242\":1}}],[\"extends\",{\"1\":{\"120\":1,\"146\":1,\"147\":1,\"199\":2,\"225\":1,\"227\":2,\"237\":1,\"254\":1}}],[\"execute\",{\"1\":{\"202\":1}}],[\"executequery\",{\"1\":{\"175\":1}}],[\"executorservice\",{\"1\":{\"92\":1}}],[\"executors\",{\"1\":{\"92\":1}}],[\"executor\",{\"1\":{\"92\":1}}],[\"exit\",{\"1\":{\"120\":1,\"132\":1}}],[\"exchanger\",{\"0\":{\"99\":1}}],[\"exception\",{\"1\":{\"71\":1,\"85\":2,\"120\":1,\"127\":1,\"132\":1,\"209\":4,\"210\":5,\"211\":1,\"212\":3,\"213\":1,\"214\":1,\"215\":1,\"226\":4,\"246\":2}}],[\"excutor\",{\"1\":{\"59\":1}}],[\"example\",{\"1\":{\"68\":1}}],[\"enum<sex>\",{\"1\":{\"225\":1}}],[\"enum\",{\"1\":{\"182\":2,\"224\":2,\"225\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"115\":1}}],[\"end\",{\"1\":{\"97\":4,\"139\":1,\"251\":2,\"252\":2}}],[\"entries\",{\"1\":{\"71\":1}}],[\"entrylist\",{\"1\":{\"60\":1,\"71\":3,\"84\":2}}],[\"enhance\",{\"1\":{\"14\":1}}],[\"square\",{\"1\":{\"252\":6}}],[\"sa\",{\"1\":{\"201\":1}}],[\"samples\",{\"1\":{\"85\":2,\"253\":2}}],[\"short\",{\"1\":{\"187\":1,\"192\":5,\"194\":1}}],[\"spm\",{\"1\":{\"263\":1}}],[\"spm=1001\",{\"1\":{\"263\":1}}],[\"spring\",{\"1\":{\"247\":1}}],[\"split\",{\"1\":{\"246\":1}}],[\"spi\",{\"0\":{\"246\":1},\"1\":{\"246\":2,\"247\":1}}],[\"specs\",{\"1\":{\"194\":1}}],[\"specially\",{\"1\":{\"182\":1}}],[\"space\",{\"1\":{\"115\":3,\"120\":1}}],[\"source=cd81f8812505504b960957155cd81114\",{\"1\":{\"263\":1}}],[\"source\",{\"1\":{\"182\":1}}],[\"sourcefile\",{\"1\":{\"182\":1,\"188\":1}}],[\"softreference\",{\"1\":{\"147\":1}}],[\"softreferencetest\",{\"1\":{\"146\":1}}],[\"softreference<>\",{\"1\":{\"146\":3}}],[\"softreference<byte\",{\"1\":{\"146\":5}}],[\"switch\",{\"0\":{\"223\":1,\"224\":1},\"1\":{\"223\":11,\"224\":2}}],[\"sweep\",{\"1\":{\"161\":2}}],[\"swap\",{\"1\":{\"87\":1,\"91\":1,\"243\":1}}],[\"sex\",{\"1\":{\"224\":12,\"225\":12}}],[\"se7\",{\"1\":{\"194\":1}}],[\"select\",{\"1\":{\"175\":1,\"202\":1}}],[\"servlet\",{\"1\":{\"247\":1}}],[\"services\",{\"1\":{\"246\":1}}],[\"service\",{\"1\":{\"246\":1,\"248\":7}}],[\"serviceloader<s>\",{\"1\":{\"248\":1}}],[\"serviceloader<接口类型>\",{\"1\":{\"247\":1}}],[\"serviceloader<driver>\",{\"1\":{\"246\":1}}],[\"serviceloader\",{\"1\":{\"246\":2,\"247\":1,\"248\":3}}],[\"server\",{\"1\":{\"158\":1}}],[\"serialgc\",{\"1\":{\"166\":1}}],[\"serial收集器是最基本的\",{\"1\":{\"159\":1}}],[\"serialold\",{\"0\":{\"159\":1},\"1\":{\"159\":1,\"161\":1}}],[\"serial\",{\"0\":{\"159\":1},\"1\":{\"158\":1,\"159\":8,\"161\":2,\"166\":1}}],[\"setparent\",{\"1\":{\"254\":1}}],[\"setdelegate\",{\"1\":{\"254\":1}}],[\"set<integer>\",{\"1\":{\"220\":1}}],[\"set\",{\"1\":{\"167\":3}}],[\"setaccessible\",{\"1\":{\"133\":1}}],[\"setmemory\",{\"1\":{\"132\":1,\"133\":1}}],[\"semaphore可以用于多种同步场景\",{\"1\":{\"96\":1}}],[\"semaphore提供了tryacquire\",{\"1\":{\"95\":1}}],[\"semaphore内部有一个计数器\",{\"1\":{\"95\":1}}],[\"semaphore本质上是一个计数信号量\",{\"1\":{\"93\":1}}],[\"semaphore是一个同步辅助类\",{\"1\":{\"93\":1}}],[\"semaphore\",{\"0\":{\"93\":1,\"94\":1},\"1\":{\"59\":2,\"92\":1,\"94\":1,\"96\":5}}],[\"subtype\",{\"1\":{\"248\":1}}],[\"subclasses\",{\"1\":{\"182\":1}}],[\"suppressed\",{\"1\":{\"226\":1}}],[\"superclass\",{\"1\":{\"182\":1}}],[\"super\",{\"1\":{\"132\":1,\"179\":1,\"182\":1,\"188\":1,\"197\":1,\"198\":1,\"217\":1,\"225\":1,\"230\":1}}],[\"sun\",{\"1\":{\"201\":1,\"241\":2,\"242\":3,\"254\":2}}],[\"survivorration\",{\"1\":{\"160\":1}}],[\"survivorratio=ratio晋升阈值\",{\"1\":{\"155\":1}}],[\"survivor\",{\"1\":{\"160\":1}}],[\"sum\",{\"1\":{\"18\":1,\"253\":4}}],[\"s6=s4\",{\"1\":{\"125\":1}}],[\"s\",{\"1\":{\"123\":3,\"161\":1,\"163\":2,\"165\":1,\"220\":1,\"248\":2,\"253\":6}}],[\"s5==s3\",{\"1\":{\"123\":1}}],[\"s5=\",{\"1\":{\"123\":1,\"125\":2}}],[\"s4是由stringbuffer的tostring方法所返回的一个对象\",{\"1\":{\"123\":1}}],[\"s4=s1+s2\",{\"1\":{\"123\":2,\"125\":2}}],[\"s3==s6\",{\"1\":{\"125\":1}}],[\"s3==s5\",{\"1\":{\"125\":1}}],[\"s3==s4\",{\"1\":{\"123\":1,\"125\":1}}],[\"s3=\",{\"1\":{\"123\":1,\"125\":1}}],[\"s3\",{\"1\":{\"123\":2,\"125\":1,\"197\":3}}],[\"s2=\",{\"1\":{\"125\":1}}],[\"s2\",{\"1\":{\"123\":4,\"169\":1,\"197\":2}}],[\"s1=\",{\"1\":{\"125\":1}}],[\"s1\",{\"1\":{\"123\":2,\"169\":1,\"197\":2}}],[\"src\",{\"1\":{\"121\":2,\"188\":2}}],[\"sb\",{\"1\":{\"108\":15}}],[\"sbuffer\",{\"1\":{\"85\":5}}],[\"scope\",{\"1\":{\"253\":1}}],[\"scope>\",{\"1\":{\"253\":1}}],[\"score\",{\"1\":{\"85\":4,\"253\":4}}],[\"scavenge\",{\"1\":{\"158\":2,\"160\":3}}],[\"scavenge使用标记\",{\"1\":{\"158\":1}}],[\"scavengebeforefullgc\",{\"1\":{\"156\":1,\"157\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"92\":1}}],[\"sleep\",{\"1\":{\"80\":1,\"97\":3,\"98\":1,\"101\":1,\"157\":2,\"260\":1,\"262\":1}}],[\"slot\",{\"1\":{\"71\":4,\"192\":1,\"193\":2,\"197\":2,\"210\":2,\"211\":1,\"220\":3}}],[\"synctest\",{\"1\":{\"215\":1}}],[\"synchronized关键字\",{\"1\":{\"138\":1}}],[\"synchronized和reentrantlock对比\",{\"0\":{\"89\":1}}],[\"synchronized消除锁的策略是比较保守的\",{\"1\":{\"85\":1}}],[\"synchronized开始\",{\"1\":{\"71\":1}}],[\"synchronized\",{\"0\":{\"69\":1,\"87\":1,\"215\":1,\"258\":1},\"1\":{\"59\":1,\"61\":1,\"65\":2,\"68\":2,\"70\":1,\"71\":5,\"76\":3,\"79\":4,\"80\":2,\"81\":4,\"82\":3,\"83\":4,\"84\":1,\"85\":1,\"87\":1,\"215\":1,\"242\":1,\"258\":7,\"262\":2}}],[\"synthetic\",{\"1\":{\"182\":2,\"227\":1}}],[\"system\",{\"1\":{\"79\":1,\"98\":4,\"101\":2,\"106\":1,\"108\":2,\"115\":1,\"120\":1,\"123\":4,\"125\":5,\"127\":1,\"132\":3,\"133\":13,\"139\":5,\"146\":9,\"147\":6,\"157\":1,\"179\":1,\"182\":1,\"187\":1,\"188\":4,\"193\":4,\"196\":2,\"197\":3,\"199\":4,\"200\":1,\"211\":1,\"213\":2,\"214\":1,\"215\":2,\"220\":2,\"221\":2,\"222\":4,\"223\":8,\"224\":4,\"226\":2,\"227\":1,\"228\":4,\"233\":1,\"234\":1,\"237\":9,\"238\":4,\"240\":2,\"241\":2,\"242\":2,\"245\":1,\"246\":1,\"251\":3,\"252\":6,\"254\":1,\"256\":1,\"258\":1,\"262\":1,\"274\":2}}],[\"singleton\",{\"1\":{\"238\":5}}],[\"single\",{\"0\":{\"210\":1}}],[\"sipush\",{\"1\":{\"192\":1}}],[\"size=3\",{\"1\":{\"197\":1}}],[\"size=0\",{\"1\":{\"197\":1,\"213\":1,\"214\":1}}],[\"size=1\",{\"1\":{\"71\":1,\"123\":2,\"188\":2,\"193\":1,\"196\":1,\"198\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"215\":1,\"219\":1,\"220\":2}}],[\"size\",{\"1\":{\"132\":7,\"146\":3,\"188\":1,\"253\":3,\"274\":2}}],[\"signature\",{\"1\":{\"71\":1,\"193\":1,\"210\":1,\"211\":1,\"220\":3}}],[\"stw\",{\"1\":{\"160\":1,\"161\":1,\"163\":2,\"176\":1}}],[\"str2\",{\"1\":{\"124\":1}}],[\"str\",{\"1\":{\"123\":2,\"223\":8}}],[\"stringtablesize=桶个数\",{\"1\":{\"128\":1}}],[\"stringtablestudy\",{\"1\":{\"123\":1}}],[\"stringtabletest\",{\"1\":{\"127\":1}}],[\"stringtable在内存紧张时\",{\"1\":{\"127\":1}}],[\"stringtable是放在堆中的\",{\"1\":{\"126\":1}}],[\"stringtable是属于常量池的一部分\",{\"1\":{\"126\":1}}],[\"stringtable\",{\"0\":{\"126\":1,\"127\":1,\"128\":1},\"1\":{\"123\":1,\"127\":1}}],[\"stringbuilder\",{\"1\":{\"108\":6,\"115\":2,\"123\":17}}],[\"stringbuffer\",{\"1\":{\"85\":2}}],[\"string\",{\"1\":{\"71\":3,\"80\":1,\"97\":1,\"101\":1,\"108\":2,\"115\":2,\"120\":1,\"123\":37,\"124\":1,\"125\":19,\"127\":2,\"132\":1,\"133\":1,\"139\":1,\"146\":2,\"147\":1,\"155\":1,\"156\":1,\"157\":1,\"169\":4,\"179\":1,\"182\":4,\"187\":1,\"188\":9,\"193\":4,\"194\":1,\"195\":3,\"196\":1,\"197\":4,\"198\":1,\"199\":2,\"206\":2,\"209\":1,\"210\":4,\"211\":4,\"212\":1,\"213\":2,\"214\":1,\"215\":3,\"218\":3,\"219\":1,\"220\":5,\"221\":12,\"222\":4,\"223\":7,\"224\":2,\"225\":2,\"226\":3,\"227\":1,\"228\":2,\"230\":2,\"233\":1,\"234\":1,\"237\":1,\"238\":2,\"240\":1,\"242\":1,\"246\":4,\"248\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"256\":1,\"258\":1,\"260\":1,\"262\":1,\"274\":1}}],[\"study\",{\"1\":{\"121\":2}}],[\"statement\",{\"1\":{\"175\":1,\"226\":1}}],[\"state\",{\"1\":{\"77\":1,\"94\":1,\"253\":1}}],[\"static变量在分配空间和赋值是在两个阶段完成的\",{\"1\":{\"233\":1}}],[\"static变量在jdk\",{\"1\":{\"233\":1}}],[\"static\",{\"1\":{\"71\":3,\"76\":4,\"79\":1,\"80\":1,\"81\":1,\"82\":2,\"84\":2,\"85\":1,\"97\":1,\"101\":1,\"108\":7,\"115\":1,\"120\":1,\"123\":4,\"125\":1,\"127\":1,\"132\":3,\"133\":5,\"139\":1,\"146\":6,\"147\":4,\"155\":6,\"156\":6,\"157\":6,\"175\":1,\"179\":1,\"187\":1,\"188\":2,\"193\":3,\"194\":1,\"195\":3,\"196\":1,\"197\":6,\"198\":2,\"199\":2,\"205\":1,\"209\":1,\"210\":3,\"211\":4,\"212\":1,\"213\":4,\"214\":2,\"215\":1,\"218\":3,\"219\":1,\"220\":3,\"221\":4,\"222\":4,\"223\":4,\"224\":5,\"225\":6,\"226\":3,\"227\":1,\"228\":4,\"233\":4,\"234\":1,\"237\":8,\"238\":8,\"240\":2,\"241\":2,\"245\":2,\"246\":1,\"248\":1,\"251\":1,\"252\":3,\"253\":5,\"254\":3,\"256\":2,\"258\":3,\"260\":2,\"262\":2,\"274\":4}}],[\"stack等\",{\"1\":{\"192\":1}}],[\"stack=3\",{\"1\":{\"211\":1}}],[\"stack=1\",{\"1\":{\"188\":1,\"197\":1,\"209\":1,\"210\":1,\"212\":1,\"213\":1,\"214\":1,\"220\":1}}],[\"stack=2\",{\"1\":{\"71\":1,\"123\":2,\"188\":1,\"191\":1,\"193\":1,\"196\":1,\"197\":1,\"198\":1,\"215\":1,\"219\":1,\"220\":1}}],[\"stackoverflowerror\",{\"1\":{\"109\":2}}],[\"stack\",{\"1\":{\"71\":1}}],[\"stackmaptable\",{\"1\":{\"71\":1,\"210\":1,\"211\":1}}],[\"start\",{\"1\":{\"68\":2,\"71\":1,\"79\":2,\"80\":2,\"81\":2,\"82\":3,\"97\":3,\"98\":2,\"101\":1,\"157\":1,\"193\":1,\"210\":1,\"211\":1,\"220\":3,\"251\":2,\"252\":2,\"256\":2,\"258\":2,\"260\":1,\"262\":1}}],[\"stop\",{\"1\":{\"68\":2,\"153\":2,\"159\":2,\"161\":2}}],[\"csdn\",{\"1\":{\"263\":2}}],[\"current\",{\"1\":{\"253\":1}}],[\"currentthread\",{\"1\":{\"237\":2,\"248\":1}}],[\"c1\",{\"1\":{\"251\":4}}],[\"cvf\",{\"1\":{\"241\":1}}],[\"c2\",{\"1\":{\"237\":2,\"251\":2}}],[\"c++\",{\"1\":{\"230\":1}}],[\"cinittest\",{\"1\":{\"197\":1}}],[\"cinit\",{\"1\":{\"197\":3,\"238\":1}}],[\"cnblogs\",{\"1\":{\"276\":2}}],[\"cnady6\",{\"1\":{\"223\":1}}],[\"cn\",{\"1\":{\"182\":1,\"193\":1,\"199\":1,\"202\":1,\"220\":1,\"227\":2,\"233\":1,\"234\":2,\"237\":3,\"240\":4,\"241\":4,\"248\":6}}],[\"cp\",{\"1\":{\"179\":1,\"201\":1}}],[\"cpu占用过高\",{\"1\":{\"110\":1}}],[\"cpu\",{\"1\":{\"60\":1,\"106\":1,\"110\":1,\"158\":1,\"159\":2,\"169\":1,\"173\":1,\"254\":4}}],[\"choose\",{\"1\":{\"223\":2}}],[\"chop\",{\"1\":{\"71\":1}}],[\"checkcast\",{\"1\":{\"219\":1,\"220\":1}}],[\"checksum\",{\"1\":{\"188\":1}}],[\"char\",{\"1\":{\"169\":2,\"194\":1}}],[\"cm\",{\"1\":{\"164\":1}}],[\"cms收集器的运行过程分为下列4步\",{\"1\":{\"161\":1}}],[\"cms\",{\"1\":{\"161\":2,\"166\":1,\"174\":1,\"177\":2,\"178\":1}}],[\"cmsinitiatingoccupancyfraction=percent\",{\"1\":{\"161\":1,\"177\":1}}],[\"cms多线程的垃圾收集器\",{\"1\":{\"158\":1}}],[\"create\",{\"1\":{\"132\":1,\"274\":1}}],[\"cl\",{\"1\":{\"237\":2,\"248\":2}}],[\"close\",{\"1\":{\"226\":8}}],[\"clone\",{\"1\":{\"206\":2,\"225\":1}}],[\"client\",{\"1\":{\"158\":1}}],[\"clean\",{\"1\":{\"132\":2}}],[\"cleaner\",{\"1\":{\"132\":5}}],[\"classpath\",{\"1\":{\"239\":1,\"241\":3,\"242\":1,\"243\":1}}],[\"class<s>\",{\"1\":{\"248\":1}}],[\"class<\",{\"1\":{\"233\":1,\"234\":1,\"240\":1,\"242\":2,\"248\":1}}],[\"classnotfoundexception\",{\"1\":{\"233\":1,\"234\":1,\"237\":1,\"240\":1,\"242\":3,\"248\":1}}],[\"class结构中有vtable\",{\"1\":{\"199\":1}}],[\"classfile\",{\"1\":{\"188\":1}}],[\"class文件\",{\"1\":{\"121\":2}}],[\"classwriter\",{\"1\":{\"120\":3}}],[\"classloader\",{\"1\":{\"104\":1,\"120\":6,\"233\":3,\"234\":3,\"237\":2,\"239\":3,\"243\":1,\"245\":1,\"246\":2,\"248\":1}}],[\"classlayout\",{\"1\":{\"79\":4,\"80\":3,\"81\":4,\"82\":8}}],[\"class\",{\"0\":{\"204\":1},\"1\":{\"67\":1,\"68\":1,\"71\":3,\"79\":4,\"85\":1,\"101\":1,\"104\":1,\"108\":2,\"115\":1,\"120\":3,\"121\":1,\"122\":1,\"123\":6,\"125\":1,\"127\":1,\"132\":1,\"133\":3,\"146\":2,\"147\":1,\"155\":1,\"156\":1,\"157\":1,\"179\":5,\"180\":2,\"182\":6,\"183\":1,\"185\":2,\"187\":1,\"188\":7,\"193\":1,\"194\":1,\"195\":3,\"196\":1,\"197\":2,\"198\":2,\"199\":4,\"203\":1,\"204\":1,\"205\":4,\"206\":1,\"207\":2,\"209\":2,\"210\":4,\"211\":5,\"212\":2,\"213\":2,\"214\":1,\"215\":2,\"216\":2,\"217\":2,\"218\":3,\"219\":3,\"220\":8,\"221\":2,\"222\":4,\"223\":4,\"224\":3,\"225\":2,\"226\":4,\"227\":4,\"228\":6,\"230\":3,\"232\":1,\"233\":4,\"234\":4,\"237\":10,\"238\":4,\"239\":1,\"240\":3,\"241\":4,\"242\":2,\"245\":3,\"246\":3,\"247\":1,\"248\":2,\"251\":1,\"252\":1,\"253\":2,\"254\":3,\"256\":1,\"258\":1,\"262\":1}}],[\"cd\",{\"1\":{\"125\":1}}],[\"cdots\",{\"1\":{\"18\":1}}],[\"cw\",{\"1\":{\"120\":3}}],[\"cb\",{\"1\":{\"98\":3}}],[\"cache\",{\"1\":{\"251\":1}}],[\"cannot\",{\"1\":{\"248\":1}}],[\"candy9\",{\"1\":{\"226\":3}}],[\"candy7\",{\"1\":{\"224\":2}}],[\"candy6\",{\"1\":{\"223\":5}}],[\"candy5\",{\"1\":{\"222\":6}}],[\"candy4\",{\"1\":{\"221\":3}}],[\"candy\",{\"1\":{\"220\":2}}],[\"candy3\",{\"1\":{\"219\":1,\"220\":2}}],[\"candy2\",{\"1\":{\"218\":3}}],[\"candy11$1\",{\"1\":{\"228\":5}}],[\"candy11\",{\"1\":{\"228\":2}}],[\"candy10$1\",{\"1\":{\"228\":2}}],[\"candy10\",{\"1\":{\"228\":2}}],[\"candy1\",{\"1\":{\"217\":3}}],[\"cat\",{\"1\":{\"199\":2}}],[\"catch块执行完\",{\"1\":{\"212\":1}}],[\"catch块\",{\"1\":{\"212\":1}}],[\"catch\",{\"0\":{\"209\":1,\"210\":1,\"211\":1},\"1\":{\"79\":2,\"80\":2,\"81\":1,\"98\":3,\"101\":1,\"115\":1,\"127\":1,\"132\":2,\"209\":1,\"210\":3,\"211\":1,\"212\":3,\"226\":7,\"242\":1,\"246\":3,\"248\":2}}],[\"ca\",{\"1\":{\"179\":1,\"180\":2,\"181\":2,\"182\":3}}],[\"card\",{\"1\":{\"167\":1}}],[\"cap\",{\"1\":{\"132\":7}}],[\"capacity\",{\"1\":{\"132\":3}}],[\"cast\",{\"1\":{\"248\":1}}],[\"case\",{\"1\":{\"223\":11,\"224\":6}}],[\"cas\",{\"0\":{\"91\":1},\"1\":{\"76\":3,\"83\":4,\"84\":2,\"91\":3,\"94\":1}}],[\"c\",{\"1\":{\"76\":1,\"85\":5,\"108\":2,\"125\":1,\"187\":2,\"188\":2,\"223\":4,\"233\":4,\"234\":4,\"237\":2,\"238\":3,\"242\":8,\"248\":4}}],[\"core<\",{\"1\":{\"253\":1}}],[\"could\",{\"1\":{\"248\":1}}],[\"countdown\",{\"1\":{\"97\":4}}],[\"countdownlatch等\",{\"1\":{\"92\":1}}],[\"countdownlatch\",{\"0\":{\"97\":1},\"1\":{\"59\":1,\"97\":2,\"98\":1}}],[\"count++\",{\"1\":{\"67\":1,\"258\":1,\"274\":1}}],[\"count\",{\"1\":{\"67\":1,\"179\":10,\"258\":1,\"274\":2}}],[\"counter++\",{\"1\":{\"71\":1}}],[\"counter\",{\"1\":{\"62\":2,\"71\":1,\"106\":1}}],[\"collection\",{\"0\":{\"163\":1,\"167\":1},\"1\":{\"162\":3}}],[\"copyonwritearraylist<>\",{\"1\":{\"245\":1}}],[\"copyonwritearraylist<driverinfo>\",{\"1\":{\"245\":1}}],[\"copyof\",{\"1\":{\"115\":1}}],[\"copy\",{\"1\":{\"153\":1}}],[\"com\",{\"1\":{\"115\":1,\"120\":1,\"121\":2,\"125\":1,\"194\":1,\"245\":3,\"263\":1,\"276\":3}}],[\"compilercontrol\",{\"1\":{\"253\":4}}],[\"compilecommand=dontinline\",{\"1\":{\"252\":1}}],[\"compiled\",{\"1\":{\"188\":1}}],[\"completablefuture是java\",{\"1\":{\"100\":1}}],[\"completablefuture\",{\"0\":{\"100\":1}}],[\"compare\",{\"1\":{\"87\":1,\"91\":1}}],[\"codebear\",{\"1\":{\"276\":1}}],[\"code\",{\"1\":{\"71\":1,\"120\":4,\"123\":2,\"127\":1,\"133\":1,\"146\":1,\"147\":1,\"155\":1,\"182\":2,\"188\":3,\"193\":1,\"196\":2,\"197\":2,\"198\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":2,\"219\":1,\"220\":3,\"233\":2,\"251\":1,\"253\":1}}],[\"connector\",{\"1\":{\"245\":1}}],[\"connection\",{\"1\":{\"226\":1}}],[\"console\",{\"1\":{\"204\":1,\"205\":1}}],[\"constants\",{\"1\":{\"230\":1}}],[\"constant\",{\"1\":{\"179\":3,\"182\":15,\"188\":1,\"252\":1}}],[\"concgcthreads=threads\",{\"1\":{\"161\":1}}],[\"concurrent\",{\"1\":{\"59\":4,\"68\":1,\"101\":1,\"161\":2,\"162\":1,\"167\":1,\"253\":1}}],[\"cond\",{\"1\":{\"62\":2}}],[\"condition\",{\"1\":{\"59\":1}}],[\"cyclicbarrier\",{\"0\":{\"98\":1},\"1\":{\"59\":2,\"98\":5}}],[\"jianshu\",{\"1\":{\"276\":1}}],[\"jit2\",{\"1\":{\"252\":2}}],[\"jit\",{\"1\":{\"251\":1,\"260\":1}}],[\"jit1\",{\"1\":{\"251\":1}}],[\"jre\",{\"1\":{\"239\":2,\"241\":2,\"242\":1,\"245\":2}}],[\"jclasslib\",{\"1\":{\"216\":1}}],[\"jconsole\",{\"1\":{\"116\":1}}],[\"jdbc\",{\"1\":{\"245\":5,\"246\":3,\"247\":1}}],[\"jdi\",{\"1\":{\"201\":1}}],[\"jdk\",{\"0\":{\"171\":1},\"1\":{\"162\":1,\"171\":3,\"201\":1,\"218\":3,\"219\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":1,\"226\":1,\"239\":1}}],[\"jdk<1\",{\"1\":{\"158\":1}}],[\"jdk8\",{\"1\":{\"121\":1,\"162\":1}}],[\"jdk1\",{\"1\":{\"119\":1,\"126\":2,\"160\":1,\"178\":1}}],[\"jpg\",{\"1\":{\"180\":1}}],[\"jps\",{\"1\":{\"139\":1,\"200\":1}}],[\"jps工具\",{\"1\":{\"116\":1}}],[\"j++\",{\"1\":{\"120\":1,\"127\":1,\"251\":1,\"252\":1,\"256\":2,\"258\":2}}],[\"j\",{\"1\":{\"120\":2,\"127\":5,\"251\":2,\"252\":2,\"256\":4,\"258\":4}}],[\"jvisualvm\",{\"1\":{\"116\":1}}],[\"jvm要保证每个monitorenter必须有对应的monitorexit与之配对\",{\"1\":{\"258\":1}}],[\"jvm基于进入和退出monitor对象来实现方法同步和代码块同步\",{\"1\":{\"258\":1}}],[\"jvm>jar\",{\"1\":{\"241\":1}}],[\"jvm>java\",{\"1\":{\"240\":1}}],[\"jvm规范\",{\"1\":{\"232\":1}}],[\"jvms\",{\"1\":{\"194\":3}}],[\"jvm中的垃圾回收器通过可达性分析来探索所有存活的对象\",{\"1\":{\"137\":1}}],[\"jvm\",{\"1\":{\"68\":1,\"79\":1,\"81\":1,\"82\":1,\"106\":1,\"121\":2,\"133\":1,\"155\":1,\"164\":1,\"179\":1,\"182\":2,\"193\":1,\"199\":2,\"201\":1,\"202\":1,\"220\":2,\"224\":1,\"227\":2,\"233\":1,\"234\":2,\"237\":3,\"240\":5,\"241\":5,\"251\":1,\"256\":1},\"2\":{\"102\":1,\"103\":1,\"264\":1,\"265\":1}}],[\"jmh<\",{\"1\":{\"253\":2}}],[\"jmh\",{\"1\":{\"253\":9}}],[\"jmap\",{\"1\":{\"116\":2,\"139\":1}}],[\"jmm\",{\"1\":{\"65\":3,\"254\":4}}],[\"jmm定义了线程和主内存之间的抽象关系\",{\"1\":{\"65\":1}}],[\"jstack\",{\"1\":{\"110\":1}}],[\"jar\",{\"1\":{\"85\":4,\"201\":1,\"241\":2,\"245\":1,\"246\":1,\"254\":2}}],[\"java并发编程的艺术\",{\"1\":{\"258\":1}}],[\"java镜像类\",{\"1\":{\"230\":1}}],[\"javase\",{\"1\":{\"194\":1}}],[\"javajdk1\",{\"1\":{\"172\":1}}],[\"javap工具\",{\"0\":{\"185\":1}}],[\"javap\",{\"1\":{\"121\":2,\"185\":2,\"216\":1}}],[\"javac在编译期会进行优化\",{\"1\":{\"123\":1}}],[\"javac对应类的绝对路径\",{\"1\":{\"121\":1}}],[\"javac\",{\"1\":{\"121\":1,\"179\":1}}],[\"java对象的类数据保存在方法区\",{\"1\":{\"74\":1}}],[\"java里面是基于内存共享来进行线程间的通信\",{\"1\":{\"59\":1}}],[\"java虚拟机\",{\"0\":{\"59\":1,\"104\":1}}],[\"java\",{\"0\":{\"54\":1},\"1\":{\"59\":7,\"65\":4,\"68\":1,\"70\":1,\"71\":2,\"76\":1,\"85\":2,\"104\":2,\"109\":2,\"115\":15,\"116\":1,\"118\":2,\"120\":9,\"121\":3,\"123\":10,\"131\":5,\"132\":8,\"172\":1,\"179\":2,\"181\":1,\"182\":4,\"188\":15,\"192\":1,\"193\":5,\"196\":2,\"199\":1,\"201\":1,\"206\":3,\"209\":1,\"210\":4,\"211\":4,\"212\":1,\"215\":4,\"216\":5,\"217\":1,\"219\":7,\"220\":13,\"221\":1,\"226\":5,\"227\":4,\"230\":7,\"233\":1,\"239\":4,\"240\":3,\"241\":2,\"245\":3,\"253\":3,\"254\":7,\"256\":2},\"2\":{\"55\":1}}],[\"join\",{\"1\":{\"61\":1,\"79\":1,\"82\":1,\"256\":2,\"258\":2}}],[\"join原理\",{\"0\":{\"61\":1}}],[\"juc是指package\",{\"1\":{\"59\":1}}],[\"蔬菜\",{\"2\":{\"52\":1}}],[\"番茄\",{\"0\":{\"49\":1}}],[\"草莓\",{\"0\":{\"44\":1},\"2\":{\"47\":1}}],[\"大部分对象用过即死\",{\"1\":{\"176\":1}}],[\"大表\",{\"1\":{\"175\":1}}],[\"大\",{\"2\":{\"43\":1,\"290\":1,\"295\":1,\"300\":1,\"305\":1}}],[\"水果\",{\"2\":{\"42\":1,\"47\":1,\"299\":1,\"304\":1,\"309\":1,\"314\":1}}],[\"火龙果\",{\"0\":{\"39\":1},\"2\":{\"42\":1}}],[\"圆\",{\"2\":{\"38\":1,\"53\":1,\"290\":1,\"295\":1,\"300\":1,\"305\":1}}],[\"小结\",{\"0\":{\"207\":1}}],[\"小\",{\"2\":{\"38\":1,\"48\":1}}],[\"红\",{\"2\":{\"38\":1,\"43\":1,\"48\":1,\"53\":1,\"290\":1,\"295\":1,\"300\":1,\"305\":1}}],[\"368960\",{\"1\":{\"253\":1}}],[\"3层\",{\"1\":{\"251\":1}}],[\"38\",{\"1\":{\"197\":1}}],[\"322\",{\"1\":{\"241\":1}}],[\"32767\",{\"1\":{\"192\":1}}],[\"32768\",{\"1\":{\"192\":2}}],[\"32项\",{\"1\":{\"182\":1}}],[\"32\",{\"1\":{\"182\":2,\"193\":2,\"220\":1}}],[\"3项\",{\"1\":{\"182\":1}}],[\"371262\",{\"1\":{\"253\":1}}],[\"37\",{\"1\":{\"179\":1}}],[\"3b\",{\"1\":{\"179\":5,\"182\":11}}],[\"351\",{\"1\":{\"253\":1}}],[\"35\",{\"1\":{\"179\":2,\"182\":3,\"197\":1}}],[\"3e\",{\"1\":{\"179\":1,\"182\":4}}],[\"3c\",{\"1\":{\"179\":1,\"182\":4}}],[\"33项\",{\"1\":{\"182\":1}}],[\"33\",{\"1\":{\"123\":1,\"182\":2,\"193\":1,\"197\":1,\"241\":1}}],[\"3332\",{\"1\":{\"115\":1}}],[\"3堆内存溢出\",{\"0\":{\"115\":1}}],[\"391\",{\"1\":{\"253\":1}}],[\"390747\",{\"1\":{\"253\":1}}],[\"39\",{\"1\":{\"82\":1}}],[\"3001\",{\"1\":{\"263\":1}}],[\"30287\",{\"1\":{\"188\":2}}],[\"30项\",{\"1\":{\"182\":1}}],[\"30\",{\"1\":{\"81\":2,\"182\":2,\"193\":1,\"197\":7,\"210\":2,\"211\":2,\"212\":4,\"215\":2,\"219\":1,\"220\":1}}],[\"31项\",{\"1\":{\"182\":1}}],[\"311\",{\"1\":{\"132\":1}}],[\"31\",{\"1\":{\"77\":1,\"123\":1,\"182\":2,\"211\":1,\"219\":1,\"220\":2}}],[\"34项\",{\"1\":{\"182\":2}}],[\"34h\",{\"1\":{\"181\":1}}],[\"34\",{\"1\":{\"67\":1,\"179\":1,\"180\":1,\"181\":4,\"182\":5,\"197\":1}}],[\"3\",{\"0\":{\"36\":1,\"41\":1,\"46\":1,\"51\":1,\"110\":1,\"111\":1,\"120\":1,\"133\":1,\"140\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1,\"161\":1,\"175\":1,\"182\":1,\"189\":1,\"193\":1,\"202\":1,\"211\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":2,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"234\":1,\"235\":1,\"242\":1,\"253\":1,\"263\":1,\"288\":1,\"293\":1,\"296\":1,\"298\":1,\"303\":1,\"308\":1,\"313\":1,\"316\":1,\"318\":1,\"323\":1},\"1\":{\"71\":4,\"72\":1,\"81\":4,\"94\":4,\"97\":1,\"106\":3,\"108\":3,\"123\":10,\"177\":1,\"182\":1,\"188\":3,\"192\":5,\"193\":5,\"194\":2,\"195\":2,\"196\":3,\"197\":6,\"198\":2,\"210\":3,\"211\":3,\"212\":3,\"213\":1,\"214\":2,\"215\":4,\"219\":2,\"220\":3,\"222\":4,\"237\":2,\"273\":1}}],[\"这就是布隆过滤器的计算原理\",{\"1\":{\"273\":1}}],[\"这就是我们所说的缓存穿透问题\",{\"1\":{\"269\":1}}],[\"这是有数学论文进行验证\",{\"1\":{\"273\":1}}],[\"这是因为当一个线程抛出oom异常后\",{\"1\":{\"157\":1}}],[\"这句话可以表达得更通俗一些\",{\"1\":{\"239\":1}}],[\"这三个常量是否会导致\",{\"1\":{\"238\":1}}],[\"这同时解释了为什么匿名内部类引用局部变量时\",{\"1\":{\"228\":2}}],[\"这段代码在\",{\"1\":{\"218\":1}}],[\"这告诉我们\",{\"1\":{\"213\":1}}],[\"这种调节方式称为\",{\"1\":{\"160\":1}}],[\"这类题记住编译器在编译期间会把字符字面量作为常量放在常量池中\",{\"1\":{\"125\":1}}],[\"这两个字符串的hashcode值都是\",{\"1\":{\"223\":1}}],[\"这两个语句都会去字符串常量池中检查是否已经存在\",{\"1\":{\"124\":1}}],[\"这两种情况都会把串池中的对象返回\",{\"1\":{\"123\":1}}],[\"这两者通常是相辅相成的\",{\"1\":{\"65\":1}}],[\"这在某些情况下可以提高性能\",{\"1\":{\"101\":1}}],[\"这行代码会使当前线程进入等待状态\",{\"1\":{\"101\":1}}],[\"这通常用于实现锁和其他同步器的框架\",{\"1\":{\"101\":1}}],[\"这不同于之前讲的细分锁的粒度\",{\"1\":{\"86\":1}}],[\"这些类希望予以隔离\",{\"1\":{\"243\":1}}],[\"这些垃圾就叫浮动垃圾\",{\"1\":{\"161\":1}}],[\"这些加锁解锁操作完全没有必要\",{\"1\":{\"85\":1}}],[\"这些修改不会相互干扰\",{\"1\":{\"65\":1}}],[\"这时候才会解开门上的锁\",{\"1\":{\"258\":1}}],[\"这时候如果\",{\"1\":{\"258\":1}}],[\"这时操作数栈中有一份对象的引用\",{\"1\":{\"215\":1}}],[\"这时也需要执行finally块中的代码\",{\"1\":{\"212\":1}}],[\"这时运行\",{\"1\":{\"200\":1}}],[\"这时a引用了c\",{\"1\":{\"168\":1}}],[\"这时就会用到remark\",{\"1\":{\"168\":1}}],[\"这时不仅会回收伊甸园中的垃圾\",{\"1\":{\"153\":1}}],[\"这时终结器对象就会被放入引用队列中\",{\"1\":{\"145\":1}}],[\"这时需要将虚引用对象cleaner放入引用队列中\",{\"1\":{\"144\":1}}],[\"这时需要定位占用cpu过高的线程\",{\"1\":{\"110\":1}}],[\"这时需要进行锁膨胀\",{\"1\":{\"84\":1}}],[\"这时会进入重量级解锁流程\",{\"1\":{\"84\":1}}],[\"这时\",{\"1\":{\"84\":1,\"94\":2}}],[\"这时一种情况就是有其它线程为此对象加上了轻量级锁\",{\"1\":{\"84\":1}}],[\"这时使用\",{\"1\":{\"83\":1}}],[\"这时重置锁记录\",{\"1\":{\"83\":1}}],[\"这时表明有竞争\",{\"1\":{\"83\":1}}],[\"这时偏向了线程\",{\"1\":{\"81\":1}}],[\"这确保了在\",{\"1\":{\"67\":1}}],[\"这样用户再次以该key请求后台的时候\",{\"1\":{\"270\":1}}],[\"这样很多个非法的请求直接打在数据库中\",{\"1\":{\"269\":1}}],[\"这样就可以使用\",{\"1\":{\"247\":1}}],[\"这样问题来了\",{\"1\":{\"245\":1}}],[\"这样的\",{\"1\":{\"230\":2}}],[\"这样也可以避免内存碎片的问题\",{\"1\":{\"151\":1}}],[\"这样下一次解释器会从程序计数器拿到指令然后进行解释执行\",{\"1\":{\"106\":1}}],[\"这样\",{\"1\":{\"67\":1}}],[\"这意味着\",{\"1\":{\"66\":1}}],[\"这意味着你可以在\",{\"1\":{\"29\":1,\"283\":1}}],[\"这里引用\",{\"1\":{\"258\":1}}],[\"这里所说的\",{\"1\":{\"243\":1}}],[\"这里一个例子来验证\",{\"1\":{\"237\":1}}],[\"这里进行了类型转换\",{\"1\":{\"219\":1}}],[\"这里进行了泛型擦除\",{\"1\":{\"219\":1}}],[\"这里也进行了泛型擦除\",{\"1\":{\"219\":1}}],[\"这里没有\",{\"1\":{\"213\":1}}],[\"这里的\",{\"1\":{\"246\":1}}],[\"这里的比较是将两个数做减法\",{\"1\":{\"196\":1}}],[\"这里的清除并不是将内存空间字节清零\",{\"1\":{\"149\":1}}],[\"这里小的数字都是和字节码指令存在一起\",{\"1\":{\"192\":1}}],[\"这里是directbytebuffer\",{\"1\":{\"132\":1}}],[\"这里是内容\",{\"1\":{\"35\":1,\"36\":1,\"40\":1,\"41\":1,\"45\":1,\"46\":1,\"50\":1,\"51\":1,\"287\":1,\"288\":1,\"292\":1,\"293\":1,\"297\":1,\"298\":1,\"302\":1,\"303\":1,\"307\":1,\"308\":1,\"312\":1,\"313\":1,\"317\":1,\"318\":1,\"322\":1,\"323\":1}}],[\"这里调用了一个cleaner的create方法\",{\"1\":{\"132\":1}}],[\"这里必须是司机停车的时候才能接单\",{\"1\":{\"64\":1}}],[\"这里跟现实不一样\",{\"1\":{\"64\":1}}],[\"这里代入一下\",{\"1\":{\"62\":1}}],[\"这个时候\",{\"1\":{\"273\":1}}],[\"这个功能其实也是语法糖\",{\"1\":{\"223\":1}}],[\"这个特性是\",{\"1\":{\"218\":1}}],[\"这个无参构造器是java编译器帮我们加上的\",{\"1\":{\"217\":1}}],[\"这个对象就归该线程所有\",{\"1\":{\"76\":1}}],[\"这个线程\",{\"1\":{\"76\":1}}],[\"这个操作在多线程环境下不是原子的\",{\"1\":{\"67\":1}}],[\"这个变量可能会被不同的线程同时访问和修改\",{\"1\":{\"66\":1}}],[\"这个包是为了解决并发问题的\",{\"1\":{\"59\":1}}],[\"这个并发包\",{\"1\":{\"59\":1}}],[\"樱桃\",{\"0\":{\"34\":1},\"2\":{\"37\":1}}],[\"学习笔记\",{\"0\":{\"32\":1},\"2\":{\"33\":1}}],[\"标记+整理\",{\"1\":{\"162\":1}}],[\"标记\",{\"1\":{\"158\":1,\"161\":3}}],[\"标记整理\",{\"0\":{\"150\":1}}],[\"标记清除\",{\"0\":{\"149\":1}}],[\"标签为\",{\"1\":{\"27\":1,\"281\":1}}],[\"标题\",{\"0\":{\"35\":1,\"36\":1,\"40\":1,\"41\":1,\"45\":1,\"46\":1,\"50\":1,\"51\":1,\"287\":1,\"288\":1,\"292\":1,\"293\":1,\"297\":1,\"298\":1,\"302\":1,\"303\":1,\"307\":1,\"308\":1,\"312\":1,\"313\":1,\"317\":1,\"318\":1,\"322\":1,\"323\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"26\":1,\"280\":1}}],[\"标题和页面信息\",{\"1\":{\"6\":1}}],[\"日\",{\"1\":{\"27\":1,\"281\":1}}],[\"月\",{\"1\":{\"27\":1,\"281\":1}}],[\"年\",{\"1\":{\"27\":1,\"281\":1}}],[\"的访问\",{\"1\":{\"260\":1}}],[\"的静态变量一个做自增\",{\"1\":{\"256\":1}}],[\"的静态代码块中\",{\"1\":{\"245\":1}}],[\"的意思\",{\"1\":{\"254\":1}}],[\"的元素\",{\"1\":{\"253\":1}}],[\"的优化\",{\"1\":{\"252\":1}}],[\"的内存模型如下\",{\"1\":{\"256\":1}}],[\"的内存地址\",{\"0\":{\"204\":1},\"1\":{\"204\":1}}],[\"的内部类\",{\"1\":{\"248\":1}}],[\"的思想\",{\"1\":{\"247\":1}}],[\"的类加载器\",{\"1\":{\"245\":1}}],[\"的类镜像\",{\"1\":{\"230\":1}}],[\"的上级是bootstarp\",{\"1\":{\"242\":1}}],[\"的线程安全\",{\"1\":{\"236\":1}}],[\"的线程都处于阻塞状态\",{\"1\":{\"60\":1}}],[\"的基本类型\",{\"1\":{\"233\":1}}],[\"的基础\",{\"1\":{\"65\":1}}],[\"的魔数\",{\"1\":{\"232\":1}}],[\"的地址\",{\"1\":{\"230\":1}}],[\"的子类\",{\"1\":{\"227\":1}}],[\"的方法内联\",{\"1\":{\"253\":1}}],[\"的方法呢\",{\"1\":{\"226\":1}}],[\"的方式释放内存\",{\"1\":{\"133\":1}}],[\"的方式\",{\"1\":{\"59\":1}}],[\"的动作\",{\"1\":{\"219\":1}}],[\"的无参构造方法\",{\"1\":{\"217\":1}}],[\"的反编译功能\",{\"1\":{\"216\":1}}],[\"的为准\",{\"1\":{\"213\":1}}],[\"的情况\",{\"0\":{\"211\":1}}],[\"的情况是通过\",{\"1\":{\"198\":1}}],[\"的检测范围\",{\"1\":{\"209\":1}}],[\"的结构\",{\"1\":{\"209\":1}}],[\"的起始地址\",{\"1\":{\"205\":1}}],[\"的起始地址开始算\",{\"1\":{\"205\":1}}],[\"的字节码\",{\"1\":{\"195\":1}}],[\"的比较\",{\"1\":{\"194\":1}}],[\"的区别是先执行\",{\"1\":{\"193\":1}}],[\"的老年代内存越大越好\",{\"1\":{\"177\":1}}],[\"的数据为宜\",{\"1\":{\"176\":1}}],[\"的过程\",{\"1\":{\"161\":1}}],[\"的自适应调节策略\",{\"1\":{\"160\":1}}],[\"的环境来说\",{\"1\":{\"159\":1}}],[\"的实现类内部\",{\"1\":{\"132\":1}}],[\"的次数\",{\"1\":{\"127\":1}}],[\"的主要区别在于\",{\"1\":{\"98\":1}}],[\"的主要特点包括\",{\"0\":{\"95\":1}}],[\"的时刻调用\",{\"1\":{\"98\":1}}],[\"的一个简单例子\",{\"0\":{\"96\":1}}],[\"的最终状态\",{\"1\":{\"87\":1}}],[\"的四种锁状态\",{\"0\":{\"87\":1}}],[\"的值缓存至自己工作内存中的高速缓存中\",{\"1\":{\"260\":1}}],[\"的值\",{\"1\":{\"260\":2}}],[\"的值到工作内存\",{\"1\":{\"260\":1}}],[\"的值赋值给了\",{\"1\":{\"228\":1}}],[\"的值更新为新值b\",{\"1\":{\"91\":1}}],[\"的值相同时\",{\"1\":{\"91\":1}}],[\"的值恢复给对象头\",{\"1\":{\"83\":1,\"84\":1}}],[\"的值存入锁记录\",{\"1\":{\"83\":1}}],[\"的锁记录\",{\"1\":{\"83\":1}}],[\"的轻量级锁\",{\"1\":{\"83\":1}}],[\"的对象\",{\"0\":{\"138\":1}}],[\"的对象仍有机会重新偏向\",{\"1\":{\"81\":1}}],[\"的对象不会关联监视器\",{\"1\":{\"71\":1}}],[\"的所有者\",{\"1\":{\"71\":1}}],[\"的\",{\"0\":{\"65\":1},\"1\":{\"26\":1,\"27\":1,\"61\":1,\"81\":1,\"83\":1,\"84\":1,\"132\":1,\"160\":2,\"205\":1,\"216\":1,\"223\":2,\"224\":2,\"228\":1,\"230\":1,\"233\":1,\"254\":1,\"280\":1,\"281\":1}}],[\"hsdb\",{\"0\":{\"201\":1},\"1\":{\"201\":1,\"230\":1}}],[\"http\",{\"1\":{\"253\":1}}],[\"https\",{\"1\":{\"194\":1,\"263\":3,\"276\":3}}],[\"html\",{\"1\":{\"194\":2,\"276\":2}}],[\"hot\",{\"1\":{\"243\":2}}],[\"hotspot名称的由\",{\"1\":{\"251\":1}}],[\"hotspot\",{\"1\":{\"119\":1,\"201\":1}}],[\"home\",{\"1\":{\"239\":2,\"241\":2,\"242\":1,\"245\":2}}],[\"hope\",{\"1\":{\"27\":1,\"281\":1}}],[\"hellowworld\",{\"1\":{\"179\":1}}],[\"helloworld\",{\"1\":{\"123\":3,\"179\":5,\"182\":3,\"232\":1}}],[\"hello\",{\"1\":{\"115\":1,\"169\":2,\"179\":1,\"182\":1,\"188\":3,\"221\":1,\"223\":5,\"238\":1}}],[\"heap\",{\"1\":{\"115\":3,\"116\":1}}],[\"head\",{\"1\":{\"94\":2}}],[\"heavyweight\",{\"1\":{\"77\":2}}],[\"h\",{\"1\":{\"110\":1,\"169\":2,\"223\":4}}],[\"happen\",{\"1\":{\"248\":1}}],[\"happens\",{\"1\":{\"65\":1}}],[\"hasnextservice\",{\"1\":{\"248\":1}}],[\"hasnext\",{\"1\":{\"222\":1,\"246\":1,\"247\":1}}],[\"hash函数的数量\",{\"1\":{\"273\":1}}],[\"hashtable结构\",{\"1\":{\"123\":1}}],[\"hashcode\",{\"0\":{\"78\":1},\"1\":{\"77\":1,\"78\":5,\"206\":2,\"223\":13}}],[\"handler\",{\"1\":{\"144\":1}}],[\"h1\",{\"1\":{\"26\":2,\"280\":2}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"fpp\",{\"1\":{\"274\":2}}],[\"f2\",{\"1\":{\"273\":4}}],[\"f1\",{\"1\":{\"273\":3}}],[\"folding\",{\"1\":{\"252\":1}}],[\"found\",{\"1\":{\"242\":1,\"248\":1,\"326\":1}}],[\"foo\",{\"1\":{\"221\":6,\"254\":6}}],[\"forname的参数2为false时\",{\"1\":{\"237\":1}}],[\"forname\",{\"1\":{\"237\":3,\"240\":1,\"245\":1,\"246\":2,\"248\":2}}],[\"foreach\",{\"0\":{\"222\":1},\"1\":{\"222\":3}}],[\"format=b\",{\"1\":{\"139\":2}}],[\"forks\",{\"1\":{\"253\":1}}],[\"fork\",{\"1\":{\"85\":1}}],[\"for\",{\"1\":{\"77\":1,\"81\":2,\"82\":3,\"120\":1,\"127\":1,\"146\":5,\"147\":5,\"195\":3,\"220\":2,\"222\":3,\"227\":1,\"246\":1,\"251\":2,\"252\":2,\"253\":5,\"254\":1,\"256\":2,\"258\":2,\"274\":2}}],[\"flag\",{\"1\":{\"182\":1}}],[\"flags\",{\"1\":{\"179\":1,\"188\":3,\"193\":1,\"210\":1,\"211\":1,\"220\":2}}],[\"float\",{\"1\":{\"182\":1,\"194\":1}}],[\"female\",{\"1\":{\"224\":6,\"225\":5}}],[\"fe\",{\"1\":{\"179\":1,\"180\":2,\"181\":2,\"182\":3}}],[\"f\",{\"1\":{\"121\":3,\"125\":1,\"240\":4}}],[\"fail\",{\"1\":{\"248\":3}}],[\"failed\",{\"1\":{\"246\":1}}],[\"fairness\",{\"1\":{\"95\":1}}],[\"false\",{\"1\":{\"68\":2,\"123\":2,\"125\":2,\"237\":2,\"242\":1,\"248\":1,\"260\":1,\"262\":1,\"263\":2}}],[\"funnels\",{\"1\":{\"274\":1}}],[\"fullgc\",{\"1\":{\"171\":1}}],[\"full\",{\"1\":{\"71\":1,\"133\":1,\"146\":1,\"153\":1,\"155\":1,\"166\":2,\"175\":1,\"176\":2,\"177\":2,\"178\":3}}],[\"future\",{\"1\":{\"59\":1}}],[\"fianlly\",{\"1\":{\"226\":1}}],[\"fileinputstream\",{\"1\":{\"226\":2}}],[\"file\",{\"1\":{\"139\":1}}],[\"file=1\",{\"1\":{\"139\":1}}],[\"fieldref\",{\"1\":{\"182\":2,\"188\":1}}],[\"fields\",{\"1\":{\"179\":3}}],[\"field\",{\"1\":{\"133\":4,\"179\":1,\"182\":1,\"188\":1,\"193\":2,\"196\":1,\"197\":3,\"215\":1,\"253\":1}}],[\"findclass\",{\"1\":{\"242\":2}}],[\"findbootstrapclassornull\",{\"1\":{\"242\":1}}],[\"findloadedclass\",{\"1\":{\"242\":1}}],[\"find\",{\"1\":{\"202\":1}}],[\"findstr\",{\"1\":{\"172\":1}}],[\"finished\",{\"1\":{\"120\":1}}],[\"finalize\",{\"1\":{\"145\":1,\"206\":2}}],[\"finalizer\",{\"1\":{\"145\":1}}],[\"finally不带return\",{\"0\":{\"214\":1}}],[\"finally中的return\",{\"0\":{\"213\":1}}],[\"finally\",{\"0\":{\"212\":1},\"1\":{\"120\":1,\"127\":1,\"132\":1,\"212\":2,\"213\":7,\"214\":1,\"226\":2}}],[\"final\",{\"1\":{\"59\":1,\"71\":1,\"76\":1,\"132\":1,\"146\":1,\"155\":5,\"156\":5,\"157\":5,\"182\":2,\"198\":1,\"205\":1,\"225\":4,\"228\":6,\"237\":1,\"238\":4,\"245\":1,\"252\":2,\"254\":1}}],[\"first\",{\"0\":{\"162\":1},\"1\":{\"26\":1,\"280\":1}}],[\"freememory\",{\"1\":{\"132\":3,\"133\":2}}],[\"freememory来手动释放\",{\"1\":{\"132\":1}}],[\"frame\",{\"1\":{\"71\":3,\"108\":1}}],[\"frac\",{\"1\":{\"18\":4}}],[\"from=pagedriver\",{\"1\":{\"263\":1}}],[\"from和to\",{\"1\":{\"151\":1}}],[\"from\",{\"1\":{\"71\":1,\"153\":2,\"175\":1,\"182\":1,\"188\":1,\"202\":1,\"209\":2,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"242\":1}}],[\"frontmatter\",{\"1\":{\"3\":1,\"6\":1,\"11\":4,\"26\":1,\"27\":1,\"56\":1,\"280\":1,\"281\":1}}],[\"上例从字节码理解是这样的\",{\"1\":{\"263\":1}}],[\"上级为application\",{\"1\":{\"239\":1}}],[\"上级为extension\",{\"1\":{\"239\":1}}],[\"上级为bootstrap\",{\"1\":{\"239\":1}}],[\"上进行运算\",{\"1\":{\"193\":1}}],[\"上面的代码中\",{\"1\":{\"146\":1,\"275\":1}}],[\"上锁的过程中\",{\"1\":{\"71\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"上一篇\",{\"1\":{\"3\":1,\"56\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"20\":1}}],[\"2层\",{\"1\":{\"251\":1}}],[\"2面世以前的\",{\"1\":{\"243\":1}}],[\"2项\",{\"1\":{\"182\":1}}],[\"2a\",{\"1\":{\"179\":1}}],[\"2e\",{\"1\":{\"179\":1,\"182\":4}}],[\"2f\",{\"1\":{\"179\":23,\"182\":31}}],[\"2特点\",{\"0\":{\"114\":1}}],[\"296141\",{\"1\":{\"253\":1}}],[\"29453f44\",{\"1\":{\"241\":1}}],[\"29项\",{\"1\":{\"182\":1}}],[\"29\",{\"1\":{\"81\":4,\"106\":1,\"123\":2,\"179\":3,\"182\":11,\"183\":4,\"193\":1,\"197\":1,\"215\":1}}],[\"28项\",{\"1\":{\"182\":1}}],[\"28\",{\"1\":{\"81\":4,\"179\":3,\"182\":9,\"188\":2,\"193\":1,\"196\":1,\"197\":1,\"215\":2}}],[\"27项\",{\"1\":{\"182\":1}}],[\"27\",{\"1\":{\"81\":4,\"123\":2,\"182\":3,\"188\":2,\"210\":1,\"211\":1,\"212\":3,\"215\":1,\"219\":1,\"220\":1}}],[\"26项\",{\"1\":{\"182\":1}}],[\"26\",{\"1\":{\"81\":4,\"106\":6,\"120\":1,\"182\":2,\"188\":2,\"210\":4,\"211\":2,\"212\":1,\"215\":1}}],[\"2544313\",{\"1\":{\"253\":1}}],[\"25项\",{\"1\":{\"182\":1}}],[\"250\",{\"1\":{\"71\":1}}],[\"255\",{\"1\":{\"71\":1}}],[\"25\",{\"1\":{\"71\":1,\"77\":1,\"81\":4,\"106\":1,\"182\":2,\"188\":2,\"193\":2,\"196\":1,\"197\":1,\"210\":2,\"211\":4,\"212\":1,\"215\":4}}],[\"23项\",{\"1\":{\"182\":1}}],[\"23\",{\"1\":{\"71\":1,\"81\":4,\"179\":1,\"180\":1,\"181\":2,\"182\":7,\"188\":2,\"197\":1,\"198\":1,\"210\":2}}],[\"220\",{\"1\":{\"253\":1}}],[\"22项\",{\"1\":{\"182\":1}}],[\"22\",{\"1\":{\"71\":2,\"81\":4,\"115\":1,\"179\":1,\"182\":8,\"188\":2,\"193\":1,\"197\":1,\"210\":2,\"211\":4,\"212\":1,\"215\":2,\"219\":1,\"220\":1,\"233\":2}}],[\"2104d11ee0a2\",{\"1\":{\"276\":1}}],[\"2123\",{\"1\":{\"223\":2}}],[\"21项\",{\"1\":{\"182\":1}}],[\"21\",{\"1\":{\"71\":1,\"81\":4,\"106\":1,\"123\":2,\"179\":2,\"182\":10,\"183\":5,\"188\":2,\"193\":1,\"196\":3,\"211\":1,\"212\":3,\"215\":1,\"219\":1,\"220\":1}}],[\"2014\",{\"1\":{\"263\":1}}],[\"20项\",{\"1\":{\"182\":1}}],[\"200万的数据进行测试\",{\"1\":{\"275\":1}}],[\"200\",{\"1\":{\"162\":1,\"251\":1}}],[\"200ms\",{\"1\":{\"160\":1}}],[\"2000000\",{\"1\":{\"274\":1}}],[\"2000\",{\"1\":{\"98\":1}}],[\"20m\",{\"1\":{\"146\":1}}],[\"20240715222432570\",{\"1\":{\"260\":1}}],[\"20240715222337696\",{\"1\":{\"260\":1}}],[\"20240715222147607\",{\"1\":{\"260\":1}}],[\"20240715213034845\",{\"1\":{\"256\":1}}],[\"20240715200831758\",{\"1\":{\"246\":1}}],[\"20240715233123923\",{\"1\":{\"92\":1}}],[\"2021\",{\"1\":{\"188\":1}}],[\"2020\",{\"1\":{\"27\":1,\"281\":1}}],[\"20\",{\"1\":{\"71\":1,\"81\":5,\"106\":2,\"123\":2,\"179\":2,\"182\":6,\"188\":2,\"194\":2,\"197\":5,\"198\":1,\"209\":2,\"212\":2,\"213\":6,\"214\":4,\"215\":1,\"219\":1,\"220\":3,\"238\":1,\"254\":1}}],[\"2469176\",{\"1\":{\"253\":1}}],[\"2420286\",{\"1\":{\"253\":1}}],[\"24项\",{\"1\":{\"182\":1}}],[\"24\",{\"1\":{\"71\":3,\"81\":4,\"106\":1,\"123\":2,\"175\":1,\"182\":2,\"188\":2,\"196\":1,\"212\":1,\"220\":2}}],[\"2\",{\"0\":{\"35\":1,\"40\":1,\"45\":1,\"50\":1,\"107\":1,\"108\":1,\"109\":2,\"110\":1,\"119\":1,\"131\":1,\"137\":1,\"148\":1,\"149\":1,\"150\":2,\"151\":1,\"154\":1,\"160\":1,\"174\":1,\"181\":1,\"184\":1,\"185\":1,\"186\":2,\"188\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"201\":1,\"208\":1,\"210\":1,\"215\":1,\"218\":1,\"231\":1,\"233\":1,\"237\":1,\"241\":1,\"252\":1,\"254\":1,\"257\":1,\"259\":1,\"260\":1,\"261\":2,\"263\":1,\"287\":1,\"291\":1,\"292\":1,\"297\":1,\"302\":1,\"307\":1,\"311\":1,\"312\":1,\"317\":1,\"322\":1},\"1\":{\"19\":1,\"67\":1,\"71\":10,\"72\":1,\"77\":1,\"81\":4,\"94\":1,\"97\":1,\"98\":2,\"106\":2,\"108\":4,\"123\":15,\"125\":1,\"132\":1,\"139\":1,\"188\":2,\"192\":3,\"193\":7,\"194\":1,\"195\":6,\"196\":13,\"197\":4,\"198\":1,\"204\":3,\"209\":4,\"210\":13,\"211\":2,\"212\":4,\"213\":2,\"214\":3,\"215\":5,\"219\":4,\"220\":5,\"222\":5,\"224\":3,\"227\":2,\"237\":2,\"241\":1,\"246\":2,\"253\":1,\"273\":1}}],[\"rinack\",{\"1\":{\"276\":1}}],[\"right\",{\"1\":{\"18\":3}}],[\"randomints\",{\"1\":{\"253\":2}}],[\"random\",{\"1\":{\"253\":4}}],[\"root引用的对象\",{\"1\":{\"151\":1}}],[\"root引用的对象从from放入to中\",{\"1\":{\"151\":1}}],[\"roots\",{\"1\":{\"141\":1,\"161\":2}}],[\"root\",{\"1\":{\"139\":1,\"164\":1}}],[\"round\",{\"1\":{\"132\":1}}],[\"runnerexception\",{\"1\":{\"253\":2}}],[\"runner\",{\"1\":{\"253\":6}}],[\"runnable\",{\"1\":{\"228\":13}}],[\"running\",{\"1\":{\"68\":5,\"101\":2,\"228\":2}}],[\"run方法\",{\"1\":{\"132\":1}}],[\"run\",{\"1\":{\"132\":3,\"228\":4,\"246\":2,\"253\":1,\"260\":9,\"262\":4,\"263\":12}}],[\"redis缓存穿透\",{\"0\":{\"268\":1}}],[\"redis\",{\"0\":{\"266\":1},\"1\":{\"175\":1},\"2\":{\"267\":1,\"277\":1}}],[\"resolveclass\",{\"1\":{\"242\":1}}],[\"resolve\",{\"1\":{\"242\":2}}],[\"resource\",{\"1\":{\"226\":1}}],[\"resources\",{\"0\":{\"226\":1},\"1\":{\"226\":3}}],[\"result\",{\"1\":{\"213\":4}}],[\"resultset\",{\"1\":{\"175\":1,\"226\":1}}],[\"reservememory\",{\"1\":{\"132\":2}}],[\"remembered\",{\"1\":{\"167\":3}}],[\"remark\",{\"1\":{\"165\":1}}],[\"remove\",{\"1\":{\"132\":1,\"146\":1,\"147\":1}}],[\"reflectionfactory\",{\"1\":{\"254\":1}}],[\"reflectiveoperationexception\",{\"1\":{\"211\":1}}],[\"reflectutil\",{\"1\":{\"254\":2}}],[\"reflect1\",{\"1\":{\"254\":1}}],[\"reflecttest\",{\"1\":{\"220\":1}}],[\"reflect\",{\"1\":{\"211\":2,\"254\":3}}],[\"refinement\",{\"1\":{\"167\":1}}],[\"ref\",{\"1\":{\"146\":10}}],[\"ref=\",{\"1\":{\"146\":1}}],[\"reference<\",{\"1\":{\"146\":1,\"147\":1}}],[\"referencequeue<>\",{\"1\":{\"146\":1,\"147\":1}}],[\"referencequeue<byte\",{\"1\":{\"146\":1,\"147\":1}}],[\"referencehandler\",{\"1\":{\"132\":1}}],[\"reference\",{\"1\":{\"83\":1,\"144\":1}}],[\"region\",{\"1\":{\"162\":1}}],[\"registereddrivers\",{\"1\":{\"245\":1}}],[\"register\",{\"1\":{\"106\":1}}],[\"regarded\",{\"1\":{\"26\":1,\"280\":1}}],[\"release\",{\"1\":{\"95\":1,\"96\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"90\":1}}],[\"reentrantlock\",{\"0\":{\"88\":1},\"1\":{\"59\":2}}],[\"read\",{\"1\":{\"79\":1,\"133\":6,\"139\":2,\"146\":1,\"199\":1,\"200\":1,\"233\":1,\"234\":1}}],[\"record\",{\"1\":{\"77\":1,\"83\":2}}],[\"return\",{\"1\":{\"71\":1,\"106\":1,\"108\":2,\"123\":3,\"132\":3,\"188\":2,\"192\":1,\"193\":1,\"194\":1,\"195\":3,\"196\":1,\"197\":2,\"198\":1,\"199\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":5,\"214\":1,\"215\":1,\"219\":1,\"220\":3,\"225\":2,\"227\":4,\"238\":1,\"242\":1,\"246\":3,\"248\":2,\"252\":2,\"253\":1,\"254\":1}}],[\"r\",{\"1\":{\"18\":3}}],[\"^\",{\"1\":{\"18\":1}}],[\"^i\",{\"1\":{\"18\":1}}],[\"^r\",{\"1\":{\"18\":2}}],[\"1层\",{\"1\":{\"251\":1}}],[\"1项\",{\"1\":{\"182\":1}}],[\"1~\",{\"1\":{\"182\":1}}],[\"1f\",{\"1\":{\"179\":1,\"182\":3}}],[\"1e\",{\"1\":{\"179\":1,\"182\":5}}],[\"1d\",{\"1\":{\"179\":2,\"182\":8}}],[\"1c\",{\"1\":{\"179\":1,\"182\":4}}],[\"1b8\",{\"1\":{\"205\":1}}],[\"1b\",{\"1\":{\"179\":2,\"182\":10}}],[\"1a\",{\"1\":{\"179\":1,\"182\":6}}],[\"1+radio\",{\"1\":{\"160\":1}}],[\"1并且交换\",{\"1\":{\"153\":1}}],[\"1gb\",{\"1\":{\"133\":5}}],[\"1l\",{\"1\":{\"132\":1}}],[\"1mb\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"1m\",{\"1\":{\"132\":1}}],[\"1定义\",{\"0\":{\"106\":1}}],[\"18b4aac2\",{\"1\":{\"241\":1}}],[\"18项\",{\"1\":{\"182\":1}}],[\"18\",{\"1\":{\"81\":4,\"179\":1,\"182\":8,\"188\":2,\"193\":3,\"196\":1,\"210\":1,\"211\":1,\"212\":1,\"226\":1}}],[\"17项\",{\"1\":{\"182\":1}}],[\"17表示它引用了常量池中\",{\"1\":{\"182\":1}}],[\"17\",{\"1\":{\"81\":4,\"123\":2,\"179\":1,\"182\":6,\"188\":2,\"193\":1,\"197\":1,\"198\":1,\"212\":1,\"215\":1}}],[\"13项\",{\"1\":{\"182\":1}}],[\"136\",{\"1\":{\"115\":1,\"253\":1}}],[\"13\",{\"1\":{\"81\":4,\"123\":2,\"179\":3,\"182\":7,\"188\":2,\"193\":1,\"197\":1,\"198\":1,\"211\":1,\"213\":1,\"214\":1}}],[\"120824295\",{\"1\":{\"263\":1}}],[\"12项\",{\"1\":{\"182\":1}}],[\"123\",{\"1\":{\"132\":1}}],[\"124\",{\"1\":{\"115\":1}}],[\"12\",{\"0\":{\"228\":1},\"1\":{\"81\":4,\"123\":2,\"179\":3,\"182\":4,\"188\":1,\"193\":2,\"194\":2,\"197\":2,\"198\":1,\"209\":2,\"210\":1,\"211\":2,\"212\":1,\"215\":2}}],[\"1999942误判了\",{\"1\":{\"275\":1}}],[\"1999827误判了\",{\"1\":{\"275\":1}}],[\"1999697误判了\",{\"1\":{\"275\":1}}],[\"1999640误判了\",{\"1\":{\"275\":1}}],[\"1999567误判了\",{\"1\":{\"275\":1}}],[\"1999501误判了\",{\"1\":{\"275\":1}}],[\"1999\",{\"1\":{\"253\":1}}],[\"19项\",{\"1\":{\"182\":1}}],[\"19\",{\"1\":{\"71\":5,\"81\":4,\"106\":1,\"132\":1,\"179\":1,\"182\":8,\"188\":2,\"197\":1,\"210\":1,\"215\":1,\"219\":1,\"220\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"16项\",{\"1\":{\"182\":1}}],[\"16进制\",{\"1\":{\"181\":1}}],[\"16104\",{\"1\":{\"139\":2}}],[\"16\",{\"1\":{\"71\":2,\"81\":4,\"85\":1,\"106\":1,\"123\":2,\"175\":1,\"179\":2,\"182\":15,\"188\":3,\"193\":1,\"197\":1,\"198\":1,\"203\":1,\"204\":1,\"210\":2,\"254\":1}}],[\"15项\",{\"1\":{\"182\":1}}],[\"15引用了常量池中\",{\"1\":{\"182\":1}}],[\"15\",{\"1\":{\"71\":1,\"81\":4,\"106\":1,\"179\":3,\"180\":1,\"181\":2,\"182\":14,\"188\":3,\"193\":1,\"194\":2,\"196\":1,\"197\":1,\"210\":2,\"211\":1,\"212\":2,\"213\":1,\"214\":1,\"215\":1,\"254\":2}}],[\"14项\",{\"1\":{\"182\":1}}],[\"14\",{\"1\":{\"71\":2,\"81\":4,\"106\":1,\"115\":1,\"179\":1,\"188\":2,\"194\":1,\"195\":4,\"196\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"219\":1,\"220\":1}}],[\"113742011\",{\"1\":{\"263\":1}}],[\"11331880\",{\"1\":{\"223\":1}}],[\"11项\",{\"1\":{\"182\":1}}],[\"11100000\",{\"1\":{\"81\":60}}],[\"11110111\",{\"1\":{\"81\":19}}],[\"11110001\",{\"1\":{\"81\":22}}],[\"11110000\",{\"1\":{\"79\":1}}],[\"11110011\",{\"1\":{\"81\":82}}],[\"11111000\",{\"1\":{\"80\":1}}],[\"11001010\",{\"1\":{\"80\":1}}],[\"11010100\",{\"1\":{\"80\":1}}],[\"11\",{\"0\":{\"215\":1,\"227\":1},\"1\":{\"71\":2,\"77\":1,\"81\":4,\"106\":1,\"179\":1,\"182\":1,\"188\":1,\"193\":2,\"195\":3,\"196\":2,\"197\":1,\"209\":1,\"210\":2,\"211\":4,\"212\":3,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"220\":2}}],[\"10911177\",{\"1\":{\"276\":1}}],[\"10314\",{\"1\":{\"275\":2}}],[\"10项\",{\"1\":{\"182\":1}}],[\"10进制\",{\"1\":{\"181\":1}}],[\"1024\",{\"1\":{\"132\":2,\"133\":3,\"146\":4,\"147\":2,\"155\":9,\"156\":9,\"157\":9}}],[\"100万\",{\"1\":{\"275\":1}}],[\"100万条数据\",{\"1\":{\"275\":1}}],[\"100mb\",{\"1\":{\"132\":2}}],[\"1009\",{\"1\":{\"128\":1}}],[\"100\",{\"1\":{\"127\":1,\"132\":1}}],[\"1000l\",{\"1\":{\"157\":1}}],[\"1000000\",{\"1\":{\"274\":3,\"275\":1}}],[\"10000\",{\"1\":{\"120\":1,\"127\":2}}],[\"1000\",{\"1\":{\"101\":1,\"251\":1,\"252\":1,\"253\":1,\"260\":1,\"262\":1}}],[\"108\",{\"1\":{\"85\":1}}],[\"10110011\",{\"1\":{\"80\":1}}],[\"10110101\",{\"1\":{\"79\":1}}],[\"10\",{\"0\":{\"208\":1,\"226\":1},\"1\":{\"71\":2,\"77\":1,\"81\":4,\"106\":1,\"147\":1,\"155\":1,\"179\":5,\"182\":11,\"187\":1,\"188\":2,\"192\":1,\"193\":4,\"194\":2,\"195\":6,\"196\":4,\"197\":7,\"199\":1,\"209\":2,\"210\":2,\"211\":1,\"212\":2,\"213\":5,\"214\":6,\"215\":1,\"219\":2,\"220\":2,\"238\":1,\"311\":1}}],[\"1public\",{\"1\":{\"67\":1}}],[\"1\",{\"0\":{\"105\":1,\"106\":1,\"108\":1,\"113\":1,\"118\":1,\"130\":1,\"134\":1,\"135\":2,\"137\":1,\"140\":1,\"149\":1,\"153\":1,\"159\":1,\"173\":1,\"179\":1,\"180\":2,\"181\":1,\"182\":1,\"183\":1,\"185\":1,\"187\":1,\"200\":1,\"209\":1,\"217\":1,\"230\":1,\"232\":1,\"236\":1,\"240\":1,\"250\":1,\"251\":1,\"255\":1,\"256\":2,\"257\":1,\"258\":1,\"260\":1,\"262\":1,\"286\":1,\"306\":1},\"1\":{\"18\":1,\"19\":1,\"27\":2,\"29\":2,\"67\":1,\"71\":7,\"72\":1,\"77\":3,\"81\":4,\"84\":2,\"85\":5,\"94\":1,\"95\":1,\"96\":1,\"97\":2,\"106\":8,\"108\":4,\"119\":2,\"120\":5,\"123\":8,\"125\":2,\"132\":3,\"139\":3,\"160\":1,\"177\":2,\"179\":1,\"182\":1,\"187\":2,\"188\":3,\"192\":4,\"193\":12,\"194\":5,\"195\":15,\"196\":12,\"197\":4,\"198\":5,\"204\":1,\"209\":4,\"210\":7,\"211\":6,\"212\":7,\"213\":2,\"214\":2,\"215\":4,\"218\":3,\"219\":3,\"220\":9,\"222\":7,\"223\":9,\"224\":3,\"225\":1,\"226\":3,\"227\":1,\"230\":3,\"237\":2,\"240\":1,\"245\":1,\"246\":2,\"253\":4,\"256\":12,\"260\":1,\"263\":4,\"281\":2,\"283\":2}}],[\"i<=16\",{\"1\":{\"254\":1}}],[\"ireturn\",{\"1\":{\"213\":4,\"214\":1}}],[\"icmplt\",{\"1\":{\"195\":1}}],[\"icmpge\",{\"1\":{\"195\":2,\"196\":1}}],[\"iconst\",{\"1\":{\"71\":1,\"106\":5,\"194\":1,\"195\":3,\"196\":2,\"209\":1,\"210\":1,\"211\":2,\"212\":1,\"219\":1,\"220\":1,\"256\":8,\"263\":2}}],[\"iinc\",{\"1\":{\"193\":5,\"195\":3,\"196\":2}}],[\"illegalargumentexception\",{\"1\":{\"254\":1}}],[\"illegalaccessexception\",{\"1\":{\"133\":2,\"211\":2,\"254\":1}}],[\"iload\",{\"1\":{\"192\":1,\"193\":6,\"194\":1,\"195\":3,\"196\":3,\"197\":1,\"213\":3,\"214\":2}}],[\"iload2\",{\"1\":{\"192\":1}}],[\"iload1\",{\"1\":{\"192\":1}}],[\"io\",{\"1\":{\"173\":1,\"182\":2,\"188\":8,\"192\":1,\"193\":4,\"196\":2,\"199\":1,\"215\":2}}],[\"ioexception\",{\"1\":{\"79\":1,\"132\":1,\"133\":4,\"139\":1,\"146\":4,\"199\":2,\"226\":2,\"233\":1,\"234\":1}}],[\"iflt\",{\"1\":{\"194\":1}}],[\"ifne\",{\"1\":{\"194\":2}}],[\"ifeq\",{\"1\":{\"194\":1}}],[\"if\",{\"1\":{\"132\":4,\"194\":1,\"195\":3,\"196\":1,\"220\":1,\"223\":4,\"226\":2,\"242\":5,\"246\":1,\"248\":2,\"254\":1,\"274\":1}}],[\"isub\",{\"1\":{\"256\":4,\"263\":1}}],[\"isvmanonymousclass\",{\"1\":{\"254\":1}}],[\"isassignablefrom\",{\"1\":{\"248\":1}}],[\"isalive\",{\"1\":{\"61\":1}}],[\"istore\",{\"1\":{\"192\":3,\"193\":2,\"194\":3,\"195\":3,\"196\":3,\"209\":3,\"210\":5,\"212\":6,\"213\":4,\"214\":4}}],[\"isdirectmemorypagealigned\",{\"1\":{\"132\":1}}],[\"is\",{\"1\":{\"101\":2,\"182\":1,\"226\":7}}],[\"implements\",{\"1\":{\"226\":1,\"228\":2}}],[\"import\",{\"1\":{\"199\":1,\"253\":7,\"254\":2}}],[\"image\",{\"1\":{\"92\":1,\"246\":1,\"256\":1,\"260\":3}}],[\"img\",{\"1\":{\"59\":1,\"60\":1,\"65\":1,\"71\":1,\"73\":2,\"83\":3,\"84\":2,\"94\":4,\"104\":1,\"107\":1,\"108\":1,\"109\":2,\"119\":1,\"121\":4,\"126\":1,\"131\":2,\"136\":1,\"139\":3,\"140\":1,\"146\":3,\"149\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":6,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":3,\"164\":1,\"165\":1,\"167\":2,\"168\":5,\"171\":1,\"176\":1,\"178\":1,\"184\":2,\"189\":1,\"190\":1,\"191\":1,\"192\":16,\"193\":11,\"196\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"206\":1,\"230\":1,\"273\":3}}],[\"idea\",{\"1\":{\"216\":2}}],[\"ideaprojects\",{\"1\":{\"188\":2}}],[\"id\",{\"1\":{\"76\":2,\"78\":1,\"79\":1,\"81\":1,\"200\":1,\"201\":1,\"263\":1}}],[\"iadd\",{\"1\":{\"71\":1,\"192\":1,\"193\":2,\"256\":4,\"263\":1}}],[\"i++\",{\"0\":{\"193\":1},\"1\":{\"67\":1,\"81\":2,\"82\":3,\"115\":1,\"120\":1,\"127\":1,\"132\":1,\"146\":3,\"147\":2,\"195\":1,\"196\":1,\"220\":1,\"251\":1,\"252\":1,\"253\":4,\"254\":1,\"256\":2,\"258\":1,\"263\":1,\"274\":2}}],[\"i+1\",{\"1\":{\"18\":1}}],[\"include\",{\"1\":{\"253\":1}}],[\"increment\",{\"1\":{\"67\":1,\"242\":1}}],[\"inline\",{\"1\":{\"253\":2}}],[\"inlining\",{\"1\":{\"252\":2}}],[\"inflationthreshold\",{\"1\":{\"254\":2}}],[\"inf\",{\"1\":{\"246\":1}}],[\"info\",{\"1\":{\"179\":4}}],[\"inputstream\",{\"1\":{\"226\":3}}],[\"index\",{\"1\":{\"219\":1}}],[\"invocationtargetexception\",{\"1\":{\"211\":2,\"254\":2}}],[\"invoke0\",{\"1\":{\"254\":2}}],[\"invokeinterface\",{\"1\":{\"219\":2,\"220\":2}}],[\"invoke\",{\"1\":{\"211\":1,\"254\":4}}],[\"invokestatic\",{\"1\":{\"198\":1,\"219\":1,\"220\":1}}],[\"invokespecial\",{\"1\":{\"123\":2,\"182\":1,\"188\":1,\"197\":1,\"198\":6,\"215\":1,\"219\":1,\"220\":2}}],[\"invoked\",{\"1\":{\"182\":1}}],[\"invokedynamic\",{\"1\":{\"182\":1}}],[\"invokevirtual\",{\"1\":{\"106\":5,\"123\":6,\"188\":1,\"192\":1,\"193\":2,\"196\":1,\"198\":2,\"207\":1,\"211\":3,\"215\":1}}],[\"inspector\",{\"1\":{\"205\":1}}],[\"instance\",{\"1\":{\"238\":2}}],[\"instanceklass和\",{\"1\":{\"230\":1}}],[\"instanceklass\",{\"1\":{\"230\":3}}],[\"instanceof\",{\"1\":{\"220\":1}}],[\"instantiated\",{\"1\":{\"182\":1,\"248\":1}}],[\"instruction\",{\"1\":{\"182\":1}}],[\"init\",{\"1\":{\"197\":1,\"237\":3,\"240\":2,\"241\":4}}],[\"initialize\",{\"1\":{\"246\":3}}],[\"initialized\",{\"1\":{\"245\":1}}],[\"initialsurvivorratio=ratio\",{\"1\":{\"155\":1}}],[\"initiatingheapoccupancypercent\",{\"1\":{\"171\":2}}],[\"initiatingheapoccupancypercent=percent\",{\"1\":{\"164\":1}}],[\"ing\",{\"1\":{\"123\":2}}],[\"intvalue\",{\"1\":{\"218\":2,\"219\":2}}],[\"integerfunnel\",{\"1\":{\"274\":1}}],[\"integer\",{\"1\":{\"175\":1,\"182\":1,\"218\":5,\"219\":12,\"220\":5,\"222\":2,\"227\":6,\"238\":2}}],[\"interpreter\",{\"1\":{\"251\":1}}],[\"interpretation\",{\"1\":{\"182\":1}}],[\"interfacemethod\",{\"1\":{\"219\":2,\"220\":2}}],[\"interfacemethodref\",{\"1\":{\"182\":1}}],[\"interface\",{\"1\":{\"182\":2,\"220\":2,\"246\":1}}],[\"interfaces\",{\"1\":{\"179\":3}}],[\"intern关注的是字符串对象\",{\"1\":{\"169\":1}}],[\"intern的区别\",{\"1\":{\"169\":1}}],[\"intern\",{\"1\":{\"123\":1,\"125\":3,\"127\":1,\"128\":1}}],[\"intern方法\",{\"1\":{\"123\":1,\"125\":1}}],[\"interruptedexception\",{\"1\":{\"79\":2,\"80\":3,\"81\":2,\"82\":1,\"97\":1,\"98\":3,\"101\":1,\"156\":1,\"157\":1,\"256\":1,\"258\":1,\"260\":1,\"262\":1}}],[\"int\",{\"1\":{\"67\":1,\"71\":1,\"81\":2,\"82\":4,\"85\":1,\"108\":4,\"115\":1,\"120\":2,\"127\":2,\"132\":5,\"133\":1,\"146\":5,\"147\":3,\"155\":5,\"156\":5,\"157\":5,\"175\":1,\"187\":3,\"192\":1,\"193\":2,\"194\":2,\"195\":3,\"196\":2,\"197\":3,\"206\":1,\"209\":1,\"210\":1,\"212\":1,\"213\":5,\"214\":3,\"218\":3,\"219\":5,\"220\":1,\"222\":6,\"223\":1,\"224\":3,\"225\":1,\"226\":1,\"228\":4,\"237\":1,\"238\":1,\"251\":2,\"252\":7,\"253\":15,\"254\":2,\"256\":3,\"258\":3,\"262\":1,\"274\":4}}],[\"in\",{\"1\":{\"26\":1,\"79\":1,\"120\":1,\"132\":1,\"133\":6,\"139\":2,\"146\":1,\"182\":1,\"199\":1,\"200\":1,\"233\":1,\"234\":1,\"280\":1}}],[\"i\",{\"1\":{\"18\":1,\"29\":1,\"67\":3,\"71\":2,\"81\":9,\"82\":15,\"85\":4,\"115\":2,\"120\":4,\"127\":2,\"132\":2,\"146\":6,\"147\":4,\"192\":1,\"193\":4,\"195\":2,\"196\":4,\"197\":10,\"209\":3,\"210\":7,\"212\":4,\"213\":1,\"214\":5,\"219\":2,\"220\":6,\"222\":5,\"226\":1,\"251\":3,\"252\":9,\"253\":13,\"254\":1,\"256\":21,\"258\":3,\"263\":5,\"274\":7,\"283\":1}}],[\"i=1\",{\"1\":{\"18\":1}}],[\"iter\",{\"1\":{\"247\":3}}],[\"iterations\",{\"1\":{\"253\":2}}],[\"iterations=5\",{\"1\":{\"85\":1}}],[\"iterations=3\",{\"1\":{\"85\":1}}],[\"iterator<接口类型>\",{\"1\":{\"247\":1}}],[\"iterator<driver>\",{\"1\":{\"246\":1}}],[\"iterator<integer>\",{\"1\":{\"222\":1}}],[\"iterator\",{\"1\":{\"222\":6,\"246\":1,\"247\":1}}],[\"iterable\",{\"1\":{\"222\":3}}],[\"itable\",{\"1\":{\"230\":1}}],[\"its\",{\"1\":{\"182\":1}}],[\"itheima\",{\"1\":{\"115\":1,\"120\":1,\"125\":1}}],[\"itcast\",{\"1\":{\"115\":1,\"120\":1,\"125\":1,\"182\":2,\"193\":1,\"199\":1,\"202\":1,\"220\":2,\"234\":2,\"237\":3,\"240\":4,\"241\":4}}],[\"it\",{\"1\":{\"12\":2}}],[\"+=\",{\"1\":{\"253\":3}}],[\"+unlockdiagnosticvmoptions\",{\"1\":{\"252\":1}}],[\"+usestringdeduplication\",{\"1\":{\"169\":1}}],[\"+useserialgc\",{\"1\":{\"155\":1,\"156\":1,\"157\":1,\"159\":1}}],[\"+useg1gc\",{\"1\":{\"162\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"161\":1}}],[\"+useadptivesizepolicy\",{\"1\":{\"160\":1}}],[\"+useadaptivesizepolicy\",{\"1\":{\"160\":1}}],[\"+useadaptivesizepolicy幸存区比例\",{\"1\":{\"155\":1}}],[\"+useparnewgc\",{\"1\":{\"161\":1}}],[\"+useparallelgc\",{\"1\":{\"160\":1}}],[\"+usepralleroldgc\",{\"1\":{\"160\":1}}],[\"++this\",{\"1\":{\"254\":1}}],[\"++i\",{\"1\":{\"222\":1}}],[\"++a\",{\"1\":{\"193\":2}}],[\"+classunloadingwithconcurrentmark\",{\"1\":{\"170\":1}}],[\"+cmsscavengebeforeremark\",{\"1\":{\"161\":1}}],[\"+scavengebeforefullgc\",{\"1\":{\"155\":1}}],[\"+disableexplicitgc\",{\"1\":{\"133\":2}}],[\"+printcompilation\",{\"1\":{\"252\":1}}],[\"+printinlining\",{\"1\":{\"252\":1}}],[\"+printtenuringdistrubution\",{\"1\":{\"176\":1}}],[\"+printtenuringdistributiongc详情\",{\"1\":{\"155\":1}}],[\"+printflagsfinal\",{\"1\":{\"172\":1}}],[\"+printgcdetails\",{\"1\":{\"127\":2,\"146\":1,\"155\":2,\"156\":1,\"157\":1}}],[\"+printstringtablestatistics\",{\"1\":{\"127\":2}}],[\"+new\",{\"1\":{\"98\":4,\"125\":2}}],[\"+1\",{\"1\":{\"71\":1}}],[\"+\",{\"0\":{\"159\":1},\"1\":{\"18\":1,\"29\":1,\"67\":1,\"81\":8,\"82\":14,\"108\":1,\"115\":1,\"120\":2,\"123\":2,\"125\":2,\"132\":2,\"146\":1,\"147\":3,\"155\":1,\"158\":1,\"159\":1,\"162\":3,\"167\":1,\"187\":2,\"192\":1,\"193\":2,\"199\":1,\"205\":1,\"220\":1,\"223\":1,\"228\":2,\"246\":4,\"248\":6,\"274\":2,\"283\":1}}],[\"young\",{\"0\":{\"163\":1,\"167\":1},\"1\":{\"162\":2,\"164\":1}}],[\"y\",{\"1\":{\"18\":2,\"218\":3}}],[\"y^\",{\"1\":{\"18\":2}}],[\"lcmp\",{\"1\":{\"194\":1}}],[\"lcn\",{\"1\":{\"182\":1,\"220\":1}}],[\"l\",{\"1\":{\"169\":4}}],[\"ldc2\",{\"1\":{\"192\":1}}],[\"ldc\",{\"1\":{\"123\":14,\"188\":1,\"192\":2,\"197\":2,\"211\":2,\"215\":1}}],[\"lazyiterator\",{\"1\":{\"248\":1}}],[\"lazyholder\",{\"1\":{\"238\":2}}],[\"launcher$extclassloader\",{\"1\":{\"241\":1}}],[\"launcher$appclassloader\",{\"1\":{\"241\":1}}],[\"last\",{\"1\":{\"188\":1}}],[\"latency\",{\"1\":{\"162\":1}}],[\"latch\",{\"1\":{\"97\":8}}],[\"lang\",{\"1\":{\"71\":4,\"109\":2,\"115\":6,\"120\":8,\"123\":20,\"132\":1,\"182\":5,\"188\":15,\"193\":5,\"196\":1,\"206\":3,\"209\":1,\"210\":9,\"211\":8,\"212\":1,\"215\":4,\"217\":1,\"219\":5,\"220\":13,\"226\":2,\"227\":2,\"254\":1}}],[\"lib里未查找到该class\",{\"1\":{\"242\":1}}],[\"lib\",{\"1\":{\"201\":1,\"239\":2,\"241\":2,\"245\":2}}],[\"limit\",{\"1\":{\"175\":1}}],[\"live\",{\"1\":{\"139\":1}}],[\"linux\",{\"1\":{\"179\":1}}],[\"linux环境下运行某些程序的时候\",{\"1\":{\"110\":1}}],[\"line\",{\"1\":{\"71\":4,\"188\":3,\"193\":5,\"220\":5}}],[\"linenumbertable\",{\"1\":{\"71\":1,\"182\":1,\"188\":3,\"193\":1,\"210\":1,\"211\":1,\"220\":2}}],[\"list=new\",{\"1\":{\"156\":1}}],[\"list<string>\",{\"1\":{\"220\":1}}],[\"list<softreference<byte\",{\"1\":{\"146\":1}}],[\"list<ljava\",{\"1\":{\"220\":1}}],[\"list<integer>\",{\"1\":{\"219\":1,\"222\":2}}],[\"list<byte\",{\"1\":{\"155\":1}}],[\"list<bytebuffer>\",{\"1\":{\"132\":1}}],[\"list<weakreference<byte\",{\"1\":{\"147\":2}}],[\"list和softreference是强引用\",{\"1\":{\"146\":2}}],[\"list\",{\"1\":{\"81\":7,\"82\":4,\"115\":3,\"132\":2,\"139\":7,\"146\":15,\"147\":8,\"155\":7,\"156\":1,\"157\":3,\"219\":11,\"220\":8,\"222\":4}}],[\"lightweight\",{\"1\":{\"77\":1}}],[\"ljava\",{\"1\":{\"71\":2,\"123\":10,\"182\":4,\"188\":10,\"193\":4,\"196\":1,\"210\":5,\"211\":4,\"215\":2,\"219\":3,\"220\":7}}],[\"length\",{\"1\":{\"71\":1,\"120\":1,\"193\":1,\"210\":1,\"211\":1,\"220\":4,\"221\":2,\"222\":1,\"246\":1,\"253\":4}}],[\"left\",{\"1\":{\"18\":3}}],[\"loading\",{\"1\":{\"246\":1}}],[\"loadinitialdrivers\",{\"1\":{\"245\":1,\"246\":2}}],[\"loadeddrivers\",{\"1\":{\"246\":2}}],[\"loader\",{\"1\":{\"230\":1,\"242\":1,\"248\":1}}],[\"load5\",{\"1\":{\"240\":2,\"241\":1}}],[\"load3\",{\"1\":{\"237\":1}}],[\"load2\",{\"1\":{\"234\":2,\"238\":1}}],[\"load\",{\"1\":{\"234\":2,\"240\":4,\"241\":4,\"246\":2,\"247\":1,\"248\":3}}],[\"loadclass源码\",{\"1\":{\"242\":1}}],[\"loadclass方法\",{\"1\":{\"237\":1}}],[\"loadclass\",{\"1\":{\"233\":1,\"234\":2,\"237\":1,\"242\":3,\"243\":2}}],[\"low\",{\"1\":{\"162\":1}}],[\"long\",{\"1\":{\"101\":2,\"132\":3,\"133\":1,\"182\":1,\"192\":2,\"194\":1,\"242\":2,\"251\":2,\"252\":2}}],[\"loopnumber\",{\"1\":{\"82\":4}}],[\"localvariabletypetable\",{\"1\":{\"220\":2}}],[\"localvariabletable\",{\"1\":{\"71\":1,\"182\":1,\"193\":1,\"210\":1,\"211\":1,\"220\":2}}],[\"locals=2\",{\"1\":{\"198\":1,\"211\":1}}],[\"locals=0\",{\"1\":{\"197\":1}}],[\"locals=4\",{\"1\":{\"191\":1,\"212\":1,\"215\":1}}],[\"locals=1\",{\"1\":{\"188\":2,\"220\":1}}],[\"locals=6\",{\"1\":{\"123\":1}}],[\"locals=5\",{\"1\":{\"123\":1}}],[\"locals=3\",{\"1\":{\"71\":1,\"193\":1,\"196\":1,\"197\":1,\"209\":1,\"210\":1,\"213\":1,\"214\":1,\"219\":1,\"220\":1}}],[\"locals\",{\"1\":{\"71\":1,\"192\":1}}],[\"local\",{\"1\":{\"65\":1,\"176\":1,\"253\":6}}],[\"locked\",{\"1\":{\"77\":2}}],[\"lock对象\",{\"1\":{\"71\":3}}],[\"lock引用\",{\"1\":{\"71\":4}}],[\"lock\",{\"1\":{\"59\":1,\"65\":1,\"71\":2,\"77\":3,\"83\":2,\"215\":2}}],[\"locksupport还提供了一些变体的park方法\",{\"1\":{\"101\":1}}],[\"locksupport提供了一些静态方法\",{\"1\":{\"101\":1}}],[\"locksupport工具类\",{\"1\":{\"101\":1}}],[\"locksupport\",{\"0\":{\"101\":1},\"1\":{\"62\":2,\"82\":4,\"101\":5}}],[\"locks\",{\"1\":{\"59\":2,\"101\":1}}],[\"locks子包\",{\"1\":{\"59\":1}}],[\"log\",{\"1\":{\"18\":2,\"79\":4,\"80\":4,\"81\":5,\"82\":10,\"97\":8}}],[\"=1\",{\"1\":{\"224\":1}}],[\"=0\",{\"1\":{\"224\":1}}],[\"===========================================\",{\"1\":{\"147\":1}}],[\"=====================\",{\"1\":{\"146\":1}}],[\"===============>\",{\"1\":{\"81\":2,\"82\":2}}],[\"==\",{\"1\":{\"123\":2,\"132\":1,\"194\":2,\"242\":2,\"246\":1}}],[\"=\",{\"1\":{\"18\":1,\"67\":2,\"68\":2,\"71\":9,\"76\":1,\"79\":3,\"80\":2,\"81\":7,\"82\":11,\"84\":1,\"85\":3,\"96\":1,\"97\":1,\"98\":1,\"101\":1,\"106\":1,\"108\":3,\"115\":4,\"120\":5,\"123\":12,\"124\":1,\"125\":1,\"127\":4,\"132\":17,\"133\":8,\"139\":2,\"146\":15,\"147\":11,\"155\":6,\"156\":5,\"157\":6,\"158\":1,\"159\":1,\"169\":2,\"175\":1,\"181\":1,\"187\":3,\"188\":28,\"192\":2,\"193\":2,\"194\":4,\"195\":3,\"196\":5,\"197\":10,\"198\":1,\"209\":3,\"210\":5,\"211\":1,\"212\":4,\"213\":3,\"214\":3,\"215\":1,\"218\":6,\"219\":7,\"220\":5,\"221\":2,\"222\":8,\"223\":8,\"224\":6,\"225\":3,\"226\":9,\"228\":5,\"233\":3,\"234\":3,\"237\":5,\"238\":4,\"240\":1,\"241\":2,\"242\":7,\"245\":1,\"246\":6,\"247\":2,\"248\":6,\"251\":4,\"252\":6,\"253\":15,\"254\":5,\"256\":5,\"258\":6,\"260\":3,\"262\":3,\"273\":4,\"274\":6,\"275\":1}}],[\"p=19\",{\"1\":{\"263\":1}}],[\"perfcounter\",{\"1\":{\"242\":3}}],[\"permgen\",{\"1\":{\"120\":1}}],[\"permits\",{\"1\":{\"94\":6}}],[\"p\",{\"1\":{\"240\":1,\"248\":3,\"276\":3}}],[\"png\",{\"1\":{\"180\":1}}],[\"posts\",{\"0\":{\"327\":1}}],[\"pop\",{\"1\":{\"198\":1,\"211\":1,\"219\":1,\"220\":1}}],[\"pool\",{\"1\":{\"179\":3,\"188\":1}}],[\"poll\",{\"1\":{\"146\":6,\"147\":6}}],[\"pid\",{\"1\":{\"110\":1}}],[\"ps\",{\"1\":{\"110\":1,\"132\":5}}],[\"present\",{\"1\":{\"182\":1}}],[\"pretenuresizethreshold\",{\"1\":{\"160\":1}}],[\"projects\",{\"1\":{\"253\":1}}],[\"proﬁling\",{\"1\":{\"251\":2}}],[\"providers\",{\"1\":{\"248\":1}}],[\"provider\",{\"1\":{\"246\":1,\"248\":3}}],[\"production\",{\"1\":{\"240\":1,\"241\":1}}],[\"protected\",{\"1\":{\"206\":2,\"242\":1}}],[\"process\",{\"1\":{\"120\":1}}],[\"program\",{\"1\":{\"106\":1}}],[\"privilegedaction<string>\",{\"1\":{\"246\":1}}],[\"privilegedaction<void>\",{\"1\":{\"132\":1,\"246\":1}}],[\"private\",{\"1\":{\"67\":1,\"68\":1,\"79\":1,\"81\":1,\"82\":1,\"132\":1,\"133\":3,\"155\":5,\"156\":5,\"157\":5,\"197\":2,\"198\":3,\"225\":2,\"238\":2,\"245\":1,\"246\":1,\"248\":1,\"252\":2,\"253\":1,\"254\":4,\"274\":3}}],[\"printf\",{\"1\":{\"220\":1,\"251\":1,\"252\":1}}],[\"print\",{\"1\":{\"147\":3,\"262\":1}}],[\"printstream\",{\"1\":{\"106\":1,\"182\":2,\"188\":8,\"192\":1,\"193\":4,\"196\":2,\"215\":2}}],[\"printstacktrace\",{\"1\":{\"79\":2,\"80\":2,\"81\":1,\"98\":2,\"101\":1,\"115\":1,\"127\":1,\"132\":1,\"211\":2,\"226\":3}}],[\"println\",{\"1\":{\"98\":4,\"101\":2,\"106\":5,\"108\":2,\"115\":1,\"120\":1,\"123\":4,\"125\":5,\"127\":1,\"132\":1,\"133\":4,\"139\":3,\"146\":8,\"147\":3,\"157\":1,\"179\":1,\"182\":1,\"187\":1,\"188\":4,\"192\":1,\"193\":4,\"196\":2,\"197\":3,\"199\":3,\"211\":1,\"213\":2,\"214\":1,\"215\":2,\"220\":1,\"221\":2,\"222\":4,\"223\":8,\"224\":4,\"226\":2,\"227\":1,\"228\":4,\"237\":9,\"238\":4,\"240\":2,\"241\":2,\"245\":2,\"246\":4,\"252\":3,\"254\":1,\"256\":1,\"258\":1,\"262\":2,\"274\":2}}],[\"ptr\",{\"1\":{\"77\":2}}],[\"put\",{\"1\":{\"248\":1,\"274\":1}}],[\"putfield\",{\"1\":{\"197\":6}}],[\"putstatic\",{\"1\":{\"71\":1,\"197\":3,\"256\":8,\"263\":3}}],[\"public\",{\"1\":{\"28\":1,\"67\":1,\"68\":3,\"71\":1,\"76\":3,\"80\":1,\"84\":1,\"85\":3,\"97\":1,\"101\":2,\"108\":9,\"115\":2,\"120\":4,\"123\":8,\"125\":2,\"127\":2,\"132\":6,\"133\":3,\"139\":1,\"146\":8,\"147\":5,\"155\":2,\"156\":2,\"157\":2,\"179\":2,\"182\":2,\"187\":2,\"188\":6,\"193\":4,\"194\":2,\"195\":6,\"196\":2,\"197\":5,\"198\":5,\"199\":7,\"206\":4,\"209\":2,\"210\":4,\"211\":5,\"212\":2,\"213\":6,\"214\":3,\"215\":2,\"217\":3,\"218\":6,\"219\":2,\"220\":6,\"221\":7,\"222\":10,\"223\":10,\"224\":4,\"225\":6,\"226\":8,\"227\":10,\"228\":13,\"233\":2,\"234\":2,\"237\":2,\"238\":7,\"240\":3,\"241\":2,\"245\":1,\"246\":2,\"248\":1,\"251\":2,\"252\":2,\"253\":6,\"254\":4,\"256\":2,\"258\":2,\"260\":1,\"262\":3,\"274\":1,\"282\":1}}],[\"paixppll\",{\"1\":{\"188\":2}}],[\"pa\",{\"1\":{\"132\":3}}],[\"package\",{\"1\":{\"125\":1,\"132\":1,\"182\":1,\"193\":1,\"198\":1,\"199\":1,\"234\":1,\"240\":2,\"241\":2,\"253\":1}}],[\"parent\",{\"1\":{\"242\":3,\"254\":5}}],[\"parnew收集器其实就是serial收集器的多线程版本\",{\"1\":{\"161\":1}}],[\"parnew\",{\"1\":{\"159\":3,\"160\":2,\"161\":2}}],[\"parameterizedtype\",{\"1\":{\"220\":6}}],[\"parameters\",{\"1\":{\"179\":1}}],[\"parallelgc\",{\"1\":{\"166\":1,\"174\":1}}],[\"parallelgcthreads=n\",{\"1\":{\"160\":1,\"161\":1}}],[\"parallelgcthreads\",{\"1\":{\"159\":1}}],[\"parallel\",{\"1\":{\"158\":2,\"160\":5}}],[\"paranoia\",{\"1\":{\"132\":1}}],[\"parseinstance\",{\"1\":{\"79\":4,\"80\":3,\"81\":4,\"82\":8}}],[\"parkunparkexample\",{\"1\":{\"101\":1}}],[\"parkuntil\",{\"1\":{\"101\":1}}],[\"parknanos\",{\"1\":{\"101\":1}}],[\"park方法的用法非常简单\",{\"1\":{\"101\":1}}],[\"park方法的作用是阻塞当前线程\",{\"1\":{\"101\":1}}],[\"park方法就是其中之一\",{\"1\":{\"101\":1}}],[\"park方法属java\",{\"1\":{\"101\":1}}],[\"parker\",{\"1\":{\"62\":1}}],[\"park\",{\"0\":{\"62\":1},\"1\":{\"62\":1,\"65\":3,\"82\":2,\"94\":2,\"101\":3}}],[\"partial\",{\"1\":{\"18\":1}}],[\"partial^r\",{\"1\":{\"18\":1}}],[\"pagesize\",{\"1\":{\"132\":1}}],[\"page\",{\"1\":{\"26\":1,\"132\":1,\"280\":1}}],[\"plugin\",{\"1\":{\"14\":1}}],[\"t0\",{\"1\":{\"242\":2}}],[\"txt\",{\"1\":{\"226\":2}}],[\"t5\",{\"1\":{\"182\":2}}],[\"tlab\",{\"1\":{\"176\":1}}],[\"time\",{\"1\":{\"253\":2}}],[\"timeunit\",{\"1\":{\"85\":1}}],[\"tid\",{\"1\":{\"110\":1}}],[\"title\",{\"1\":{\"26\":3,\"280\":3}}],[\"t3\",{\"1\":{\"82\":6,\"193\":1,\"199\":1,\"202\":1,\"220\":2,\"234\":2,\"237\":3,\"240\":4,\"241\":4}}],[\"t\",{\"1\":{\"81\":4,\"82\":7,\"179\":1,\"226\":5,\"246\":1,\"251\":1,\"252\":2,\"253\":6,\"260\":7,\"262\":3,\"263\":5}}],[\"treat\",{\"1\":{\"182\":1}}],[\"tracing\",{\"1\":{\"161\":1}}],[\"try块执行完后\",{\"1\":{\"212\":1}}],[\"try块\",{\"1\":{\"212\":1}}],[\"try\",{\"0\":{\"209\":1,\"226\":1},\"1\":{\"79\":2,\"80\":2,\"81\":1,\"95\":1,\"98\":3,\"101\":1,\"115\":1,\"120\":1,\"127\":1,\"132\":3,\"209\":1,\"210\":1,\"211\":1,\"212\":2,\"213\":3,\"214\":1,\"226\":9,\"242\":1,\"246\":3,\"248\":2}}],[\"true\",{\"1\":{\"68\":1,\"79\":4,\"80\":3,\"81\":4,\"82\":8,\"115\":1,\"123\":2,\"125\":3,\"132\":1,\"133\":1,\"246\":1,\"260\":1,\"262\":1,\"263\":4}}],[\"t2\",{\"1\":{\"79\":7,\"80\":2,\"81\":95,\"82\":5,\"256\":3,\"258\":6}}],[\"terminated\",{\"1\":{\"132\":1}}],[\"test6\",{\"1\":{\"226\":6}}],[\"test1\",{\"1\":{\"198\":3,\"253\":5}}],[\"test\",{\"1\":{\"120\":2,\"199\":3,\"211\":5,\"213\":4,\"214\":2,\"220\":2,\"226\":3,\"227\":2,\"228\":2,\"233\":1,\"253\":1}}],[\"test4\",{\"1\":{\"82\":1,\"198\":4}}],[\"test3\",{\"1\":{\"81\":1,\"198\":3,\"253\":3}}],[\"testbiased\",{\"1\":{\"79\":4}}],[\"test2\",{\"1\":{\"79\":1,\"198\":3,\"253\":3}}],[\"tex\",{\"0\":{\"18\":1}}],[\"types\",{\"1\":{\"220\":2}}],[\"type的值就去表中找类型\",{\"1\":{\"182\":1}}],[\"type\",{\"1\":{\"71\":3,\"182\":3,\"209\":2,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"220\":6}}],[\"target\",{\"1\":{\"71\":1,\"209\":2,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"254\":3}}],[\"table\",{\"1\":{\"71\":1,\"209\":2,\"210\":2,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1}}],[\"tomcat\",{\"1\":{\"243\":1}}],[\"tools\",{\"1\":{\"202\":1,\"205\":1,\"206\":1,\"253\":1}}],[\"to中为空\",{\"1\":{\"151\":1}}],[\"tobytearray\",{\"1\":{\"120\":1}}],[\"tostring\",{\"1\":{\"108\":2,\"123\":5,\"125\":1,\"199\":2,\"206\":2}}],[\"toprintablesimple\",{\"1\":{\"79\":4,\"80\":3,\"81\":4,\"82\":8}}],[\"to\",{\"1\":{\"71\":1,\"77\":2,\"132\":1,\"153\":2,\"209\":2,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1}}],[\"toc\",{\"1\":{\"6\":1}}],[\"t1\",{\"1\":{\"61\":6,\"79\":5,\"80\":6,\"81\":34,\"82\":4,\"242\":3,\"256\":3,\"258\":7}}],[\"thunk\",{\"1\":{\"132\":1}}],[\"this为虚引用的实际对象\",{\"1\":{\"132\":1}}],[\"this\",{\"1\":{\"132\":3,\"179\":1,\"182\":1,\"197\":8,\"199\":1,\"220\":1,\"228\":2,\"248\":1,\"253\":1,\"254\":11,\"262\":1}}],[\"thrpt\",{\"1\":{\"253\":6}}],[\"throughput\",{\"1\":{\"162\":1}}],[\"thrown\",{\"1\":{\"242\":1}}],[\"throws\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"85\":2,\"97\":1,\"132\":1,\"133\":4,\"139\":1,\"146\":4,\"156\":1,\"157\":1,\"199\":1,\"220\":1,\"226\":1,\"233\":1,\"234\":1,\"237\":1,\"240\":1,\"242\":1,\"253\":1,\"254\":2,\"256\":1,\"258\":1,\"260\":1,\"262\":1}}],[\"throwable\",{\"1\":{\"71\":1,\"115\":1,\"132\":1,\"226\":4,\"246\":1,\"248\":1}}],[\"throw\",{\"1\":{\"71\":1,\"132\":1,\"226\":2,\"248\":2}}],[\"threads\",{\"1\":{\"167\":1}}],[\"thread\",{\"1\":{\"71\":9,\"77\":1,\"79\":4,\"80\":4,\"81\":5,\"82\":4,\"84\":4,\"94\":9,\"97\":3,\"98\":3,\"101\":12,\"120\":1,\"121\":2,\"132\":1,\"157\":2,\"176\":1,\"237\":2,\"248\":1,\"256\":4,\"258\":4,\"260\":3,\"262\":3}}],[\"threadpoolexecutor\",{\"1\":{\"59\":1,\"92\":1}}],[\"threadlocalrandom\",{\"1\":{\"253\":2}}],[\"threadlocal\",{\"1\":{\"59\":1}}],[\"theunsafe\",{\"1\":{\"133\":1}}],[\"the\",{\"1\":{\"26\":1,\"153\":2,\"159\":2,\"161\":2,\"182\":2,\"242\":1,\"280\":1}}],[\"导致了\",{\"1\":{\"260\":1}}],[\"导致无法分配\",{\"1\":{\"149\":1}}],[\"导致两个对象都无法被释放\",{\"0\":{\"136\":1}}],[\"导致栈内存溢出的情况\",{\"1\":{\"109\":1}}],[\"导致线程发生多次重入\",{\"1\":{\"86\":1}}],[\"导入文件\",{\"0\":{\"17\":1}}],[\"导航栏\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"脚注\",{\"0\":{\"16\":1}}],[\"mysql\",{\"1\":{\"245\":4}}],[\"my\",{\"1\":{\"241\":1}}],[\"myresource\",{\"1\":{\"226\":4}}],[\"mybenchmark\",{\"1\":{\"85\":5}}],[\"m\",{\"1\":{\"198\":4,\"227\":14}}],[\"multi\",{\"0\":{\"211\":1}}],[\"must\",{\"1\":{\"182\":1}}],[\"mutex是互斥锁\",{\"1\":{\"62\":1}}],[\"mutex\",{\"1\":{\"62\":1}}],[\"mutexes\",{\"1\":{\"59\":1}}],[\"mightcontain\",{\"1\":{\"274\":1}}],[\"misc\",{\"1\":{\"241\":2,\"242\":3,\"254\":1}}],[\"mirror末尾了\",{\"1\":{\"233\":1}}],[\"mirror\",{\"1\":{\"230\":4}}],[\"mixed\",{\"1\":{\"162\":1}}],[\"minor\",{\"1\":{\"153\":1,\"155\":1,\"166\":4,\"176\":3,\"178\":1,\"179\":1,\"181\":1,\"188\":1}}],[\"minorgcxx\",{\"1\":{\"155\":1}}],[\"minorgc\",{\"1\":{\"153\":2}}],[\"mem\",{\"1\":{\"204\":2,\"205\":1}}],[\"memory\",{\"1\":{\"65\":3,\"132\":1,\"139\":2,\"157\":1,\"254\":2}}],[\"mehtod1\",{\"1\":{\"146\":2}}],[\"meta\",{\"1\":{\"246\":1}}],[\"metaspace\",{\"1\":{\"120\":3}}],[\"methodaccessorgenerator\",{\"1\":{\"254\":1}}],[\"methodaccessorimpl\",{\"1\":{\"254\":3}}],[\"methodaccessor\",{\"1\":{\"254\":1}}],[\"methodparameters\",{\"1\":{\"182\":1,\"210\":1,\"211\":1}}],[\"methodtype\",{\"1\":{\"182\":1}}],[\"methodhandle\",{\"1\":{\"182\":1}}],[\"methodref\",{\"1\":{\"182\":2,\"188\":2}}],[\"methods\",{\"1\":{\"179\":3,\"182\":1,\"230\":1}}],[\"method3\",{\"1\":{\"146\":1}}],[\"method\",{\"1\":{\"120\":1,\"123\":8,\"133\":3,\"179\":1,\"182\":2,\"188\":2,\"193\":2,\"196\":1,\"198\":5,\"211\":2,\"215\":2,\"219\":2,\"220\":6,\"227\":1,\"254\":18}}],[\"method2\",{\"1\":{\"108\":2,\"146\":4,\"147\":2}}],[\"method1\",{\"1\":{\"84\":1,\"108\":2,\"133\":2,\"146\":2,\"147\":2}}],[\"measurement\",{\"1\":{\"85\":1,\"253\":1}}],[\"m3\",{\"1\":{\"76\":2,\"108\":1}}],[\"m2\",{\"1\":{\"76\":2,\"108\":1}}],[\"m1\",{\"1\":{\"76\":1,\"108\":1}}],[\"maven\",{\"1\":{\"253\":1}}],[\"man\",{\"1\":{\"224\":2}}],[\"male\",{\"1\":{\"224\":8,\"225\":5}}],[\"may\",{\"1\":{\"182\":1}}],[\"major\",{\"1\":{\"179\":1,\"181\":1,\"188\":1}}],[\"magic\",{\"1\":{\"179\":1,\"180\":1}}],[\"map<integer\",{\"1\":{\"220\":1}}],[\"map\",{\"1\":{\"175\":2,\"220\":3,\"224\":4}}],[\"mat\",{\"0\":{\"139\":1}}],[\"math\",{\"1\":{\"132\":1}}],[\"maxtenuringthreshold=threshold\",{\"1\":{\"176\":1}}],[\"maxtenuringthreshold=threshold晋升详情\",{\"1\":{\"155\":1}}],[\"maxgcpausemills\",{\"1\":{\"165\":1}}],[\"maxgcpausemillis=time\",{\"1\":{\"162\":1}}],[\"maxgcpausemillis=ms\",{\"1\":{\"160\":2}}],[\"maxnewsize=size\",{\"1\":{\"155\":1}}],[\"maxheapsize=size新生代大小\",{\"1\":{\"155\":1}}],[\"max\",{\"1\":{\"132\":1,\"187\":1,\"192\":2}}],[\"maxmetaspacesize=8m\",{\"1\":{\"120\":2}}],[\"maxpermsize=8m\",{\"1\":{\"120\":1}}],[\"marked\",{\"1\":{\"77\":1}}],[\"mark\",{\"1\":{\"72\":1,\"76\":1,\"77\":1,\"83\":3,\"84\":1,\"161\":2,\"162\":1}}],[\"markword\",{\"1\":{\"71\":3,\"78\":1,\"203\":1}}],[\"markdown\",{\"0\":{\"9\":1,\"10\":1,\"11\":1,\"12\":1},\"1\":{\"9\":2,\"10\":3,\"11\":1,\"12\":3,\"13\":2,\"14\":1,\"26\":3,\"27\":1,\"28\":2,\"29\":2,\"280\":3,\"281\":1,\"282\":2,\"283\":2},\"2\":{\"24\":1}}],[\"main>javap\",{\"1\":{\"188\":1}}],[\"main1\",{\"1\":{\"108\":2,\"115\":3,\"120\":5}}],[\"main\",{\"0\":{\"191\":1},\"1\":{\"65\":1,\"71\":1,\"80\":1,\"97\":1,\"101\":1,\"108\":2,\"115\":2,\"120\":3,\"121\":2,\"123\":4,\"125\":2,\"127\":1,\"132\":7,\"133\":1,\"139\":1,\"146\":2,\"147\":1,\"155\":1,\"156\":2,\"157\":2,\"179\":1,\"182\":1,\"187\":1,\"188\":15,\"192\":3,\"193\":2,\"194\":1,\"195\":3,\"196\":1,\"197\":6,\"198\":9,\"199\":1,\"209\":2,\"210\":2,\"211\":2,\"212\":2,\"213\":4,\"214\":3,\"215\":1,\"218\":3,\"219\":1,\"220\":2,\"221\":2,\"222\":4,\"223\":2,\"224\":2,\"226\":5,\"227\":1,\"228\":2,\"233\":1,\"234\":1,\"237\":3,\"238\":1,\"240\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"256\":1,\"258\":1,\"260\":3,\"262\":1,\"263\":1,\"274\":1}}],[\"modified\",{\"1\":{\"188\":1}}],[\"mode\",{\"1\":{\"85\":3,\"253\":4}}],[\"model\",{\"1\":{\"65\":1,\"254\":2}}],[\"monitorexit\",{\"1\":{\"71\":2,\"215\":2}}],[\"monitorenter指令是在编译后插入到同步代码块的开始位置\",{\"1\":{\"258\":1}}],[\"monitorenter\",{\"1\":{\"71\":1,\"215\":1}}],[\"monitor中只能有一个\",{\"1\":{\"71\":1}}],[\"monitor\",{\"0\":{\"70\":1},\"1\":{\"65\":1,\"70\":2,\"71\":4,\"77\":1,\"78\":1,\"84\":4}}],[\"more\",{\"1\":{\"25\":1,\"268\":1,\"279\":1}}],[\"ms\",{\"1\":{\"27\":1,\"162\":1,\"281\":1}}],[\"md5\",{\"1\":{\"188\":1}}],[\"md\",{\"1\":{\"14\":1}}],[\"对数据的可见性\",{\"1\":{\"254\":1}}],[\"对我们不可见\",{\"1\":{\"224\":1}}],[\"对号入座\",{\"1\":{\"206\":1}}],[\"对进行并发标记\",{\"1\":{\"164\":1}}],[\"对新生代垃圾收集\",{\"1\":{\"162\":1}}],[\"对标记的对象进行清除回收\",{\"1\":{\"161\":1}}],[\"对应枚举类中的元素\",{\"1\":{\"225\":1}}],[\"对应字节码\",{\"1\":{\"219\":1}}],[\"对应字节码文件\",{\"1\":{\"180\":1,\"181\":1}}],[\"对应的字节码文件\",{\"1\":{\"198\":1,\"209\":1,\"210\":1,\"212\":1,\"213\":1,\"214\":1}}],[\"对应的虚拟机指令有所区别\",{\"1\":{\"198\":1}}],[\"对应的目录下就会出现类的\",{\"1\":{\"121\":1}}],[\"对应代码中的\",{\"1\":{\"192\":1}}],[\"对应操作数栈有2个空间\",{\"1\":{\"191\":1}}],[\"对应着当前正在执行的方法\",{\"1\":{\"108\":1}}],[\"对应着每次调用方法时所占用的内存\",{\"1\":{\"108\":1}}],[\"对相同对象多次加锁\",{\"1\":{\"86\":1}}],[\"对象呢\",{\"1\":{\"258\":1}}],[\"对象的\",{\"1\":{\"228\":1}}],[\"对象的指针\",{\"1\":{\"70\":1}}],[\"对象时\",{\"1\":{\"228\":1}}],[\"对象引用\",{\"1\":{\"198\":5}}],[\"对象大小\",{\"1\":{\"175\":1}}],[\"对象图\",{\"1\":{\"175\":1}}],[\"对象首先分配在伊甸园区域\",{\"1\":{\"153\":1}}],[\"对象都不通过\",{\"1\":{\"141\":1}}],[\"对象都可以关联一个\",{\"1\":{\"70\":1}}],[\"对象就会被回收\",{\"1\":{\"139\":1}}],[\"对象调用\",{\"1\":{\"133\":1}}],[\"对象被垃圾回收\",{\"1\":{\"132\":1}}],[\"对象完成直接内存的分配回收\",{\"1\":{\"132\":1}}],[\"对象申请\",{\"1\":{\"84\":1}}],[\"对象头中存储了\",{\"1\":{\"83\":1}}],[\"对象头由以下三部分组成\",{\"1\":{\"72\":1}}],[\"对象头\",{\"0\":{\"72\":1}}],[\"对象\",{\"1\":{\"62\":1,\"70\":1,\"83\":1,\"84\":1,\"132\":1,\"139\":1,\"198\":1,\"258\":1}}],[\"对于仅占据小部分的热点代码\",{\"1\":{\"251\":1}}],[\"对于大部分的不常用的代码\",{\"1\":{\"251\":1}}],[\"对于任意一个类\",{\"1\":{\"239\":1}}],[\"对于子类\",{\"1\":{\"227\":1}}],[\"对于限定单个\",{\"1\":{\"159\":1}}],[\"对于以上代码\",{\"1\":{\"139\":1}}],[\"对于\",{\"1\":{\"28\":1,\"282\":1}}],[\"对\",{\"1\":{\"13\":1,\"139\":1,\"247\":1}}],[\"为静态变量\",{\"1\":{\"256\":1}}],[\"为e\",{\"1\":{\"209\":1}}],[\"为什么会这样\",{\"1\":{\"260\":1}}],[\"为什么会交错\",{\"1\":{\"256\":1}}],[\"为什么需要这里的\",{\"1\":{\"258\":1}}],[\"为什么需要两份引用呢\",{\"1\":{\"198\":1}}],[\"为什么呢\",{\"1\":{\"256\":1}}],[\"为什么要设计一个\",{\"1\":{\"226\":1}}],[\"为什么第一遍时必须既比较\",{\"1\":{\"223\":1}}],[\"为什么最终的\",{\"1\":{\"196\":1}}],[\"为什么有的老年代被拷贝了\",{\"1\":{\"165\":1}}],[\"为例\",{\"1\":{\"177\":1,\"239\":1}}],[\"为了反射使用\",{\"1\":{\"219\":1}}],[\"为了抓住重点\",{\"1\":{\"209\":1}}],[\"为了保证时间不超过设定的停顿时间\",{\"1\":{\"165\":1}}],[\"为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"161\":1}}],[\"为了丰富文档写作\",{\"1\":{\"13\":1}}],[\"为\",{\"1\":{\"68\":1,\"71\":1,\"84\":1,\"94\":1,\"179\":1,\"224\":2,\"233\":1,\"263\":1}}],[\"为每个\",{\"1\":{\"11\":1}}],[\"扩展类的加载器\",{\"0\":{\"241\":1}}],[\"扩展\",{\"0\":{\"12\":1,\"13\":1},\"1\":{\"13\":1}}],[\"请求高峰期发生\",{\"1\":{\"178\":1}}],[\"请求\",{\"1\":{\"176\":1}}],[\"请参考之\",{\"1\":{\"61\":1}}],[\"请使用绝对链接\",{\"1\":{\"28\":1,\"282\":1}}],[\"请阅读\",{\"1\":{\"11\":1,\"13\":1}}],[\"请先阅读\",{\"1\":{\"10\":1}}],[\"中对静态变量的自增\",{\"1\":{\"256\":1}}],[\"中如果抛出了异常\",{\"1\":{\"226\":1}}],[\"中出现了\",{\"1\":{\"213\":1}}],[\"中一个分支\",{\"1\":{\"210\":1}}],[\"中去\",{\"1\":{\"146\":1}}],[\"中引用的对象\",{\"1\":{\"138\":1}}],[\"中引入了偏向锁来做进一步优化\",{\"1\":{\"76\":1}}],[\"中添加\",{\"1\":{\"115\":1}}],[\"中记录\",{\"1\":{\"78\":1}}],[\"中存储的是线程\",{\"1\":{\"78\":1}}],[\"中等待的线程来竞争锁\",{\"1\":{\"71\":1}}],[\"中就被设置指向\",{\"1\":{\"70\":1}}],[\"中\",{\"1\":{\"59\":2,\"65\":1,\"71\":1,\"84\":1,\"153\":1,\"167\":1,\"192\":1,\"215\":1,\"222\":1,\"230\":1,\"248\":1,\"273\":3}}],[\"中使用\",{\"1\":{\"29\":1,\"283\":1}}],[\"中设置页面信息\",{\"1\":{\"27\":1,\"281\":1}}],[\"中设置页面标题\",{\"1\":{\"26\":1,\"280\":1}}],[\"中的代码被复制了\",{\"1\":{\"212\":1}}],[\"中的第一个\",{\"1\":{\"26\":1,\"280\":1}}],[\"中的\",{\"1\":{\"13\":1,\"71\":1,\"146\":1,\"213\":1}}],[\"中很重要的一个概念\",{\"1\":{\"11\":1}}],[\"中自定义它们\",{\"1\":{\"6\":1}}],[\"是从自己工作内存中的高速缓存中读取这个变量的值\",{\"1\":{\"260\":1}}],[\"是热点方法\",{\"1\":{\"252\":1}}],[\"是将字节码解释为针对所有平台都通用的机器码\",{\"1\":{\"251\":1}}],[\"是将异常对象引用存入局部变量表的2号位置\",{\"1\":{\"209\":1}}],[\"是指在运行过程中收集一些程序执行状态的数据\",{\"1\":{\"251\":1}}],[\"是由于用户对程序动态性的追求而导致的\",{\"1\":{\"243\":1}}],[\"是由这个模型自身的缺陷导致的\",{\"1\":{\"243\":1}}],[\"是包装类\",{\"1\":{\"238\":1}}],[\"是存储在堆中\",{\"1\":{\"230\":2}}],[\"是存储在方法区\",{\"1\":{\"230\":2}}],[\"是父类\",{\"1\":{\"227\":1}}],[\"是我们代码出现的异常\",{\"1\":{\"226\":1}}],[\"是为了防止异常信息的丢失\",{\"1\":{\"226\":1}}],[\"是为了防止\",{\"1\":{\"223\":1}}],[\"是为了提高效率\",{\"1\":{\"223\":1}}],[\"是为了提高比较效率\",{\"1\":{\"223\":1}}],[\"是防止有\",{\"1\":{\"223\":1}}],[\"是前闭后开\",{\"1\":{\"209\":1}}],[\"是查看\",{\"1\":{\"204\":1}}],[\"是对象地址\",{\"1\":{\"204\":1}}],[\"是通过\",{\"1\":{\"198\":1}}],[\"是复制操作数栈栈顶的内容\",{\"1\":{\"198\":1}}],[\"是创建\",{\"1\":{\"198\":1}}],[\"是否存在内存泄漏\",{\"1\":{\"175\":1}}],[\"是并发的\",{\"1\":{\"161\":1}}],[\"是parallel\",{\"1\":{\"160\":1}}],[\"是被\",{\"1\":{\"133\":1}}],[\"是线程私有的\",{\"1\":{\"106\":1}}],[\"是记录下一条\",{\"1\":{\"106\":1}}],[\"是可以重用的\",{\"1\":{\"98\":1}}],[\"是java中用于实现锁和同步器的基础框架\",{\"1\":{\"92\":1}}],[\"是类\",{\"1\":{\"88\":1}}],[\"是一个类\",{\"1\":{\"183\":1}}],[\"是一样的\",{\"1\":{\"79\":1}}],[\"是一种原子操作\",{\"1\":{\"91\":1}}],[\"是一种比\",{\"1\":{\"68\":1}}],[\"是一种抽象的模型\",{\"1\":{\"65\":1}}],[\"是自己的就表示没有竞争\",{\"1\":{\"76\":1}}],[\"是之前获得过锁\",{\"1\":{\"71\":1}}],[\"是唤醒所有等待线程\",{\"1\":{\"65\":1}}],[\"是调用者轮询检查线程\",{\"1\":{\"61\":1}}],[\"是\",{\"1\":{\"11\":1,\"94\":1,\"160\":1,\"182\":21,\"192\":2,\"254\":1}}],[\"演示多态原理\",{\"1\":{\"199\":1}}],[\"演示内存的分配策略\",{\"1\":{\"156\":1,\"157\":1}}],[\"演示堆内存不足\",{\"1\":{\"146\":1}}],[\"演示堆内存溢出\",{\"1\":{\"115\":1}}],[\"演示元空间内存溢出\",{\"1\":{\"120\":1}}],[\"演示\",{\"1\":{\"10\":1,\"127\":1,\"133\":2,\"146\":3,\"147\":2}}],[\"和我们之前定义的误判率为0\",{\"1\":{\"275\":1}}],[\"和下标为5的位置设置成1\",{\"1\":{\"273\":1}}],[\"和monitorexit指令实现的\",{\"1\":{\"258\":1}}],[\"和原子性的规则和保障\",{\"1\":{\"254\":1}}],[\"和枚举使用时\",{\"1\":{\"223\":1}}],[\"和内存位置\",{\"1\":{\"91\":1}}],[\"和新值\",{\"1\":{\"91\":1}}],[\"和\",{\"1\":{\"10\":1,\"27\":1,\"59\":1,\"60\":1,\"62\":1,\"65\":3,\"94\":1,\"155\":1,\"159\":1,\"162\":1,\"178\":1,\"182\":11,\"193\":1,\"195\":1,\"223\":3,\"241\":1,\"273\":4,\"281\":1}}],[\"介绍\",{\"0\":{\"10\":1},\"1\":{\"10\":1,\"11\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"你知道是怎么做的吗\",{\"1\":{\"245\":1}}],[\"你发现它们是一模一样的\",{\"1\":{\"195\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"29\":1,\"283\":1}}],[\"你需要创建并编写\",{\"1\":{\"9\":1}}],[\"你可以将图片和\",{\"1\":{\"28\":1,\"282\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"28\":1,\"282\":1}}],[\"你可以在\",{\"1\":{\"26\":1,\"27\":1,\"280\":1,\"281\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"6\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"9\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"3\":1,\"56\":1}}],[\"文本\",{\"1\":{\"118\":1}}],[\"文件内容是实现类名称\",{\"1\":{\"246\":1}}],[\"文件进行分析\",{\"1\":{\"139\":1}}],[\"文件名\",{\"1\":{\"139\":1}}],[\"文件读取流程\",{\"1\":{\"131\":1}}],[\"文件读写流程\",{\"1\":{\"131\":1}}],[\"文件中的\",{\"1\":{\"122\":1}}],[\"文件\",{\"1\":{\"59\":1,\"180\":1,\"185\":1,\"239\":1}}],[\"文件夹的图片\",{\"1\":{\"28\":1,\"282\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"28\":1,\"282\":1}}],[\"文件生成页面\",{\"1\":{\"9\":1}}],[\"文章标题列表\",{\"1\":{\"6\":1}}],[\"展示\",{\"0\":{\"9\":1}}],[\"夜间模式按钮\",{\"1\":{\"6\":1}}],[\"主线程还是会正常执行\",{\"1\":{\"157\":1}}],[\"主线程稍等一秒钟后调用unpark方法唤醒等待的线程\",{\"1\":{\"101\":1}}],[\"主动将串池中还没有的字符串对象放入串池中\",{\"1\":{\"123\":1}}],[\"主题扩展了更多\",{\"1\":{\"14\":1}}],[\"主题扩展\",{\"0\":{\"14\":1}}],[\"主题也带有以下元素\",{\"1\":{\"6\":1}}],[\"主要是为了减轻程序员的负担\",{\"1\":{\"216\":1}}],[\"主要配合\",{\"1\":{\"144\":1}}],[\"主要用于保证变量的可见性\",{\"1\":{\"68\":1}}],[\"主要从\",{\"1\":{\"9\":1}}],[\"主要功能与配置演示\",{\"0\":{\"1\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"29\":1,\"283\":1}}],[\"页面内容\",{\"0\":{\"28\":1,\"282\":1}}],[\"页面标题\",{\"0\":{\"26\":1,\"280\":1},\"1\":{\"26\":1,\"280\":1}}],[\"页面配置\",{\"0\":{\"25\":1,\"279\":1},\"1\":{\"27\":1,\"281\":1},\"2\":{\"31\":1,\"285\":1}}],[\"页面引入配置\",{\"1\":{\"11\":1}}],[\"页面信息\",{\"0\":{\"27\":1,\"281\":1},\"1\":{\"3\":1,\"56\":1}}],[\"页脚\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"评论\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"链接\",{\"0\":{\"231\":1},\"1\":{\"3\":1,\"56\":1}}],[\"贡献者\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"路径导航\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}],[\"侧边栏\",{\"1\":{\"3\":1,\"6\":1,\"56\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
