---
# 这是文章的标题
title:  Redis缓存三兄弟
# 你可以自定义封面图片
cover: /assets/images/cover1.jpg
# 这是页面的图标
icon: file
# 这是侧边栏的顺序
order: 3
# 设置作者
author: HotMilk
# 设置写作时间
date: 2024-7-15
# 一个页面可以有多个分类
category:
  - Redis
# 一个页面可以有多个标签
tag:
  - 缓存穿透
  - 缓存击穿
  - 缓存雪崩
# 此页面会在文章列表置顶
# sticky: true
# 此页面会出现在星标文章中
# star: true
# 你可以自定义页脚
# footer: 这是测试显示的页脚
# 你可以自定义版权信息
# copyright: 无版权
---

`more` 注释之前的内容被视为文章摘要。

<!-- more -->

#  缓存穿透

![image-20240716232915559](https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407162329593.png)

缓存穿透：

指查询一个不存在的数据，由于缓存不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入

缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

风险：

利用不存在的数据进行攻击，数据库压力瞬间增大，最终导致崩溃

解决：

- null结果缓存，并加入短暂过期时间
- 布隆过滤器判断是否存在

# 缓存击穿

![image-20240716232939467](https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407162329508.png)

缓存击穿：

对于一些设置了过期时间的key，如果这些key可能在某些时间内被超高并发的访问，是一种非常热点的数据

，如果这个key在大量请求同时进来前刚好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。

解决：

- 分布式锁

  大量并发只让一人去查，其他人等待，查询到以后释放锁，其他人获取到锁，先查询缓存，就会有数据，不用去DB查询

- 逻辑过期

  第二种方案可以设置当前key逻辑过期，大概是思路如下：

  ①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间

  ②：当查询的时候，从redis取出数据后判断时间是否过期

  ③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新

当然两种方案各有利弊：

如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题

如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。

# 缓存雪崩

![image-20240716233013863](https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407162330907.png)

缓存雪崩：

缓存雪崩是指我们在设置缓存key时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB压力瞬时压力过重雪崩

解决：

在原有的失效时间基础上行增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，

就很难引发集体失效的事件

