---
# 这是文章的标题
title:  Redis主从复制

# 你可以自定义封面图片
cover: /assets/images/cover1.jpg

# 这是页面的图标
icon: file

# 这是侧边栏的顺序
order: 3

# 设置作者
author: HotMilk

# 设置写作时间
date: 2024-7-15

# 一个页面可以有多个分类
category:
  - Redis

# 一个页面可以有多个标签
tag:
  - Redis

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在星标文章中
# star: true

# 你可以自定义页脚
# footer: 这是测试显示的页脚

# 你可以自定义版权信息
# copyright: 无版权
---

Redis主从复制原理，Redis主从复制配置。

<!-- more -->

![image-20240717182103796](https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407171821863.png)

![image-20240717181813999](https://hotmilk-pic.oss-cn-shenzhen.aliyuncs.com/assets/202407171818049.png)

### 是什么

Redis的主从复制（Replication）是一种数据管理和扩展的策略，通过此机制可以将一个Redis服务器（称为主节点，Master）的数据实时复制到一个或多个其他Redis服务器（称为从节点，Slave）。这种架构设计主要用于实现数据冗余、提高读取性能以及构建高可用系统。以下是Redis主从复制的主要特点和工作原理：

### 为什么，主从复制主要的作用?

- 数据冗余： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方 式。
- 故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢 复 (实际上是一种服务的冗余) 。
- 负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务， 由从节点提供读服务 （即写 Redis 数据时应用连接主节点，读 Redis 数据时应用 连接从节点） ，分担服务器负载。尤其是在写少读多的场景下，通过多个从节 点分担读负载，可以大大提高 Redis 服务器的并发量。
- 高可用基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的 基 础 ，因此说主从复制是 Redis 高可用的基础。

### 优点和缺点

主从复制虽好，但也存在一些问题：

一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。

主节点的写能力受到单机的限制。

主节点的存储能力受到单机的限制。

第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。

### 工作原理

1. 连接与同步：
   - 初始化连接：从节点通过SLAVEOF命令连接到主节点，建立复制关系。在Redis 6之后，推荐使用REPLICAOF命令。
   - 全量复制：首次建立复制关系时，主节点会执行BGSAVE生成RDB快照文件，然后将此快照文件发送给从节点。从节点接收后载入快照，以达到与主节点数据一致的状态。
   - 部分复制：如果从节点断线后重新连接到主节点，主节点会根据复制积压缓冲区（replication backlog）来确定哪些命令需要补发给从节点，实现增量复制。
2. 命令传播：
   - 一旦从节点完成初始同步，主节点会持续将新的写操作命令异步地发送给所有从节点，保持数据的近实时同步。
3. 复制积压缓冲区：
   - 为了支持部分复制，Redis主节点维护一个固定大小的FIFO队列，保存最近的写操作命令。这个缓冲区有助于从节点在重连后仅同步缺失的部分数据，而非再次进行全量复制。
4. 心跳与监控：
   - 从节点定期向主节点发送PING命令，以检测连接状态并获取可能的延迟命令。
   - 哨兵系统（Sentinel）可以进一步监控主从节点的健康状态，自动处理故障转移。

### 目的与好处

- 数据备份：通过主从复制实现数据冗余，保护数据免受单点故障的影响。
- 读写分离：主节点处理写操作，从节点处理读操作，可以提高系统的读取性能和扩展性。
- 高可用性：结合哨兵系统或集群模式，可以实现故障自动转移，提高服务可用性。

### 注意事项

- 一致性：Redis的主从复制是异步的，意味着在极端情况下，从节点的数据可能会稍微滞后于主节点。
- 配置与管理：需要合理配置主从节点数量、复制策略以及监控机制，以满足特定应用场景的需求。

Redis的主从复制机制是其高可用性和可扩展性设计的重要组成部分，广泛应用于需要高性能读取和数据备份的场景中。

### 主从复制场景应用

主从复制模式适用于以下场景：

数据备份和容灾恢复：通过从节点备份主节点的数据，实现数据冗余。

读写分离：将读操作分发到从节点，减轻主节点压力，提高系统性能。

在线升级和扩展：在不影响主节点的情况下，通过增加从节点来扩展系统的读取能力。

总结：主从复制模式适合数据备份、读写分离和在线升级等场景，但在主节点故障时需要手动切换，不能自动实现故障转移。如果对高可用性要求较高，可以考虑使用哨兵模式或Cluster模式。

### 可以配置的内容：这里可以忽视，直接去redis的配置文件看就行了 

主要的内容是配置主节点的ip+端口+密码，从节点的行为，比如断开连接时是否响应客户端，从节点是否只读，主从之间同步策略，从节点优先级（需要搭配哨兵模式），积压缓冲区大小，主从心跳与超时等等。详细看下文。

```xml
# replicaof <masterip> <masterport>
```

###### 主从复制基础

- replicaof: 用于设置从节点要复制的主节点的IP地址和端口号，格式为`replicaof <masterip> <masterport>`。这建立了主从关系，使从节点成为主节点的一个副本。

`# masterauth <master-password>`



###### 认证与安全性

- masterauth: 如果主节点设置了访问密码（通过requirepass指令），这里需要配置相同的密码，以便从节点能够成功进行身份验证并开始复制过程。



replica-serve-stale-data yes

###### 处理过时数据

- replica-serve-stale-data: 决定当从节点与主节点失去联系时，是否继续响应客户端的读请求。如果设置为yes（默认），即使数据可能陈旧或不完整，从节点仍会尝试服务客户端；设置为no，则在同步过程中返回错误。



replica-read-only yes

###### 只读从节点

- replica-read-only: 默认设置为yes，意味着从节点拒绝执行写操作，以此作为保护措施防止误操作。虽然名为“只读”，但请注意，某些管理命令依然可执行，考虑使用rename-command增强安全性。



repl-diskless-sync no

###### 同步策略

- repl-diskless-sync: 控制全量复制时是否采用无盘复制（diskless replication）。默认no，表示使用基于磁盘的复制方式。无盘复制减少了I/O操作，适合于网络带宽充足且磁盘速度较慢的场景。
- repl-diskless-sync-delay: 当使用无盘复制时，主节点等待额外的秒数以允许更多从节点连接，从而可能并行传输RDB文件。

\# repl-timeout 60

###### 心跳与超时

- repl-ping-replica-period: 从节点向主节点发送PING的心跳间隔，默认10秒。
- repl-timeout: 复制超时时间，影响SYNC期间的I/O超时、主从间数据交换及心跳检测，默认60秒。

\# repl-backlog-ttl 3600

###### 复制积压缓冲区

- repl-backlog-size: 控制复制积压缓冲区的大小，用于部分重同步，减少完全重同步的需要，默认1MB。
- repl-backlog-ttl: 没有从节点连接后，复制积压缓冲区自动释放前等待的秒数，默认3600秒（1小时）。

replica-priority 100

###### 从节点优先级

- replica-priority: 影响Redis Sentinel选择从节点晋升为主节点时的决策，默认为100，值越低优先级越高。0表示该从节点不应被晋升。

\# min-replicas-max-lag is set to 10.

###### 主节点写入限制

- min-replicas-to-write 和 min-replicas-max-lag: 如之前解释，控制主节点在继续接受写入前需要的最低从节点连接数及其数据最大滞后时间。

##### 主从复制REPLICATION #################################

这段配置文件内容详细描述了Redis的REPLICATION（复制）相关设置，用于控制主节点（Master）和从节点（Replica，也常称作Slave）之间的复制行为。

\# Master-Replica replication. Use replicaof to make a Redis instance a copy of
 \# another Redis server. A few things to understand ASAP about Redis replication.
 \#
 \#   +------------------+      +---------------+
 \#   |      Master      | ---> |    Replica    |
 \#   | (receive writes) |      |  (exact copy) |
 \#   +------------------+      +---------------+
 \#
 \# 1) Redis replication is asynchronous, but you can configure a master to
 \#    stop accepting writes if it appears to be not connected with at least
 \#    a given number of replicas.
 \# 2) Redis replicas are able to perform a partial resynchronization with the
 \#    master if the replication link is lost for a relatively small amount of
 \#    time. You may want to configure the replication backlog size (see the next
 \#    sections of this file) with a sensible value depending on your needs.
 \# 3) Replication is automatic and does not need user intervention. After a
 \#    network partition replicas automatically try to reconnect to masters
 \#    and resynchronize with them.
 \#
 \# replicaof `<masterip> <masterport>`

###### 主从复制基础

- replicaof: 用于设置从节点要复制的主节点的IP地址和端口号，格式为replicaof `<masterip> <masterport>`。这建立了主从关系，使从节点成为主节点的一个副本。

\# If the master is password protected (using the "requirepass" configuration
 \# directive below) it is possible to tell the replica to authenticate before
 \# starting the replication synchronization process, otherwise the master will
 \# refuse the replica request.
 \#
 \# masterauth `<master-password>`

###### 认证与安全性

- masterauth: 如果主节点设置了访问密码（通过requirepass指令），这里需要配置相同的密码，以便从节点能够成功进行身份验证并开始复制过程。

\# When a replica loses its connection with the master, or when the replication
 \# is still in progress, the replica can act in two different ways:
 \#
 \# 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
 \#    still reply to client requests, possibly with out of date data, or the
 \#    data set may just be empty if this is the first synchronization.
 \#
 \# 2) if replica-serve-stale-data is set to 'no' the replica will reply with
 \#    an error "SYNC with master in progress" to all the kind of commands
 \#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
 \#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
 \#    COMMAND, POST, HOST: and LATENCY.
 \#
 replica-serve-stale-data yes

###### 处理过时数据

- replica-serve-stale-data: 决定当从节点与主节点失去联系时，是否继续响应客户端的读请求。如果设置为yes（默认），即使数据可能陈旧或不完整，从节点仍会尝试服务客户端；设置为no，则在同步过程中返回错误。

\# You can configure a replica instance to accept writes or not. Writing against
 \# a replica instance may be useful to store some ephemeral data (because data
 \# written on a replica will be easily deleted after resync with the master) but
 \# may also cause problems if clients are writing to it because of a
 \# misconfiguration.
 \#
 \# Since Redis 2.6 by default replicas are read-only.
 \#
 \# Note: read only replicas are not designed to be exposed to untrusted clients
 \# on the internet. It's just a protection layer against misuse of the instance.
 \# Still a read only replica exports by default all the administrative commands
 \# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
 \# security of read only replicas using 'rename-command' to shadow all the
 \# administrative / dangerous commands.
 replica-read-only yes

###### 只读从节点

- replica-read-only: 默认设置为yes，意味着从节点拒绝执行写操作，以此作为保护措施防止误操作。虽然名为“只读”，但请注意，某些管理命令依然可执行，考虑使用rename-command增强安全性。

\# Replication SYNC strategy: disk or socket.
 \#
 \# -------------------------------------------------------
 \# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
 \# -------------------------------------------------------
 \#
 \# New replicas and reconnecting replicas that are not able to continue the replication
 \# process just receiving differences, need to do what is called a "full
 \# synchronization". An RDB file is transmitted from the master to the replicas.
 \# The transmission can happen in two different ways:
 \#
 \# 1) Disk-backed: The Redis master creates a new process that writes the RDB
 \#                 file on disk. Later the file is transferred by the parent
 \#                 process to the replicas incrementally.
 \# 2) Diskless: The Redis master creates a new process that directly writes the
 \#              RDB file to replica sockets, without touching the disk at all.
 \#
 \# With disk-backed replication, while the RDB file is generated, more replicas
 \# can be queued and served with the RDB file as soon as the current child producing
 \# the RDB file finishes its work. With diskless replication instead once
 \# the transfer starts, new replicas arriving will be queued and a new transfer
 \# will start when the current one terminates.
 \#
 \# When diskless replication is used, the master waits a configurable amount of
 \# time (in seconds) before starting the transfer in the hope that multiple replicas
 \# will arrive and the transfer can be parallelized.
 \#
 \# With slow disks and fast (large bandwidth) networks, diskless replication
 \# works better.
 repl-diskless-sync no

###### 同步策略

- repl-diskless-sync: 控制全量复制时是否采用无盘复制（diskless replication）。默认no，表示使用基于磁盘的复制方式。无盘复制减少了I/O操作，适合于网络带宽充足且磁盘速度较慢的场景。
- repl-diskless-sync-delay: 当使用无盘复制时，主节点等待额外的秒数以允许更多从节点连接，从而可能并行传输RDB文件。

\# When diskless replication is enabled, it is possible to configure the delay
 \# the server waits in order to spawn the child that transfers the RDB via socket
 \# to the replicas.
 \#
 \# This is important since once the transfer starts, it is not possible to serve
 \# new replicas arriving, that will be queued for the next RDB transfer, so the server
 \# waits a delay in order to let more replicas arrive.
 \#
 \# The delay is specified in seconds, and by default is 5 seconds. To disable
 \# it entirely just set it to 0 seconds and the transfer will start ASAP.
 repl-diskless-sync-delay 5

\# Replicas send PINGs to server in a predefined interval. It's possible to change
 \# this interval with the repl_ping_replica_period option. The default value is 10
 \# seconds.
 \#
 \# repl-ping-replica-period 10

\# The following option sets the replication timeout for:
 \#
 \# 1) Bulk transfer I/O during SYNC, from the point of view of replica.
 \# 2) Master timeout from the point of view of replicas (data, pings).
 \# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
 \#
 \# It is important to make sure that this value is greater than the value
 \# specified for repl-ping-replica-period otherwise a timeout will be detected
 \# every time there is low traffic between the master and the replica.
 \#
 \# repl-timeout 60

###### 心跳与超时

- repl-ping-replica-period: 从节点向主节点发送PING的心跳间隔，默认10秒。
- repl-timeout: 复制超时时间，影响SYNC期间的I/O超时、主从间数据交换及心跳检测，默认60秒。

\# Disable TCP_NODELAY on the replica socket after SYNC?
 \#
 \# If you select "yes" Redis will use a smaller number of TCP packets and
 \# less bandwidth to send data to replicas. But this can add a delay for
 \# the data to appear on the replica side, up to 40 milliseconds with
 \# Linux kernels using a default configuration.
 \#
 \# If you select "no" the delay for data to appear on the replica side will
 \# be reduced but more bandwidth will be used for replication.
 \#
 \# By default we optimize for low latency, but in very high traffic conditions
 \# or when the master and replicas are many hops away, turning this to "yes" may
 \# be a good idea.
 repl-disable-tcp-nodelay no

###### 网络优化

- repl-disable-tcp-nodelay: 是否禁用TCP_NODELAY选项，默认no。禁用可以减少带宽使用但增加数据到达延迟，适用于高流量或远距离通信。

\# Set the replication backlog size. The backlog is a buffer that accumulates
 \# replica data when replicas are disconnected for some time, so that when a replica
 \# wants to reconnect again, often a full resync is not needed, but a partial
 \# resync is enough, just passing the portion of data the replica missed while
 \# disconnected.
 \#
 \# The bigger the replication backlog, the longer the time the replica can be
 \# disconnected and later be able to perform a partial resynchronization.
 \#
 \# The backlog is only allocated once there is at least a replica connected.
 \#
 \# repl-backlog-size 1mb

\# After a master has no longer connected replicas for some time, the backlog
 \# will be freed. The following option configures the amount of seconds that
 \# need to elapse, starting from the time the last replica disconnected, for
 \# the backlog buffer to be freed.
 \#
 \# Note that replicas never free the backlog for timeout, since they may be
 \# promoted to masters later, and should be able to correctly "partially
 \# resynchronize" with the replicas: hence they should always accumulate backlog.
 \#
 \# A value of 0 means to never release the backlog.
 \#
 \# repl-backlog-ttl 3600

###### 复制积压缓冲区

- repl-backlog-size: 控制复制积压缓冲区的大小，用于部分重同步，减少完全重同步的需要，默认1MB。
- repl-backlog-ttl: 没有从节点连接后，复制积压缓冲区自动释放前等待的秒数，默认3600秒（1小时）。

\# The replica priority is an integer number published by Redis in the INFO output.
 \# It is used by Redis Sentinel in order to select a replica to promote into a
 \# master if the master is no longer working correctly.
 \#
 \# A replica with a low priority number is considered better for promotion, so
 \# for instance if there are three replicas with priority 10, 100, 25 Sentinel will
 \# pick the one with priority 10, that is the lowest.
 \#
 \# However a special priority of 0 marks the replica as not able to perform the
 \# role of master, so a replica with priority of 0 will never be selected by
 \# Redis Sentinel for promotion.
 \#
 \# By default the priority is 100.
 replica-priority 100

###### 从节点优先级

- replica-priority: 影响Redis Sentinel选择从节点晋升为主节点时的决策，默认为100，值越低优先级越高。0表示该从节点不应被晋升。

\# It is possible for a master to stop accepting writes if there are less than
 \# N replicas connected, having a lag less or equal than M seconds.
 \#
 \# The N replicas need to be in "online" state.
 \#
 \# The lag in seconds, that must be <= the specified value, is calculated from
 \# the last ping received from the replica, that is usually sent every second.
 \#
 \# This option does not GUARANTEE that N replicas will accept the write, but
 \# will limit the window of exposure for lost writes in case not enough replicas
 \# are available, to the specified number of seconds.
 \#
 \# For example to require at least 3 replicas with a lag <= 10 seconds use:
 \#
 \# min-replicas-to-write 3
 \# min-replicas-max-lag 10

\#
 \# Setting one or the other to 0 disables the feature.
 \#
 \# By default min-replicas-to-write is set to 0 (feature disabled) and
 \# min-replicas-max-lag is set to 10.

###### 主节点写入限制

- min-replicas-to-write 和 min-replicas-max-lag: 如之前解释，控制主节点在继续接受写入前需要的最低从节点连接数及其数据最大滞后时间。

\# A Redis master is able to list the address and port of the attached
 \# replicas in different ways. For example the "INFO replication" section
 \# offers this information, which is used, among other tools, by
 \# Redis Sentinel in order to discover replica instances.
 \# Another place where this info is available is in the output of the
 \# "ROLE" command of a master.
 \#
 \# The listed IP and address normally reported by a replica is obtained
 \# in the following way:
 \#
 \#   IP: The address is auto detected by checking the peer address
 \#   of the socket used by the replica to connect with the master.
 \#
 \#   Port: The port is communicated by the replica during the replication
 \#   handshake, and is normally the port that the replica is using to
 \#   listen for connections.
 \#
 \# However when port forwarding or Network Address Translation (NAT) is
 \# used, the replica may be actually reachable via different IP and port
 \# pairs. The following two options can be used by a replica in order to
 \# report to its master a specific set of IP and port, so that both INFO
 \# and ROLE will report those values.
 \#
 \# There is no need to use both the options if you need to override just
 \# the port or the IP address.
 \#
 \# replica-announce-ip 5.5.5.5
 \# replica-announce-port 1234

###### 从节点宣告地址

- 配置允许从节点向主节点宣告不同于实际连接地址和端口的信息，以适应NAT或代理环境。

- 特殊网络环境适应：在使用端口转发或网络地址转换（NAT）的环境中，从节点实际可访问的IP地址和端口可能与它们连接主节点时显示的不同。为解决这个问题，Redis提供了两个配置项：

  replica-announce-ip: 允许从节点指定一个不同的IP地址，使得主节点在通过INFO或ROLE命令报告从节点信息时，使用这个宣告的IP地址而非自动检测的地址。

- replica-announce-port: 类似地，此配置项让从节点能够声明一个不同于实际用于连接主节点的监听端口的端口号。这确保了监控和管理工具能够使用正确的端口访问从节点。